#! /bin/sh -

ACTION=
FORCEP="NO"
DOT_EMACS_VERSION="master"	# Commit/Branch/Tag for the in-used dot-emacs, will be override by current branch

IN_USE_HEAD="dot-emacs-in-use" 	# A branch to track the in-used dot-emacs. Why not make a list of heads, and allow switching between them? Maybe next task:)

TARGET_DOT_FILE=~/.emacs
TARGET_DOT_DIR=~/.emacs.d

SRC_DOT_FILE=$(pwd)/.emacs
SRC_DOT_DIR=$(pwd)/.emacs.d

RET_OK=0
RET_ERR=1
RET_CODE=0
ERR_DOT_LINK_TARGET_OR_SRC_EMPTY=1
ERR_DOT_LINK_TARGET_EMPTY=2
ERR_OTHER_CONFIGURATION_METHOD_CONFLICT=3
ERR_DOT_EMACS_TARGET_LINK_EXIST=4
ERR_DOT_LINK_CREATE_FAILED=5
ERR_GIT_REPOSITORY_INVALID=6
ERR_GIT_COMMIT_INVALID=7
ERR_INVALID_PARAMETER=8
ERR_CALC_SHA1SUM_FAILED=9
ERR_HEAD_NOT_IN_USE=10
ERR_CREATE_IN_USE_HEAD_FAILED=11
ERR_REMOVE_IN_USE_HEAD_FAILED=12
ERR_SWITCH_IN_USE_HEAD_FAILED=13
ERR_EMPTY_ERROR_CODE=14
ERR_CREATEE_IN_USE_HEAD_FAILED_TRY_FORCE=15
ERR_NO_VALID_TRACKING_BRANCH=16
ERR_CURRENT_BRANCH_NOT_FOUND=17
ERR_CANNOT_BRANCH_FROM_MYSELF=18

errorp()
{
    local errno=
    if [ -z $1 ]
    then
	errno=$ERR_EMPTY_ERROR_CODE
    else
	errno=$1
    fi
    
    echo "ERROR"
    echo -n "  - ["
    case $errno in 
	$ERR_DOT_LINK_TARGET_OR_SRC_EMPTY)
	    echo -n "Specified target links or src files are empty"
	    ;;
	$ERR_DOT_LINK_TARGET_EMPTY)
	    echo -n "Specified target links are empty"
	    ;;
	$ERR_OTHER_CONFIGURATION_METHOD_CONFLICT)
	    echo -n "Other configuration method in use"
	    ;;
	$ERR_DOT_EMACS_TARGET_LINK_EXIST)
	    echo -n "Specified target links exist, use -force to forcibly install"
	    ;;
	$ERR_DOT_LINK_CREATE_FAILED)
	    echo -n "Link can not be created"
	    ;;
	$ERR_GIT_REPOSITORY_INVALID)
	    echo -n "Specified repository of dot-emacs invalid"
	    ;;
	$ERR_GIT_COMMIT_INVALID)
	    echo -n "Specified commit of dot-emacs invalid"
	    ;;
	$ERR_INVALID_PARAMETER)
	    echo -n "Invalid parameter"
	    ;;
	$ERR_CALC_SHA1SUM_FAILED)
	    echo -n "Calculate sha1sum failed"
	    ;;
	$ERR_HEAD_NOT_IN_USE)
	    echo -n "Specified commit for branch is not in use"
	    ;;
	$ERR_CREATE_IN_USE_HEAD_FAILED)
	    echo -n "dot-emacs branch can not be created"
	    ;;
	$ERR_REMOVE_IN_USE_HEAD_FAILED)
	    echo -n "dot-emacs branch can not be removed"
	    ;;
	$ERR_SWITCH_IN_USE_HEAD_FAILED)
	    echo -n "dot-emacs branch can not be switched"
	    ;;
	$ERR_EMPTY_ERROR_CODE)
	    echo -n "Empty error code"
	    ;;
	$ERR_CREATEE_IN_USE_HEAD_FAILED_TRY_FORCE)
	    echo -n "dot-emacs branch can not be created, use -force to forcibly create"
	    ;;
	$ERR_NO_VALID_TRACKING_BRANCH)
	    echo -n "No valid local upstream"
	    ;;
	$ERR_CURRENT_BRANCH_NOT_FOUND)
	    echo -n "Current branch not found"
	    ;;
	$ERR_CANNOT_BRANCH_FROM_MYSELF)
	    echo -n "Cannot branch from myself"
	    ;;
	*)
	    echo -n "Unknown error"
	    ;;
    esac
    echo "]"
}
repository_ok_p()
{
    git rev-parse master 1>/dev/null 2>&1
    if [ $? != 0 ]
    then
	RET_CODE=$ERR_GIT_REPOSITORY_INVALID
	return $RET_ERR
    fi

    RET_CODE=$RET_OK
    return $RET_OK
}
commit_ok_p()
{
    if [ -z $1 ]
    then
	RET_CODE=$ERR_INVALID_PARAMETER
	return $RET_ERR
    fi

    git rev-parse $1 1>/dev/null 2>&1
    if [ $? != 0 ]
    then
	RET_CODE=$ERR_GIT_COMMIT_INVALID
	return $RET_ERR
    fi

    RET_CODE=$RET_OK
    return $RET_OK
}
current_branch()
{
    repository_ok_p
    if [ $? != 0 ]
    then
	return $RET_ERR
    fi

    local current=
    current=$(git branch \
	| grep -o -E "^\*[[:space:]]+[^[:space:]]+[[:space:]]*$" \
	| sed "s/^\*[[:space:]]*//")

    validp=$(git branch \
	| grep -o -E $current)
    
    if [ -z "$current" -o -z "$validp" -o x$current != x$validp ]
    then 
	echo "master"
	RET_CODE=$ERR_CURRENT_BRANCH_NOT_FOUND
	return $RET_ERR
    else 
	echo $current

	RET_CODE=$RET_OK
	return $RET_OK
    fi

}
DOT_EMACS_VERSION=$(current_branch)
branch_local_upstream()		# Use branch --track to for local upstream
{
    if [ -z $1 ]
    then
	RET_CODE=$ERR_INVALID_PARAMETER
	return $RET_ERR
    fi
    
    commit_ok_p $1
    if [ $? != 0 ]
    then
	return $RET_ERR
    fi

    local upstream=
    upstream=$(git branch -vv \
	| grep -E "^\*?[[:space:]]+$1[[:space:]]+" \
	| grep -o "\\[\([^][]*\)\\]" \
	| sed "s/\\[\([^][]*\)\\]/\1/" \
	| cut -d ':' -f1)
    
    validp=$(git branch \
	| grep -o -E $upstream)
    
    if [ -z "$upstream" -o -z "$validp" -o x$upstream != x$validp ]
    then 
	RET_CODE=$ERR_NO_VALID_TRACKING_BRANCH
	return $RET_ERR
    else 
	echo $upstream

	RET_CODE=$RET_OK
	return $RET_OK
    fi
}
calc_short_sha1sum()
{
    if [ $# = 0 ]
    then
	RET_CODE=$ERR_INVALID_PARAMETER
	return $RET_ERR
    fi
    echo "$@" | sha1sum | cut -c1-5
    
    if [ $? != 0 ]
    then
	RET_CODE=$ERR_CALC_SHA1SUM_FAILED
	return $RET_ERR
    fi

    RET_CODE=$RET_OK
    return $RET_OK
}
IN_USE_HEAD=$IN_USE_HEAD-$(calc_short_sha1sum $IN_USE_HEAD)
has_in_use_head_p()
{
    git branch -a | grep $IN_USE_HEAD 1>/dev/null 2>&1
    if [ $? != 0 ]
    then
	RET_CODE=$ERR_HEAD_NOT_IN_USE
	return $RET_ERR
    fi
    RET_CODE=$RET_OK
    return $RET_OK
}
create_in_use_head()
{
    local discardp=
    local argnum=$#

    if [ x$1 = x"YES" ]
    then 
	discardp=-f
    fi

    has_in_use_head_p

    if [ $? != 0 -a $RET_CODE = $ERR_HEAD_NOT_IN_USE ]
    then
	git checkout -tb $discardp $IN_USE_HEAD $DOT_EMACS_VERSION 1>/dev/null 2>&1
    else
	git checkout $discardp master 1>/dev/null 2>&1 \
	    && git branch -D $IN_USE_HEAD 1>/dev/null 2>&1 \
	    && git checkout -tb $discardp $IN_USE_HEAD $DOT_EMACS_VERSION 1>/dev/null 2>&1
    fi

    if [ $? != 0 ]
    then
	if [ $# != 0 -a -z $discardp ]
	then 
	    RET_CODE=$ERR_CREATEE_IN_USE_HEAD_FAILED_TRY_FORCE
	else
	    RET_CODE=$ERR_CREATEE_IN_USE_HEAD_FAILED
	fi
	return $RET_ERR
    fi

    RET_CODE=$RET_OK
    return $RET_OK
}
switch_in_use_head()
{
    has_in_use_head_p

    if [ $? = 0 -a $RET_CODE != $ERR_HEAD_NOT_IN_USE ]
    then
	git checkout $IN_USE_HEAD 1>/dev/null 2>&1
    else
	return $RET_ERR
    fi

    if [ $? != 0 ]
    then
	RET_CODE=$ERR_SWITCH_IN_USE_HEAD_FAILED
	return $RET_ERR
    fi

    RET_CODE=$RET_OK
    return $RET_OK
}
remove_in_use_head()
{
    has_in_use_head_p
    if [ $? != 0 -a $RET_CODE = $ERR_HEAD_NOT_IN_USE ]
    then
	return $RET_ERR
    fi
    
    local upstream=$(branch_local_upstream $IN_USE_HEAD)
    if [ -z "$upstream" -o $? != 0 ]
    then 
	upstream=master
    fi

    git checkout $upstream 1>/dev/null 2>&1 \
	    && git branch -D $IN_USE_HEAD 1>/dev/null 2>&1

    if [ $? != 0 ]
    then
	RET_CODE=$ERR_REMOVE_IN_USE_HEAD_FAILED 
	return $RET_ERR
    fi

    RET_CODE=$RET_OK
    return $RET_OK
}
create_dot_links()
{
    if [ -z $TARGET_DOT_FILE -o -z $TARGET_DOT_DIR -o -z $SRC_DOT_FILE -o -z $SRC_DOT_DIR ]
    then
	RET_CODE=$ERR_DOT_LINK_TARGET_OR_SRC_EMPTY
	return $RET_ERR
    fi

    if [ -f $TARGET_DOT_FILE -a ! -L $TARGET_DOT_FILE ] || [ -d $TARGET_DOT_DIR -a ! -L $TARGET_DOT_DIR ]
    then
	RET_CODE=$ERR_OTHER_CONFIGURATION_METHOD_CONFLICT
	return $RET_ERR
    fi

    if [ -L $TARGET_DOT_FILE -o -L $TARGET_DOT_DIR ]
    then
	RET_CODE=$ERR_DOT_EMACS_TARGET_LINK_EXIST
	return $RET_ERR
    fi
    
    ln -s $SRC_DOT_FILE $TARGET_DOT_FILE && ln -s $SRC_DOT_DIR $TARGET_DOT_DIR
    
    if [ $? != 0 ]		# When failed, ensure no partly created actions
    then
	rm -f $TARGET_DOT_FILE
	rm -f $TARGET_DOT_DIR
	RET_CODE=$ERR_DOT_LINK_CREATE_FAILED
	return $RET_ERR
    fi

    RET_CODE=$RET_OK
    return $RET_OK
}
remove_dot_links()
{
    if [ -z $TARGET_DOT_FILE -o -z $TARGET_DOT_DIR ]
    then
	RET_CODE=$ERR_DOT_LINK_TARGET_EMPTY
	return $RET_ERR
    fi

    if [ -f $TARGET_DOT_FILE -a ! -L $TARGET_DOT_FILE ] || [ -d $TARGET_DOT_DIR -a ! -L $TARGET_DOT_DIR ]
    then
	RET_CODE=$ERR_OTHER_CONFIGURATION_METHOD_CONFLICT
	return $RET_ERR
    fi

    if [ -L $TARGET_DOT_FILE ]
    then
	rm -f $TARGET_DOT_FILE
    fi

    if [ -L $TARGET_DOT_DIR ]
    then
	rm -f $TARGET_DOT_DIR
    fi

    RET_CODE=$RET_OK
    return $RET_OK
}
switch()
{
    echo -n "Branch $IN_USE_HEAD from "
    echo "upstream $DOT_EMACS_VERSION"

    if [ x$IN_USE_HEAD = x$DOT_EMACS_VERSION ]
    then
	RET_CODE=$ERR_CANNOT_BRANCH_FROM_MYSELF
	return $RET_ERR
    fi

    echo -n "Check repository: "
    repository_ok_p
    if [ $? = $RET_ERR ]
    then
	return $RET_ERR
    fi
    echo "OK"

    echo -n "Check specified commit: "
    commit_ok_p $DOT_EMACS_VERSION
    if [ $? = $RET_ERR ]
    then
	return $RET_ERR
    fi
    echo "OK"

    if [ x$FORCEP = x"YES" ]
    then 
	echo -n "Forcibly checkout"
    else
	echo -n "Checkout"
    fi
    echo -n " specified commit as branch in use: "

    create_in_use_head $FORCEP
    if [ $? = $RET_ERR ]
    then
	return $RET_ERR
    fi
    echo "OK"
    
    RET_CODE=$RET_OK
    return $RET_OK
}
install()
{
    echo "Make links from $TARGET_DOT_FILE to $SRC_DOT_FILE"
    echo "     links from $TARGET_DOT_DIR to $SRC_DOT_DIR"

    if [ x$FORCEP = x"YES" ]
    then
	echo -n "Forcibly remove original links: "
	remove_dot_links
	if [ $? = $RET_ERR ]
	then
	    return $RET_ERR
	fi
	echo "OK"
    fi
    
    echo -n "Create links: "
    create_dot_links
    if [ $? = $RET_ERR ]
    then
	return $RET_ERR
    fi
    echo "OK"
    
    switch
    if [ $? != 0 ]
    then
	local tmp_code=$RET_CODE
	remove_dot_links
	RET_CODE=$tmp_code
	return $RET_ERR
    fi

    RET_CODE=$RET_OK
    return $RET_OK
}
uninstall()
{
    echo -n "Remove links: "
    remove_dot_links
    if [ $? = $RET_ERR ]
    then
	errorp $RET_CODE
    else
	echo "OK"
    fi

    echo -n "Remove dot-emacs branch in use (back to upstream): "
    remove_in_use_head
    if [ $? = $RET_ERR ]
    then
	return $RET_ERR
    fi
    echo "OK"

    RET_CODE=$RET_OK
    return $RET_OK
}
dist()
{
    echo -n "Check repository: "
    repository_ok_p
    if [ $? = $RET_ERR ]
    then
	return $RET_ERR
    fi
    echo "OK"

    echo -n "Check specified commit: "
    commit_ok_p $DOT_EMACS_VERSION
    if [ $? = $RET_ERR ]
    then
	return $RET_ERR
    fi
    echo "OK"
    
    ARC_NAME=dot-emacs-on-$DOT_EMACS_VERSION-$(date +%Y%m%d%H%M%S).tar.gz
    echo -n "Archiving commit/branch: "
    echo $DOT_EMACS_VERSION
    echo -n "Generating "$ARC_NAME": "
    mkdir -p dist && git archive --format=tar.gz $DOT_EMACS_VERSION > dist/$ARC_NAME
    if [ $? = $RET_ERR ]
    then
	return $RET_ERR
    fi
    echo "OK"
}
clean()
{
    echo -n "Check repository: "
    repository_ok_p
    if [ $? = $RET_ERR ]
    then
	return $RET_ERR
    fi
    echo "OK"

    echo "Cleanning: "
    git clean -d -x -f -f
    echo "Done."
}
usage()
{
    echo "Usage: $(basename $0) [OPTION]"
    echo "Install/Uninstall dot-emacs branch (links) to user's home directory"
    echo "    -i [commit], --install[=commit]     Create links and commit-specified (current by default) dot-emacs branch"
    echo "    -s [commit], --switch[=commit]      Switch to commit-specified (current by default) dot-emacs branch"
    echo "    -f, --force                         Force to install"
    echo "    -u, --uninstall                     Remove links and dot-emacs branch"
    echo "    -d, --dist                          Make distribution archive (on current branch by default)"
    echo "    -c, --clean                         Clean up working directory"
    echo "    -h, --help                          Output this help"
    exit 1
}
#args=`getopt -o "isfuh" -l"install,switch,force,uninstall,help" $* 2>/dev/null` # process long options
#[ $? != 0 ] && usage
#set -- $args
#Kludge: I need optional argument for install!
set -- "$@" --
while [ $# -gt 0 ]
do
    case $1 in
	-i|--install*)
	    if echo "$1" | grep "^--install=" 1>/dev/null 2>&1 # CASE1: --option=argument
	    then
		DOT_EMACS_VERSION=$(echo "$1" | sed -r s/--[^-=]+=//)
	    fi

	    echo "$2" | grep -E '^=$' 1>/dev/null 2>&1 # CASE2: --option = argument
	    if [ $? = 0 ]
	    then
		shift
	    fi

	    echo "$2" | grep -E '^-.?$|^--.*$' 1>/dev/null 2>&1 # CASE3: --option =argument
	    if [ $? != 0 ]
	    then
		shift
		DOT_EMACS_VERSION=$(echo -n "$1" | tr -d "=")
	    fi

	    if [ -z $ACTION ]
	    then
		ACTION="INSTALL"
	    else
		usage
	    fi
	    ;;
	-s|--switch*)
	    if echo "$1" | grep "^--switch=" 1>/dev/null 2>&1
	    then
		DOT_EMACS_VERSION=$(echo "$1" | sed -r s/--[^-=]+=//)
	    fi

	    echo "$2" | grep -E '^=$' 1>/dev/null 2>&1
	    if [ $? = 0 ]
	    then
		shift
	    fi

	    echo "$2" | grep -E '^-.?$|^--.*$' 1>/dev/null 2>&1
	    if [ $? != 0 ]
	    then
		shift
		DOT_EMACS_VERSION=$(echo -n "$1" | tr -d "=")
	    fi

	    if [ -z $ACTION ]
	    then
		ACTION="SWITCH"
	    else
		usage
	    fi
	    ;;
	-f|--force)
	    FORCEP="YES"
	    ;;
	-u|--uninstall)
	    if [ -z $ACTION ]
	    then
		ACTION="UNINSTALL"
	    else
		usage
	    fi
	    ;;
	-d|--dist*)
	    if echo "$1" | grep "^--dist=" 1>/dev/null 2>&1 # CASE1: --option=argument
	    then
		DOT_EMACS_VERSION=$(echo "$1" | sed -r s/--[^-=]+=//)
	    fi

	    echo "$2" | grep -E '^=$' 1>/dev/null 2>&1 # CASE2: --option = argument
	    if [ $? = 0 ]
	    then
		shift
	    fi

	    echo "$2" | grep -E '^-.?$|^--.*$' 1>/dev/null 2>&1 # CASE3: --option =argument
	    if [ $? != 0 ]
	    then
		shift
		DOT_EMACS_VERSION=$(echo -n "$1" | tr -d "=")
	    fi

	    if [ -z $ACTION ]
	    then
		ACTION="DIST"
	    else
		usage
	    fi
	    ;;
	-c|--clean*)
	    if [ -z $ACTION ]
	    then
		ACTION="CLEAN"
	    else
		usage
	    fi
	    ;;
	-h|--help|'?'|':')
	    usage
	    ;;
    esac
    shift
done

case $ACTION in
    INSTALL)
	install
	if [ $? != 0 ]
	then
	    errorp $RET_CODE
	fi
	;;
    SWITCH)
	switch
	if [ $? != 0 ]
	then
	    errorp $RET_CODE
	fi
	;;
    UNINSTALL)
	uninstall
	if [ $? != 0 ]
	then
	    errorp $RET_CODE
	fi
	;;
    DIST)
	dist
	if [ $? != 0 ]
	then
	    errorp $RET_CODE
	fi
	;;
    CLEAN)
	clean
	if [ $? != 0 ]
	then
	    errorp $RET_CODE
	fi
	;;
    *)
	usage
	;;
esac

#Kludge: Test goes here, maybe a suite of test cases should be more appropriate :)
# repository_ok_p
# commit_ok_p
# calc_short_sha1sum 'asdf asdf'
# has_in_use_head_p
# create_in_use_head
# remove_in_use_head
# switch_in_use_head
# branch_local_upstream "master"
# current_branch
