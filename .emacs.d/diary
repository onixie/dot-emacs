Aug 20, 2010 Swap Caps Lock and left Ctrl under X11
1. edit .xmodmap under your home dir; add:
remove Lock = Caps_Lock
remove Control = Control_L
keysym Control_L = Caps_Lock
keysym Caps_Lock = Control_L
add Lock = Caps_Lock
add Control = Control_L

2. edit /etc/rc.local; add:
xmodmap ~/.xmodmap 2 > /dev/null

Aug 21, 2010 Rule For Software Tool
1. Only Do One Thing At A Time
2. Process Text Not Binary
3. Use Regular Expression(Posix Support Two Form: Bre And Ere)
4. Use Standard Output/Input As Default
5. Don'T Bothering(No Need Interaction)
6. Make Output Format Consistent With Required Input Format
7. Let Tool To Do The Most Difficult Thing
8. Before Create Specialized Tool, Think More

Aug 25, 2010 Emacs Basics
Emacs Regex Function
      (string-match REGEXP STRING &optional START)
      (match-string NUM &optional STRING)
      (match-end SUBEXP)
      (match-beginning SUBEXP)
Emacs Hook Function
      (add-hook HOOK FUNCTION &optional APPEND LOCAL)
      (run-hooks &rest HOOKS)
      (run-hook-with-args HOOK &rest ARGS)
Emacs Compile Function
      (compile COMMAND &optional COMINT)

Aug 30, 2010 Shell Programming - trap, pid, and print format
1. trap
   fmt: trap "cmd" signal.
   meaning: trap a signal and run the cmd
2. process variable
   $$ variable is process id
3. printf
   %-39s means left-aligning, 39 fixed char length

Aug 31, 2010 Shell Programming - embeded document
1. embedded document
   fmt: use << and EOFILE
   meaning: in a shell script to insert document with variable substitution
2. word dict
   /usr/share/dict/
   /usr/dict/
   /usr/share/lib/dict/
   /usr/local/share/dict

Mar 10, 2011 CUPS debugging technique
1. Attach filter process
   sleep filter until you can attach from gdb
2. Send print result to a file
   1). listen on a local port, "nc -l -p 20000 > filename"
   2). set printer's device uri to this local port, "socket://localhost:20000"
   3). print
3. Use FileDevice URI
   enable FileDevice in /etc/cups/cups.config

Mar 15, 2011 Network Port Range
IANA divides port numbers into three ranges:
0~1023       for common, well-known services, 3FF, On Unix-like operating system, require superuser
1024~49151   for IANA registered services, BFFF
49152~65535  for services not officially designated, such as ephemeral ports, FFFF

Mar 16, 2011 Pipeline subshell: Bash vs Ksh
When doing pipelines, ksh will run each pipeline in current process,
in contrary, bash will run each pipeline in a subshell environment.

This difference direct consequnce is when setting some variable in a pipeline in bash,
it may not reflect the value in the parent scripts.

e.g.
------------------------------------------------
echo "bla bla bla.." | while read one two three
do
    result=$one $two $three
done

echo $result
------------------------------------------------

in ksh, you got bla bla bla..
in bash, you got nothing

Mar 21, 2011 Robotics simulation toolkits
Open Sourced:
ODE, Open Dynamics Engine, written in C++, an open source physics engine, LGPLed or BSD, industrial-quality
Simbad robot simulator, written in Java, featured with an visulization console, GPLed
Teambots, portable multi-agent robotic simulator
Carmen, Carnegie Mellon Robot Navigation Toolkit

Commercial:
Khepera

Jun 8, 2011  Git 断点续传
通过git init && git fetch <url>可以实现git下载的断点续传
git clone不具备这个功能

Jul 25, 2011 SBCL build process
cross compiling phase:
make-host-1  ---->  make-target-1

target system compiling phase:
make-host-2 ----> make-genesis-2  ----> make-target-2

Jul 26, 2011 Git (v1.6.6 above) SMART HTTP PROXY
1. use http_proxy environment variables and http as the clone protocol
2. use GIT_CURL_VERBOSE to output verbose information

Jul 27, 2011 SSH 通过公私钥代替密码登录认证
1. 在.ssh/config文件中，通过IdentityFile使得ssh客户端能够自动选择与登录服务端相匹配的密钥
如：
IdentityFile ~/.ssh/ids/%h/id_rsa
IdentityFile ~/.ssh/id_rsa
2. 创建目录，将私钥按照主机或者用户进行分类存放
3. 在服务器端，.ssh/authorized_keys文件中，每一行记录一个允许通过公私钥登录的客户端对应的公钥

Jul 27, 2011 SSH 常见用法
1. 创建隧道
ssh -N -L2011:localhost:80 somemachine 创建从本地2011到远端80端口的隧道, localhost部分其实指的是服务端
ssh -N -R2011:localhost:80 somemachine 创建从远端2011端口到本地80端口的隧道, localhost指的是本地客户端
可以用nc来进行测试，如：
nc -l -p 80 在某一端监听
nc localhost 2011 发送消息到隧道里

2. 比较远程和本地文件
ssh user@remote cat /path/to/somefile1 | diff /path/to/somefile2 -

3. 将远程的内容复制到粘帖版
ssh user@remote cat /path/to/somefile | xclip

Jul 27, 2011 DBUS的概念
DBUS称为消息总线，分为系统总线和会话总线。
用于实现进程间的1对1通信，连接到总线上的进程通过提供服务和获取服务来交换信息。
服务连接有一个BUS全局名称，而每个连接都有个唯一私有名称，
通过全局名称琐定服务后，指定服务的对象，接口，以及方法来进行信息获取。
dbus-send和dbus-monitor是两个实用的调试工具

Jul 29, 2011 CRON计划任务之at
通过at命令可以进行简单的计划任务
1. at now+1minutes -f <command>
2. at -t "MMDDmmss" -f <command>
如果没有f指定作业文件，则从标准输入中读取

Jul 29, 2011 DBUS的Session地址
在dbus-send的参数里除了--system和--session还有一个--address
这个参数没有很好的文档说明，它实际上就是dbus进行消息传递的文件的地址(socket方式)
另外，还有一个环境变量叫做DBUS_SESSION_BUS_ADDRESS是表示当前session的dbus的地址

最后通过dbus-daemon --print-address也可以显示当前开启的dbus对应的地址

有关session bus address的信息其实存放在~/.dbus/session-bus/$(dbus-uuidgen --get)-[$HOST]-$(DISPLAY)
这个文件里面。

发现一个奇怪的现象，
通过ssh remote dbus-send --sesion ..bla.bla.bla的方式
在ubuntu9.10上返回一个错误，提示说session dbus是null的，
这是由于在ssh运行dbus-send的时候，环境变量可能还没有准备好，
因此，可以通过读取上面的文件来获取dbus

Jul 29, 2011 GIT获取revision和commit信息的相关的命令
git log 获取commit的log信息，通过-p -2可以对最近两个版本进行比较， --since与--until可以对日期进行过滤
git rev-list 获取从某个commit回溯可以到达的revisions的历史列表， 通过--not可以指定过滤显示到达不了的那些历史列表
git rev-parse 显示一个commit的全局唯一哈希码, --short可以仅显示部分这个码
git describe 显示一个revision的tag名，可以是轻量级的，使用--tags, --all, --dirty可以显示各种不同级别的tag, 一般情况下显示离当前签入的commit最近的过去时间中的revision， 如果使用--contain则显示最近的未来时间的revision, --abbrev=0使用短格式显示revision tag

Aug 3, 2011 Send message to users on unix
command:
wall       send all user a message
mesg       disable/enable message receiving
write user [tty]  send a message to a user

Aug 4, 2011 Echo KnowHow
Echo has two options very useful
-n  stop output trailing newline
-e  enable escape character

e.g. echo -ne '\032\032'

Aug 19, 2011 X开发中 Display的指定
OpenDisplay的时候，
host为空的情况，会打开本地默认的0号display，
不管是否指定display，也不管本地默认Xserver是否监听网络，还是限制访问
host为localhost或者本机ip的时候，需要指定display,
并可以在指定display上显示，但前提是该display上的Xserver监听网络，并且无网络限制。


Aug 27, 2011 Emacs Tramp for SSH
C-x C-f and then type /ssh:<user>@<host>:<files>
it can open remote files by ssh.

Nov 16, 2011 LINUX GIT
最近的一些经验：
1. dd_rescue 可以用来从坏扇区恢复一些数据

2. 在1.7以后git可以通过ssl代替ssh推送数据，具体的是在url中指定用户名，git会询问passwd
   如 ：git clone https://myname@github.com/XXX/XXX.git
   这样就等同于使用ssh，可以进行推送了。

3. 使用https协议穿过代理的时候，可以设定http.proxy, http.sslCAInfo, http.sslCAPath等变量
   后两个是指定认证根文件，和目录的所在位置

4. 可以使用--track在本地创建一个跟踪本地upstream的分支，以使用pull，这默认只对远程分支有用
   使用git branch -vv，两个v可以看到upstream

5. 当使用--amend重新commit的时候，切记仅在本地操作，如果已经推送到远程源，那么只能在push的时候--force
   但是这样实际改变了之前的commit

Nov 22, 2011 SBCL
SBCL中关于IR2之后的一些文件
system.lisp定义了一些vop操作, 用于访问vm层的对象和信息
objdef.lisp中定义了在vm层中支持的原生C结构的对象
meta-vmdef.lisp定义了vm.lisp中用于定义SB,SC的操作
vm.lisp定义了SB,SC具体有哪些内容
vop.lisp定义了IR2转换时候的结构对象，SB, SC, TN, Template, VOP-Info等对象结构
assem.lisp和insts.lisp定义了80x86指令结构，具体的操作指令inst，以及对应的op code等信息

一些碰到的名词
Storage Base, Storage Class, Temporary Name, Template, TN-Ref, Effective Address
Virtual Operation, Primitive types, Instruction
emitter, printer, prefilter, generator

Nov 24, 2011 SBCL
在SBCL中定义新的VOP的方法
在SB-VM包中，
首先调用defknown声明该VOP是一个已知的操作
通过define-vop定义新的操作，然后通过defun定义上层函数

如：
声明我的VOP接受一个系统区域指针，返回一个系统区域指针
(defknown myvop (system-area-pointer) system-area-pointer (flushable movable))
定义我的操作，意思是接受线程的系统区域指针，并且返回它 (相当没意义的操作)
(define-vop (myvop)
	 (:args (thread :scs (sap-reg) :target int))
	 (:arg-types system-area-pointer)
	 (:results (int :scs (sap-reg)))
	 (:result-types system-area-pointer)
	 (:translate myvop)
	 (:policy :fast-safe)
	 (:generator 1
		     (move int thread)))
声明高层函数
(defun myvop (thread)
	     (myvop thread))

不明白的是什么是flushable, movable, foldable属性？

Nov 24, 2011 SBCL
SAP相关操作
可以通过SAP-REF-*之类的，来读取某个SAP指针偏移处的内存的内容
另外，对于在C空间中的变量，可以通过alien-sap和extern-alien
来获取它的地址， extern-alien对于类型的要求可以在sb-alien包
中找到，或者使用(* t)，另外还支持对函数的获取，指定函数类型

如对于函数：
(extern-alien "getcwd" (function (* char) (* char) size-t))
如对于变量：
(alien-sap (extern-alien "all_threads"  (* t)))

Nov 28, 2011 SBCL
SBCL编译器叫做Python compiler(和python语言可没关系哦)
编译分为两个阶段phase，分别处理两种不同的中间语言IR:
IR1 (Implicit Continuation Representation)
IR2 (Virtual Machine Representation)

编译器前端frontend主要负责IR1变换，后端backend则负责IR2变换
ICR相当于一个CL的子集，以流程图flow graph的形式描述被编译代码的语法\语义
VMR则是一些虚拟机操作码 (不同体系的汇编)的模板，将代码翻译成虚拟机的语言

================================================================
具体的语言变换过程：

     IR1                    IR2
  /------\    /--------------------------------\
 / 	  \  /   			        \
CL -> ICR -> VMR -> assembly instruction -> OP code

IR1 phase
1. ICR conversion - 进行宏展开和代码到代码的变换，将被编译代码转换为ICR形式 （解决命名冲突问题） - ir1tran, srctran, typetran
2. Local call analysis - 寻找对本地函数的调用，分析关键字参数，将仅调用一次的函数识别为let，创建XEP - locall
3. Find components - 寻找flow graph中的组块component，区分top level和run time代码，确定top level的components - dfo
4. ICR optimization - ir1opt, ir1tran, typetran, seqtran, vm/vm-tran
5. Type constraint propagation - 使用global flow analysis传播lexical 变量的类型信息，取消不必要的类型检查 - constraint
6. Type check generation - 对在后端中比较难检查的类型，产生检查这些类型的ICR代码 - checkgen
7. Event driven operation - 重新计算一些ICR部分 - ir1util, ir1opt
8. ICR finalize - 在所有components都被编译后，寻找全局变量引用中的未定义的变量和不兼容的函数定义 - ir1final, main
9. Environment analysis - 分析需要创建的不同环境以及其上下文， 探测非本地退出以及设置闭包变量 - envanal

IR2 phase
10. Global TN allocation - 遍历所有定义的函数，确定调用规约，给本地变量分配TN - gtn
11. Local TN allocation - 根据类型和policy决定对已知函数使用什么VMR翻译，创建表达式评估时需要的TN - ltn
12. Control analysis - 线性化flow graph，尽量减少其分支。block级的flow graph在这确定下来。 -  control
13. Stack analysis - 针对unknown-values continuation维护堆栈？ - stack
14. Entry analysis - 搜集外部函数调用的信息
15. VMR conversion - 通过将flow graph中的节点转换为VOP将ICR转换为VMR - ir2tran, vmdef
16. Copy propagation - 通过flow analysis删除不需要的TN
17. Representation selection - 根据对TN的引用，确定哪个表示的cost最低。选择相应的VOP
18. Lifetime analysis - 通过flow analysis找到生命期重叠的TN的集合，标注那些需要存储TN的VOP调用 - life
19. Pack - 寻找合适的寄存器分配 - pack
20. Code generation - 调用VOP产生器生成代码 - codegen
21. Pipeline reorganization - assem-opt
22. Assembly - 解决分支，转化为object code以及fixup信息 - assembler
23. Dump - 将编译后的内容输出到object file或者in-core函数 - debug-dump, dump, vm/core
=================================================================

Nov 28, 2011 Compiler, SBCL
- Peephole optimization的意思是针对一段产生的代码中的一小部分指令进行优化，这一小部分指令常称为peephole。
  通常优化是指，识别无效的指令以及选择轻量级的等价指令。

- Partial evaluation是一种在编译期将常量表达式替换掉constant folding的优化方法，该方法不仅优化完整的常量表达式，还根据
  任何代码（表达式）中常量部分对这部分代码整体进行优化，主要表现为常量（值，函数都可）替换，无用表达式的删除，常量条件分支删除等

- Inline expansion是指函数在调用处展开为代码的优化。

- Meta-programming是指通过开发一种语言的特定领域扩展 Domain-specific extension来编程的方法。 (我猜lisp里就是特别指macro编程了吧)

- Block compilation就是在假定全局函数global function不会重定义的情况下，优化掉函数边界。把defuned的函数编译成如flet, labels定义的
  函数块。该优化可以将函数调用转化为本地jump跳转，取消参数检查。另外，也将partial evaluation和type inference的边界扩展到block而不是函数。

Nov 29, 2011 Compiler, Type system
- Type checking是检验类型规则限制的过程，可以发生在编译期，或者运行时。
  - Static typing静态类型，是指在编译器进行类型检查的类型，与之相关的类型检查错误是compile time type error。
  - Dynamic typing动态类型，是指在绝大多数类型检查在运行期间完成，与之相关的类型检查错误是runtime type error。
    动态类型中，一般变量是没有类型的，有类型的是值。
    - Duck typing是OO编程中，源于duck test的概念，即不管是什么对象，只要它走起来，叫起来，游起来像个鸭子，就叫它鸭子。
      是一种动态类型检查，即由当前对象的行为和属性来决定值语义，而不是继承。
  - Strong typing与weak typing是类型系统的另外一个纬度关注的问题。

- Type inference是一种编译期自动对表达式的类型进行部分或者完全推导的功能。编译器通过推导使得显示的类型声明type annotation可以省略掉。一般类型推导用于静态类型语言。

- Polymorpism是OO编程中，指同一个操作可以应用于多个类型的对象，或者同一个数据结构可以包含多个类型的元素。

Nov 29, 2011 SBCL调试
可以通过enable-debugger, disable-debugger, invoke-debugger显示的启用调试 (默认)，禁止调试，以及调用调试
另外通过(define-alien-routine ("ldb_monitor" ldb_monitor) void)定义一个调用low level debugger的函数
可以引起low level debugger.

Nov 29, 2011 Programming, Compiler, First Class
First Class Object

在程序语言中，如果一个对象支持以下内容，它就是一级的：
1. 能够存储到变量或数据结构中
2. 能够作为参数传递给子过程
3. 能够作为子过程的返回值
4. 能够在运行时创建
5. 具备intrinsic identity（唯一的标示？）

具体到特定的程序元素，有
first class function
first class value
first class continuation
first class data type

Dec 27, 2011 从用户的角度控制SBCL编译器
1. 控制编译时输出的信息Verbosity：
基础知识：
在SBCL中有四种编译时的检查输出compiler diagnostic severity: error, warning, style warning, note

前三种都对应的是ANSI CL标准中的condition, 意思是报告编译时发生了错误级别error severity的严重问题。
第四个note通常是编译器提示的一些提示信息hint, 如如何改善代码以达到期望的性能、编译器优化掉的无用代码信息等。

note从condition继承，基类为sb-ext::compiler-note，其中有个子类是code-deletion-note。

对于输出，一般分为6个部分
1. file: 标示错误所在的文件
2. in: 标示错误发生的top level的definition或者form
3. 之后缩进两格的是错误发生的最直接的form的原始代码（未经过宏展开和代码变换的）
   注：这个信息里form是包含错误的最小的form，所以错误只会发生在这个form上，而不会发生在其包含的form中。
4. --> 处理路径processing path， 显示在编译过程中，进行宏展开的每步的动作，该行中的每一个单词是展开一次的最外层的头一个form
5. ==> 展开后的实际出错的代码
6. 错误的类型和错误信息

方法：
a. 通过在declare或者declaim中使用muffle-condition/unmuffle-condition来声明屏蔽输出哪些编译的diagnostics检查
b. 通过修改*compiler-print-variable-alist*来绑定一些*print-xxx*变量来控制编译时的输出
----------------------------------------------------------------------
2. 控制类型检查
默认的情况下，SBCL并不盲目相信声明的类型declared types，而是把他们当成需要在运行期检查的assertions（但因为一些原因，这个规则是有出入的）, 对这些类型声明，将使用如同typep一样的严格精准的检查策略，如果一个对象有多个类型声明，那么每个都必须符合。

类型检查有三类，
全类型检查Full Type Checks, 条件：当优化级别safety>=2 或 safety>=speed>=1时（默认的方式）
弱类型检查Weak Type Checks（简化为检查更宽泛的类型限制）, 条件：当优化级别safety<2并且safety<speed时
无检查No Type Checks, 条件：safety=0
----------------------------------------------------------------------
3. 控制编译器策略
知识：
使用optimize优化声明，可以控制ANSI CL标准定义的四种不同的优化策略：safety, speed, space, debug
通常speed优化策略过高时，编译器会提示用户一些它无法进行的优化提示，以告知修改代码来实现期望的优化。
通常space优化策略影响内联函数的展开，将会增大编译后的代码大小。小心使用space=0，因为编译器会不分情况的进行内联，可能减慢程序执行速度。

方法：
1. 通过declare\declaim声明优化策略
2. 通过declare-compiler-policy输出当前上下文的优化策略
3. 通过restrict-compiler-policy限定指定的策略类型的最小级别。 如果没有指定，将会取消先前的指定（即设定为0），否则设定为1~3中的一个。
4. 通过with-compilation-unit将编译策略声明的影响限定到它的上下文中。
   使用:override有两个作用，其一，延迟其内部的警告的发生，并且当它为false时，未定义的警告会传播到外层的with-compilation-unit，
   它为true时，就会在该层被处理。
   使用:policy可以将其内部的策略绑定到当前的with-compilation-unit环境而不影响全局的策略。

   例子：
   除了safety其他都使用全局的策略，而在该单元内使用safety为2的策略，该策略不影响全局的safety
   (with-compilation-unit (:policy '(optimize））
	   (declaim (optimize (safety 2)))
	   (load "/home/nixie/workspace/source/workdir/lisp/sbclstudy.lisp"))   
   除了safety其他都使用全局策略，safety在该单元内为3 
   (with-compilation-unit (:policy '(optimize safety))
	   (load "/home/nixie/workspace/source/workdir/lisp/sbclstudy.lisp"))
   都使用全局策略，包括safety的改变，会影像全局策略
   (with-compilation-unit (:policy nil)
	   (declaim (optimize (safety 2)))
	   (load "/home/nixie/workspace/source/workdir/lisp/sbclstudy.lisp"))
   都不使用全局策略而使用默认策略，safety在该单元内为3
   (with-compilation-unit (:policy '(optimize safety) :override t)
	   (load "/home/nixie/workspace/source/workdir/lisp/sbclstudy.lisp"))

   注：restrict-compiler-policy并不受with-compilation-unit的影响，因此即便它在其内部，也会对全局起作用

Dec 27, 2011 Open coded vs. Closed coded
所谓Open coded就是指在函数调用的地方，用等价的内联代码（注意这里只是指代码，而不是其他等价的函数调用）替换掉该函数的调用。
所谓Closed coded就是指在函数调用的地方，要么没有等价的替换，要么替换只是变成调用其他等价的函数。

Dec 27, 2011 杂技巧搜集
1. 使用Xephyr实现窗口化X服务
使用Xephyr -ac -br -noreset -screen 800x600 :1&可以打开一个在:1的新的X服务在在当前X服务的一个窗口里。
然后就可以让一些应用连上去看看了。
2. Shell中的路径解析/的定义
POSIX规定一个/代表root目录，多余两个的/如///也应该当成一个/。
而两个/即//是可以由shell的实现决定其含义的。
Bash把//显示为//当作/, Zsh把//显示并且当作/
3. ping的mdev代表的是mean deviation, 是RTT的平均偏差，越大代表网速越不稳定。

Dec 28, 2011 计算理论
1. Turing Machine图灵机
   根据一个表格的规则，读取磁带输入的信息，对符号进行操作的设备。 Universal Turing Machine是能够模拟其他图灵机的图灵机。

   --------------------
   Turing在1948年写了一个简介的定义：
   被分割成一块一块square cell的无限长的磁带infinit tape提供了无限的内存容量，每个symbol都可以存储在一个cell上。
   在一个特定的时刻，只有一个符号在机器中，该符号被称为被扫描的符号(scanned)。机器可以修改这个符号，并且它自己的行为
   也依赖于这个符号，而磁带上的其他符号不能影响当前的机器。最后，磁带是可以前后移动来让机器读取的，这是机器的一个最基本的
   操作。因此，所有的符号都可以被机器扫描。

   对这段还的理解是，图灵机的构成是：
   a. 无限长的磁带（分成cells，每个cells存储有限alphabet中的symbol）
   b. 一个前后可移动的磁头（读写操作）
   c. 一个状态寄存器（记录有限个状态中的一个）
   d. 有限的指令表（迁移函数表）
      根据当前状态和读入指令动作有：移动磁头，读写符号，修改状态。
      deterministic的模型，前两个动作是二选一，最后一个动作是可以结合的；non-deterministic所有动作是可以结合的。
      有些模型里，如果符号和状态的结合没有产生动作，那么机器是可以停止halt。
   --------------------

2. Computable Function可计算的函数
   通过机械的计算设备可以在不限定时间和空间条件下被计算的函数。
   或者说通俗点是有算法描述（一定的计算步骤序列）的函数就是可计算的，它可以用纸和笔在不限定时间和空间等资源的条件下被计算出来。

   --------------------
   在历史上，曾今使用Effectively calculable来代表可计算（但是它是形象的说法）
   
   Rosser在1939年对Effective的描述是：Effective Method是指计算的每一步都是预先确定好的，并且能够在有限步内产生答案的方法。
   这里Effective有1. 能够产生确定的，准确的，期望的效果，2. 并且能够产生一个结果的意思。
   
   Turing在1939年中说:computable function的意思是可以被机器计算的函数，而使用effectively calculable来代表形象的意思在不需要特别
   指明这些定义的情况下。即：
   Every effectively calculable function is a computable function.

   a function is effectively calculable if its value can be found by some purely mechanical process.
   a purely mechanical process one which could be carried out by a machine.

   而Effective calculable的意思就是能够不管什么effective的方法产生的， Effective computable是指被图灵机或等价设备产生的。
   --------------------

   P.S.
3. total vs. partial （函数概念的扩展）
   在数学中，如果一个函数它只能把X的子集X'映射到Y，我们说它是X到Y的一个partial function。
   如果该函数X'就是X，那么它就是一个total function。

   对于partial function来说，在recursion theorists那，domain就是X'；在category theorists那，domain还是X，X'被叫做domain of definition
   
   在可计算理论里面，如果一个可计算函数没有接受所有可能的参数，那么它是partial computable或叫做partial recursive
   否则就是total computable或者叫total recursive

4. Turing Complete图灵完备
   通常说能够模拟turing Machine图灵机的一系列操作规则（系统）的集合是图灵完备的
   （一般有上下文相关文法，递归函数，Lambda算子）。
  
   Turing Completeness
   如果这套操作规则（或系统）可以计算每一个图灵机能够计算的可计算函数，那么他就是图灵完备的。

5. Turing Equivalence
   如果这套操作规则（或系统）是图灵完备的，且它能计算的每一个函数都可以被图灵机计算，那么它和图灵机是等价的。
   
6. University
   所谓university是针对一类系统来说，如果这类系统里的每一个可计算函数都可以被某个系统计算，那么该系统就说是在该类系统中具有university.
   
7. Church-Turing Thesis
   在可计算性上：
     a. 图灵机(by Alan Turing)，
     b. 递归函数(by Alonzo Church, Stephen Kleene, J.B. Rosser)，
     c. Lambda算子(by Alonzo Church)是等价的。
   这三种方法定义的函数是等价类。
   Church-Turing Thesis中指明如果有一个算法被计算，那么使用任何这三种方法都是等价的， 这个性质是作为计算理论的本质存在的，也是一个假定。

Dec 28, 2011 自动机理论
1. Automata自动机
   在离散的时间序列上接受给定的序列输入inputs，每个时间步骤上读取一个输入input（符号symbols或者是字符alphabets集合中的一个）。
   而在任何给定的时间点，所有的输入构成了一串有限的符号或者字符串这个叫做word单词。
   该状态机含有有限个状态state，每个时间步骤上它只处于一个状态。在一个时间点上，状态机读入输入后根据转移函数transition function转移状态
  （转移函数的输入是当前状态和当前输入）
   当输入串处理完后，状态机停止下来，它所处的最后的状态叫final state，有accept和reject两类。
   如果所有的word都被accept，那么也说language被accept了。

2. 根据输入、状态、转移函数和接受条件的不同可以分为不同的状态机
   输入：Finit Input, Infinit Input, Tree word Input（一次读入树的所有输入）, Infinite Tree Input
   状态：Finit States, Infinite States（不可数或者数不尽）, Stack MEmory(pushdown automaton符号可以存入栈中)
   转移：Deterministic, Non-deterministic, 
                       Alternation（一种特别的non-deterministic，有existential（选择）和universal(并行)两种不同的非确定转移）
       (这三种可以通过密集构造powerset construction相互转换)

   接受：Acceptance of finite word, Acceptance of infinite word, Probabilistic acceptance
   这些分类还可以相互结合形成更复杂的分类。

  另外，1. 如果给pushdown automaton在增加一个堆栈（即两个），那么这个新的状态机将与图灵机等价。
       2. Linear bounded automaton也是一类特殊的non-deterministic图灵机
          它的意思是不能访问无限长的磁带的所有部分，而只能访问由线性函数决定的有限长度范围，
	  每个读入的输入有上下两个marker，所有的指令的操作都在这个范围内进行。

Dec 28, 2011 形式语言理论
1. Formal grammar正规文法
   由有限终结符terminal symbols, 有限非终结符non-terminal symbols, 有限的产生式集合set of production rules和开始符号构成。
   正规文法定义了正规语言，即从开始符号开始，通过使用产生式产生的有限长度的终结符号序列。
2. Chormsky Hierarchy
   Type-0 grammar(Unrestricted Grammar)（文法中包含a->b的形式, a,b为字串)
   产生能够被图灵机识别的语言，这些语言是recursively enumarable language

   Type-1 grammar(Context-Sensitive Grammar)（文法中包含aAb->arb的形式, a,r（不能为空）,b为字串, A为非终结符）
   产生能够被Linear bounded automaton识别的语言，这些语言是上下文相关语言

   Type-2 grammar(Context-Free Grammar)（文法中包含A->r的形式, A为非终结符, r为字串)
   产生能够被Non-deterministic pushdown automaton识别，这些语言是上下文无关语言

   Type-3 grammar(Regular Grammar)(文法中包含A->aB and A->a, a为终结符, A,B为非终结符）
   产生能够被Finite state automaton识别的语言，这些语言是正规语言regular language
3. Recursive Language
   I. Recursive Set
   在计算理论里，如果有一个算法能够在有限的时间内正确的确定一个给定的自然数是否属于某个自然数集合，
   那么称这个自然数集合是recursive, computable或者decidable。
   换句话说，如果存在一个total computable函数，通过该函数可以确定任意给定的自然数是否是在该自然数集合中，那么该集合就是recursive的。

   II. Recursively Enumerable Set
   在计算理论里，如果存在一个computable函数f，针对该自然数集合中的每一个自然数n, f(n)都是有定义的，且它只定义了这些自然数，
   那么称它是一个recursively enumerable, computably enumerable, 或者semidecidable的集合。
   即只有它是某个可计算函数的domain的时候，它在可能是computably enumerable。

   III. 对于Computable Language或者说Recursive Language
   就是只要有一个total function能够确定字符集alphabet中的所有symbol要么属于要么不属于该语言，那么该语言就是可计算的。
   这个感觉比Type-0还要大的语言，对应Decider(Always Halting Turing machine)
   
   对于Computably enumerable或者说Recursively enumerable Language
   就是说只要是在该语言里定义的symbol，都存在一个可计算函数可以对它进行计算。
   这个就是Type-0文法产生的语言

Dec 29, 2011 HTTP返回码含义
1XX 信息
2XX 成功
3XX 重定位
4XX 客户端错误
5XX 服务端错误

Dec 30, 2011 编译器优化
1. 尾调用优化Tail call optimization
针对存在尾调用Tail call的代码，通过取消为被调用者创建新栈帧（保存参数目的）直接使用调用者的栈空间的动作，
通过简单的跳转去执行被调用者的代码。

使用尾调用优化可以减少对栈空间的需求，对于递归或者深层次的函数调用节省栈的消耗。

2. 尾调用Tail call
所谓尾调用，被调用者是调用者返回前的最后一个操作，即被调用者返回后调用者就立即返回之间不再做其他操作。
尾调用的好处是被调用者的返回值可以直接作为调用者的返回值返回，所以进入被调用者后，调用者的栈空间就没有必要保存了，被调用者可以利用这一空间
（因为调用者后续没有操作，而所有的信息都已经传递给被调用者），这就为尾递归优化提供了基础。

3. Tail local call
对于CL中，即意思是通过labels, flet定义的函数存在尾调用。是一种效率很高的调用方式。

Dec 30, 2011 CL编译、调试
(disassemble fn)
通过该函数可以输出一个函数、或者lambda生成的本地代码 (SBCL中为汇编)
(compile-file #p"path-to-src" :trace-output t)
在编译的时候会生成编译过程的log (SBCL中输出IR1和IR2的信息）

Jan 3, 2012 CL语言，生命周期
Scope vs. Extent
在CL中有Extent和Scope两个跟生命期（Reference引用的有效性）相关的概念
Scope涉及的是空间的、代码文字范围上的范围概念
Extent涉及的是时间范围的概念
- Lexical Scope
  对已经建立的实体的引用(reference to established entity)限制在与创建这个实体的构造相同的代码部分(program portions that are lexically contained within the establishing construct)。通常这个包含构造实体的代码部分构成叫做body, 而对该实体的引用就只能在这个body中。
  例子：
  函数的参数名
  
- Indefinite Scope
  对实体的引用可以在任何代码部分进行，没有限制。

- Dynamic Extent
  对实体的访问限定在创建实体到销毁实体的时间范围内，通常dynamic extent都遵循类似于stack的规则。
  例子：
  1. 如with-open-file会建立一个访问文件的连接，并创建流来代表这个连接，虽然流对象是indefinite extent,但这个连接是dynamic extent的。
  2. 在如用special声明的变量。

- Indefinite Extent
  实体一直存在到引用不存在为止的时间点。
  例子：
  1. 大多数的对象
  2. 函数内lexical scoped的函数参数（这些变量使得构造闭包称为可能）

除了以上这些概念，还有一个dynamic scope的概念，它indefinite scope + dynamic extent，虽然用此不当，但是已经称为传统和习惯。

Jan 3, 2012 CL语言，控制转移
1. normal return
   在执行完form后的控制和值的自然转移(natrual transfer of control and values after the completen execuation of a form)
2. non-local exit - NLX
   由除了normal return以外的原因引起的到退出点(exit point)的控制和值的转移。（通常由go, throw, return-from引起的转移）
3. exit point
   在控制form中的一个点，可以通过主动的方式（通过转移form如go, throw）或者被动方式（即通常的evaluation的顺序）将控制和值转移到该点。
   1. catch建立了个throw可以转移的退出点，该退出点名字是indefinite scope, dynamic extent即dynamic variable
   2. block建立了个return-from可以转移的退出点,该退出点名字是lexical scope, dynamic extent
   3. tagbody建立了个退出点可以用go跳转，退出点和block的退出点作用域相同
   4. unwind-protect建立了个throw可以跳转的退出点

Jan 5, 2012 CL语言，参数
函数，宏的定义都涉及到参数，参数在CL中叫做lambda list。
分为三种不同的lambda list
- Ordinary Lambda List
  即被普通的函数ordinary function使用的参数表，
  一般defun, flet, labels, lambda, handler-case, restart-case等都使用的是ordinary lambda list
  该参数表只包含如下的关键字
  &key, &rest, &optional, &allow-other-keys, &aux

- Extended Lambda List
  就是扩展了Ordinary Lambda List的语法，增加了关键字的列表，通常defmacro使用的就是这种
  包含诸如&body, &whole这样的关键字

- Modified Lambda List
  就是从Ordinary Lambda List修改或者继承而来的参数表，通常deftype使用的就是这种

P.S.
在SBCL中，编译前端会将lambda list参数表转换为IR1中的lambda-vars和arg-info结构(在make-lambda-vars函数中)，
每一个参数都会有自己的lambda-vars，如果是&optional, &keyword诸如这类特殊的参数，还会有对应的arg-info记录它们的额外信息（如默认值、是否提供判断，关键字等）

Jan 6, 2012 SBCL编译器，后端
在SBCL编译器的后端中，Template, VOP, VOP-INFO, primitive指的都是同样的事情，就是VOP
这些VOP定义在sb-c::*backend-template-names*哈希表中。并且可以通过%primitive访问。

Jan 19, 2012 SBCL的回归测试
文件结构
在SBCL中，对系统的回归测试都放在/sbcl/tests/文件夹下，测试文件的结构一般是<pure or impure>.<function parts>.lisp
首先测试分为pure和impure两大类，pure的测试是不产生副作用（即没有全局变量、函数、宏等的定义的）。
相反impure一般都有全局的函数、变量、类、错误等定义。
其次，根据功能，将测试分开成不同的小类，比如compiler, arith, alien, loop等不同的测试分在不同的文件中。

定义测试
定义测试需要使用with-test，它可以通过:name指定测试的名字
在定义的测试中，可以使用assert等方式来判断，如果没有一个assert失败，那么with-test就会成功。
而在assert里面，可以是任意的lisp代码。

最后，在tests目录下，还有个assertoid.lisp文件，其中定义了帮助编写rt的常用的宏。
如raise-error?用来测试代码是否产生某个错误，is测试某个op对两个输入的结果是否一致（我觉得一般op应该都是eq之类的东西）
grab-condition类似于raise-error?返回捕获的错误，assertoid功能比较多，支持一个form在不同优化条件下，等于特定的期望值或者产生期望的错误。

Jan 30, 2012 CL实现的名字，版本，机器的名字，版本，类型的获取
(lisp-implementation-type)
(lisp-implementation-version)
(machine-instance)
(machine-type)
(machine-version)

Jan 30, 2012 CL reader
- Read Table
    CL的语法是由reader的readtable决定的，readtable可分为，当前的*readtable*，标准的（默认的），和初始的三种。
    同一个时间可以有很多个readtable, 但reader只使用其中一种。因此，CL的语法可以通过readtable切换。
    以下是相关的一些函数：
    copy-readtable
    readtable-case
    readtablep
    set-dispatch-macro-character
    get-dispatch-macro-character
    make-dispatch-macro-character
    set-syntax-from-char
    set-macro-character
    get-macro-character

    readtable中每一个字符都有对应的语法类型(syntax type)，不同的类型影响reader对字符的处理。
    + constituent类型表示字符是token（如符号，数字）的一部分；
    + whitespace类型是token的分割符号；
    + macro类型，当reader遇到的时候就会将其分派(dispatch)到相应的reader macro function来处理输入。
      + non-terminating 在token中间出现时，它被当作constituent，否则是macro（如:#）。
      + terminating 会中断正在分析的token
    + escape类型，防止后续的字符被大小写转化，一般有single escape（如:\) 和multiple escape （如: |)

    对于macro类型，CL默认的标准定义有如下：
    ()'"`,#;
    
- 影响语法的dynamic variable
  除了Read Table还有一些全局变量影响reader，如：
  *read-base*
  *read-suppress*
  *package*
  *read-default-float-format*
  *read-eval*控制#这个macro char的启用与否
  
- 控制reader对大小写的处理
  除了通过escape字符来控制大小写，还可以通过控制当前readtable的readtable case，可以达到如下的效果：
  :upcase， 当使用此关键字值时，所有未被escape的符号都变成的大写
  :downcase, 类似与上面，都被转成小写
  :preserve， 所有的大小写都变化
  :invert,  所有的未被escape的符号，如果在一个token中都是同样的case, 那么就会被转换成相反的case。换言之，
            全是小写的token会被转换成大写，全是大写的会被转换成小写，有大小写混杂的则保持不变。

Jan 31, 2012 Linux Shell-Script Invoking
有三种方式可以执行一个脚本，他们的效果差别很大，
1. 使用sh命令，或者./ (默认)
   执行的脚本将会作为调用脚本进程的子进程执行，这将会影响环境变量 (父进程必须通过export传递给子进程，而子进程无法传递给父进程)
2. 使用source，或者. ./
   执行的脚本在原进程中执行，因此继承并且可以修改原进程中的所有环境变量
3. 使用exec
   执行的脚本将会替换原来执行的内容，在该命令后的原脚本的内容都将不再执行

Apr 14, 2012 ELP (Emacs Lisp Profiler)可用来对Emacs进行Profiling
有三种方式:
  - elp-instrument-package
  - elp-instrument-function
  - elp-instrument-list

通过 elp-results 可以查看对特定函数的profiling结果。
这样可以发现一些性能上的瓶颈。

Apr 17, 2012 dpkg错误处理
有时候倒霉会碰到dpkg包管理错误（比如安装时突然断电）
一旦发生这样的错误，往往后续的安装将会失败或者报错，通常情况下apt-get之类的无法修复。

以下是一些修复的方案：
1. 先尝试最基本的dpkg修复
   - 使用dpkg --audit查看错误
   - 使用dpkg --remove/--configure/--install/--purge等对出错包进行处理
2. 如果以上还不能成功
   - 使用dpkg --force all --remove
2.5 如果还不行   
   - 使用aptitude update, aptitude install -f进行修复
3. 如果还不成功
   - 保存/var/lib/dpkg/status
   - 打开/var/lib/dpkg/status，找出出错的包所在的 Package: XXXX的行
   - 删除从Package: XXXX的整个该包的信息
   - 保持下一个包和上一个包仅隔一行
   - 然后使用aptitude install -f重新安装
4. 如果还不成功， 恭喜你！   

Apr 19, 2012 软件介绍
unetbootin可以使得grub2加载硬盘上的iso文件，因此免去了刻盘的麻烦。
比起徒手去load各种iso镜像。方便很多。

virt-manager是一款很好的管理kvm虚拟机的软件。
但是ubuntu karmic上0.7.0的版本是破损的。

win32下可以使用Git for Windows + Toitose Git来使用git
另外，作为git server端的用户配置，可以之用gitosis
gitosis是一个在git仓库中被版本管理的管理git仓库访问权限的配置项目。

doxygen可以生成代码文档，配合emacs的doxymacs可以很轻松生成针对
代码的文档注视。需要注意doxygen -g默认生成的Doxyfile中，是不生成XML TAG
的，而doxymacs若需要扫描，就需要这个TAG。所以除非仅仅把doxymacs
当添加标准注释工具，就有必要配置配置Doxyfile.另外，使用doxygen-gui的
doxywizard可以方便的进行配置。

Apr 19, 2012 Gentoo 镜像站点
- 源镜像
  Gentoo的full source mirror大小大概240G以上，
  包括
	distfiles（源码目录140G）,
	snapshots(portage快照600M）,
	releases（正式stage, livedvd发布40～50G),
	experamental(实验性的发布， 20～30G)

  镜像站点的制作可以只包括前两者（叫做partial mirror)或者所有(叫做full mirror)
  同步镜像使用rsync工具，要求每个站点4小时同步一次。

- rsync镜像
  除了源镜像还有一种镜像是保持多个机器间的portage同步的
  通常是使用一台机器作为rsyncd服务，提供给其他机器进行同步
