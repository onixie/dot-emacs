Aug 20, 2010 Swap Caps Lock and left Ctrl under X11
1. edit .xmodmap under your home dir; add:
remove Lock = Caps_Lock
remove Control = Control_L
keysym Control_L = Caps_Lock
keysym Caps_Lock = Control_L
add Lock = Caps_Lock
add Control = Control_L

2. edit /etc/rc.local; add:
xmodmap ~/.xmodmap 2 > /dev/null

Aug 21, 2010 Rule For Software Tool
1. Only Do One Thing At A Time
2. Process Text Not Binary
3. Use Regular Expression(Posix Support Two Form: Bre And Ere)
4. Use Standard Output/Input As Default
5. Don'T Bothering(No Need Interaction)
6. Make Output Format Consistent With Required Input Format
7. Let Tool To Do The Most Difficult Thing
8. Before Create Specialized Tool, Think More

Aug 25, 2010 Emacs Basics
Emacs Regex Function
      (string-match REGEXP STRING &optional START)
      (match-string NUM &optional STRING)
      (match-end SUBEXP)
      (match-beginning SUBEXP)
Emacs Hook Function
      (add-hook HOOK FUNCTION &optional APPEND LOCAL)
      (run-hooks &rest HOOKS)
      (run-hook-with-args HOOK &rest ARGS)
Emacs Compile Function
      (compile COMMAND &optional COMINT)

Aug 30, 2010 Shell Programming - trap, pid, and print format
1. trap
   fmt: trap "cmd" signal.
   meaning: trap a signal and run the cmd
2. process variable
   $$ variable is process id
3. printf
   %-39s means left-aligning, 39 fixed char length

Aug 31, 2010 Shell Programming - embeded document
1. embedded document
   fmt: use << and EOFILE
   meaning: in a shell script to insert document with variable substitution
2. word dict
   /usr/share/dict/
   /usr/dict/
   /usr/share/lib/dict/
   /usr/local/share/dict

Mar 10, 2011 CUPS debugging technique
1. Attach filter process
   sleep filter until you can attach from gdb
2. Send print result to a file
   1). listen on a local port, "nc -l -p 20000 > filename"
   2). set printer's device uri to this local port, "socket://localhost:20000"
   3). print
3. Use FileDevice URI
   enable FileDevice in /etc/cups/cups.config

Mar 15, 2011 Network Port Range
IANA divides port numbers into three ranges:
0~1023       for common, well-known services, 3FF, On Unix-like operating system, require superuser
1024~49151   for IANA registered services, BFFF
49152~65535  for services not officially designated, such as ephemeral ports, FFFF

Mar 16, 2011 Pipeline subshell: Bash vs Ksh
When doing pipelines, ksh will run each pipeline in current process,
in contrary, bash will run each pipeline in a subshell environment.

This difference direct consequnce is when setting some variable in a pipeline in bash,
it may not reflect the value in the parent scripts.

e.g.
------------------------------------------------
echo "bla bla bla.." | while read one two three
do
    result=$one $two $three
done

echo $result
------------------------------------------------

in ksh, you got bla bla bla..
in bash, you got nothing

Mar 21, 2011 Robotics simulation toolkits
Open Sourced:
ODE, Open Dynamics Engine, written in C++, an open source physics engine, LGPLed or BSD, industrial-quality
Simbad robot simulator, written in Java, featured with an visulization console, GPLed
Teambots, portable multi-agent robotic simulator
Carmen, Carnegie Mellon Robot Navigation Toolkit

Commercial:
Khepera

Jun 8, 2011  Git 断点续传
通过git init && git fetch <url>可以实现git下载的断点续传(反馈：尝试了，貌似不能！)
git clone不具备这个功能

Jul 25, 2011 SBCL build process
cross compiling phase:
make-host-1  ---->  make-target-1

target system compiling phase:
make-host-2 ----> make-genesis-2  ----> make-target-2

Jul 26, 2011 Git (v1.6.6 above) SMART HTTP PROXY
1. use http_proxy environment variables and http as the clone protocol
2. use GIT_CURL_VERBOSE to output verbose information

Jul 27, 2011 SSH 通过公私钥代替密码登录认证
1. 在.ssh/config文件中，通过IdentityFile使得ssh客户端能够自动选择与登录服务端相匹配的密钥
如：
IdentityFile ~/.ssh/ids/%h/id_rsa
IdentityFile ~/.ssh/id_rsa
2. 创建目录，将私钥按照主机或者用户进行分类存放
3. 在服务器端，.ssh/authorized_keys文件中，每一行记录一个允许通过公私钥登录的客户端对应的公钥

Jul 27, 2011 SSH 常见用法
1. 创建隧道
ssh -N -L2011:localhost:80 somemachine 创建从本地2011到远端80端口的隧道, localhost部分其实指的是服务端
ssh -N -R2011:localhost:80 somemachine 创建从远端2011端口到本地80端口的隧道, localhost指的是本地客户端
可以用nc来进行测试，如：
nc -l -p 80 在某一端监听
nc localhost 2011 发送消息到隧道里

2. 比较远程和本地文件
ssh user@remote cat /path/to/somefile1 | diff /path/to/somefile2 -

3. 将远程的内容复制到粘帖版
ssh user@remote cat /path/to/somefile | xclip

Jul 27, 2011 DBUS的概念
DBUS称为消息总线，分为系统总线和会话总线。
用于实现进程间的1对1通信，连接到总线上的进程通过提供服务和获取服务来交换信息。
服务连接有一个BUS全局名称，而每个连接都有个唯一私有名称，
通过全局名称琐定服务后，指定服务的对象，接口，以及方法来进行信息获取。
dbus-send和dbus-monitor是两个实用的调试工具

Jul 29, 2011 CRON计划任务之at
通过at命令可以进行简单的计划任务
1. at now+1minutes -f <command>
2. at -t "MMDDmmss" -f <command>
如果没有f指定作业文件，则从标准输入中读取

Jul 29, 2011 DBUS的Session地址
在dbus-send的参数里除了--system和--session还有一个--address
这个参数没有很好的文档说明，它实际上就是dbus进行消息传递的文件的地址(socket方式)
另外，还有一个环境变量叫做DBUS_SESSION_BUS_ADDRESS是表示当前session的dbus的地址

最后通过dbus-daemon --print-address也可以显示当前开启的dbus对应的地址

有关session bus address的信息其实存放在~/.dbus/session-bus/$(dbus-uuidgen --get)-[$HOST]-$(DISPLAY)
这个文件里面。

发现一个奇怪的现象，
通过ssh remote dbus-send --sesion ..bla.bla.bla的方式
在ubuntu9.10上返回一个错误，提示说session dbus是null的，
这是由于在ssh运行dbus-send的时候，环境变量可能还没有准备好，
因此，可以通过读取上面的文件来获取dbus

Jul 29, 2011 GIT获取revision和commit信息的相关的命令
git log 获取commit的log信息，通过-p -2可以对最近两个版本进行比较， --since与--until可以对日期进行过滤
git rev-list 获取从某个commit回溯可以到达的revisions的历史列表， 通过--not可以指定过滤显示到达不了的那些历史列表
git rev-parse 显示一个commit的全局唯一哈希码, --short可以仅显示部分这个码
git describe 显示一个revision的tag名，可以是轻量级的，使用--tags, --all, --dirty可以显示各种不同级别的tag, 一般情况下显示离当前签入的commit最近的过去时间中的revision， 如果使用--contain则显示最近的未来时间的revision, --abbrev=0使用短格式显示revision tag

Aug 3, 2011 Send message to users on unix
command:
wall       send all user a message
mesg       disable/enable message receiving
write user [tty]  send a message to a user

Aug 4, 2011 Echo KnowHow
Echo has two options very useful
-n  stop output trailing newline
-e  enable escape character

e.g. echo -ne '\032\032'

Aug 19, 2011 X开发中 Display的指定
OpenDisplay的时候，
host为空的情况，会打开本地默认的0号display，
不管是否指定display，也不管本地默认Xserver是否监听网络，还是限制访问
host为localhost或者本机ip的时候，需要指定display,
并可以在指定display上显示，但前提是该display上的Xserver监听网络，并且无网络限制。


Aug 27, 2011 Emacs Tramp for SSH
C-x C-f and then type /ssh:<user>@<host>:<files>
it can open remote files by ssh.

Nov 16, 2011 LINUX GIT
最近的一些经验：
1. dd_rescue 可以用来从坏扇区恢复一些数据

2. 在1.7以后git可以通过ssl代替ssh推送数据，具体的是在url中指定用户名，git会询问passwd
   如 ：git clone https://myname@github.com/XXX/XXX.git
   这样就等同于使用ssh，可以进行推送了。

3. 使用https协议穿过代理的时候，可以设定http.proxy, http.sslCAInfo, http.sslCAPath等变量
   后两个是指定认证根文件，和目录的所在位置

4. 可以使用--track在本地创建一个跟踪本地upstream的分支，以使用pull，这默认只对远程分支有用
   使用git branch -vv，两个v可以看到upstream

5. 当使用--amend重新commit的时候，切记仅在本地操作，如果已经推送到远程源，那么只能在push的时候--force
   但是这样实际改变了之前的commit

Nov 22, 2011 SBCL
SBCL中关于IR2之后的一些文件
system.lisp定义了一些vop操作, 用于访问vm层的对象和信息
objdef.lisp中定义了在vm层中支持的原生C结构的对象
meta-vmdef.lisp定义了vm.lisp中用于定义SB,SC的操作
vm.lisp定义了SB,SC具体有哪些内容
vop.lisp定义了IR2转换时候的结构对象，SB, SC, TN, Template, VOP-Info等对象结构
assem.lisp和insts.lisp定义了80x86指令结构，具体的操作指令inst，以及对应的op code等信息

一些碰到的名词
Storage Base, Storage Class, Temporary Name, Template, TN-Ref, Effective Address
Virtual Operation, Primitive types, Instruction
emitter, printer, prefilter, generator

Nov 24, 2011 SBCL
在SBCL中定义新的VOP的方法
在SB-VM包中，
首先调用defknown声明该VOP是一个已知的操作
通过define-vop定义新的操作，然后通过defun定义上层函数

如：
声明我的VOP接受一个系统区域指针，返回一个系统区域指针
(defknown myvop (system-area-pointer) system-area-pointer (flushable movable))
定义我的操作，意思是接受线程的系统区域指针，并且返回它 (相当没意义的操作)
(define-vop (myvop)
	 (:args (thread :scs (sap-reg) :target int))
	 (:arg-types system-area-pointer)
	 (:results (int :scs (sap-reg)))
	 (:result-types system-area-pointer)
	 (:translate myvop)
	 (:policy :fast-safe)
	 (:generator 1
		     (move int thread)))
声明高层函数
(defun myvop (thread)
	     (myvop thread))

不明白的是什么是flushable, movable, foldable属性？

Nov 24, 2011 SBCL
SAP相关操作
可以通过SAP-REF-*之类的，来读取某个SAP指针偏移处的内存的内容
另外，对于在C空间中的变量，可以通过alien-sap和extern-alien
来获取它的地址， extern-alien对于类型的要求可以在sb-alien包
中找到，或者使用(* t)，另外还支持对函数的获取，指定函数类型

如对于函数：
(extern-alien "getcwd" (function (* char) (* char) size-t))
如对于变量：
(alien-sap (extern-alien "all_threads"  (* t)))

Nov 28, 2011 SBCL
SBCL编译器叫做Python compiler(和python语言可没关系哦)
编译分为两个阶段phase，分别处理两种不同的中间语言IR:
IR1 (Implicit Continuation Representation)
IR2 (Virtual Machine Representation)

编译器前端frontend主要负责IR1变换，后端backend则负责IR2变换
ICR相当于一个CL的子集，以流程图flow graph的形式描述被编译代码的语法\语义
VMR则是一些虚拟机操作码 (不同体系的汇编)的模板，将代码翻译成虚拟机的语言

================================================================
具体的语言变换过程：

     IR1                    IR2
  /------\    /--------------------------------\
 / 	  \  /   			        \
CL -> ICR -> VMR -> assembly instruction -> OP code

IR1 phase
1. ICR conversion - 进行宏展开和代码到代码的变换，将被编译代码转换为ICR形式 （解决命名冲突问题） - ir1tran, srctran, typetran
2. Local call analysis - 寻找对本地函数的调用，分析关键字参数，将仅调用一次的函数识别为let，创建XEP - locall
3. Find components - 寻找flow graph中的组块component，区分top level和run time代码，确定top level的components - dfo
4. ICR optimization - ir1opt, ir1tran, typetran, seqtran, vm/vm-tran
5. Type constraint propagation - 使用global flow analysis传播lexical 变量的类型信息，取消不必要的类型检查 - constraint
6. Type check generation - 对在后端中比较难检查的类型，产生检查这些类型的ICR代码 - checkgen
7. Event driven operation - 重新计算一些ICR部分 - ir1util, ir1opt
8. ICR finalize - 在所有components都被编译后，寻找全局变量引用中的未定义的变量和不兼容的函数定义 - ir1final, main
9. Environment analysis - 分析需要创建的不同环境以及其上下文， 探测非本地退出以及设置闭包变量 - envanal

IR2 phase
10. Global TN allocation - 遍历所有定义的函数，确定调用规约，给本地变量分配TN - gtn
11. Local TN allocation - 根据类型和policy决定对已知函数使用什么VMR翻译，创建表达式评估时需要的TN - ltn
12. Control analysis - 线性化flow graph，尽量减少其分支。block级的flow graph在这确定下来。 -  control
13. Stack analysis - 针对unknown-values continuation维护堆栈？ - stack
14. Entry analysis - 搜集外部函数调用的信息
15. VMR conversion - 通过将flow graph中的节点转换为VOP将ICR转换为VMR - ir2tran, vmdef
16. Copy propagation - 通过flow analysis删除不需要的TN
17. Representation selection - 根据对TN的引用，确定哪个表示的cost最低。选择相应的VOP
18. Lifetime analysis - 通过flow analysis找到生命期重叠的TN的集合，标注那些需要存储TN的VOP调用 - life
19. Pack - 寻找合适的寄存器分配 - pack
20. Code generation - 调用VOP产生器生成代码 - codegen
21. Pipeline reorganization - assem-opt
22. Assembly - 解决分支，转化为object code以及fixup信息 - assembler
23. Dump - 将编译后的内容输出到object file或者in-core函数 - debug-dump, dump, vm/core
=================================================================

Nov 28, 2011 Compiler, SBCL
- Peephole optimization的意思是针对一段产生的代码中的一小部分指令进行优化，这一小部分指令常称为peephole。
  通常优化是指，识别无效的指令以及选择轻量级的等价指令。

- Partial evaluation是一种在编译期将常量表达式替换掉constant folding的优化方法，该方法不仅优化完整的常量表达式，还根据
  任何代码（表达式）中常量部分对这部分代码整体进行优化，主要表现为常量（值，函数都可）替换，无用表达式的删除，常量条件分支删除等

- Inline expansion是指函数在调用处展开为代码的优化。

- Meta-programming是指通过开发一种语言的特定领域扩展 Domain-specific extension来编程的方法。 (我猜lisp里就是特别指macro编程了吧，反馈：macro是其中一种机制)

- Block compilation就是在假定全局函数global function不会重定义的情况下，优化掉函数边界。把defuned的函数编译成如flet, labels定义的
  函数块。该优化可以将函数调用转化为本地jump跳转，取消参数检查。另外，也将partial evaluation和type inference的边界扩展到block而不是函数。

Nov 29, 2011 Compiler, Type system
- Type checking是检验类型规则限制的过程，可以发生在编译期，或者运行时。
  - Static typing静态类型，是指在编译器进行类型检查的类型，与之相关的类型检查错误是compile time type error。
  - Dynamic typing动态类型，是指在绝大多数类型检查在运行期间完成，与之相关的类型检查错误是runtime type error。
    动态类型中，一般变量是没有类型的，有类型的是值。
    - Duck typing是OO编程中，源于duck test的概念，即不管是什么对象，只要它走起来，叫起来，游起来像个鸭子，就叫它鸭子。
      是一种动态类型检查，即由当前对象的行为和属性来决定值语义，而不是继承。
  - Strong typing与weak typing是类型系统的另外一个纬度关注的问题。

- Type inference是一种编译期自动对表达式的类型进行部分或者完全推导的功能。编译器通过推导使得显示的类型声明type annotation可以省略掉。一般类型推导用于静态类型语言。

- Polymorpism是OO编程中，指同一个操作可以应用于多个类型的对象，或者同一个数据结构可以包含多个类型的元素。

Nov 29, 2011 SBCL调试
可以通过enable-debugger, disable-debugger, invoke-debugger显示的启用调试 (默认)，禁止调试，以及调用调试
另外通过(define-alien-routine ("ldb_monitor" ldb_monitor) void)定义一个调用low level debugger的函数
可以引起low level debugger.

Nov 29, 2011 Programming, Compiler, First Class
First Class Object

在程序语言中，如果一个对象支持以下内容，它就是一级的：
1. 能够存储到变量或数据结构中
2. 能够作为参数传递给子过程
3. 能够作为子过程的返回值
4. 能够在运行时创建
5. 具备intrinsic identity（唯一的标示？）

具体到特定的程序元素，有
first class function
first class value
first class continuation
first class data type

Dec 27, 2011 从用户的角度控制SBCL编译器
1. 控制编译时输出的信息Verbosity：
基础知识：
在SBCL中有四种编译时的检查输出compiler diagnostic severity: error, warning, style warning, note

前三种都对应的是ANSI CL标准中的condition, 意思是报告编译时发生了错误级别error severity的严重问题。
第四个note通常是编译器提示的一些提示信息hint, 如如何改善代码以达到期望的性能、编译器优化掉的无用代码信息等。

note从condition继承，基类为sb-ext::compiler-note，其中有个子类是code-deletion-note。

对于输出，一般分为6个部分
1. file: 标示错误所在的文件
2. in: 标示错误发生的top level的definition或者form
3. 之后缩进两格的是错误发生的最直接的form的原始代码（未经过宏展开和代码变换的）
   注：这个信息里form是包含错误的最小的form，所以错误只会发生在这个form上，而不会发生在其包含的form中。
4. --> 处理路径processing path， 显示在编译过程中，进行宏展开的每步的动作，该行中的每一个单词是展开一次的最外层的头一个form
5. ==> 展开后的实际出错的代码
6. 错误的类型和错误信息

方法：
a. 通过在declare或者declaim中使用muffle-condition/unmuffle-condition来声明屏蔽输出哪些编译的diagnostics检查
b. 通过修改*compiler-print-variable-alist*来绑定一些*print-xxx*变量来控制编译时的输出
----------------------------------------------------------------------
2. 控制类型检查
默认的情况下，SBCL并不盲目相信声明的类型declared types，而是把他们当成需要在运行期检查的assertions（但因为一些原因，这个规则是有出入的）, 对这些类型声明，将使用如同typep一样的严格精准的检查策略，如果一个对象有多个类型声明，那么每个都必须符合。

类型检查有三类，
全类型检查Full Type Checks, 条件：当优化级别safety>=2 或 safety>=speed>=1时（默认的方式）
弱类型检查Weak Type Checks（简化为检查更宽泛的类型限制）, 条件：当优化级别safety<2并且safety<speed时
无检查No Type Checks, 条件：safety=0
----------------------------------------------------------------------
3. 控制编译器策略
知识：
使用optimize优化声明，可以控制ANSI CL标准定义的四种不同的优化策略：safety, speed, space, debug
通常speed优化策略过高时，编译器会提示用户一些它无法进行的优化提示，以告知修改代码来实现期望的优化。
通常space优化策略影响内联函数的展开，将会增大编译后的代码大小。小心使用space=0，因为编译器会不分情况的进行内联，可能减慢程序执行速度。

方法：
1. 通过declare\declaim声明优化策略
2. 通过declare-compiler-policy输出当前上下文的优化策略
3. 通过restrict-compiler-policy限定指定的策略类型的最小级别。 如果没有指定，将会取消先前的指定（即设定为0），否则设定为1~3中的一个。
4. 通过with-compilation-unit将编译策略声明的影响限定到它的上下文中。
   使用:override有两个作用，其一，延迟其内部的警告的发生，并且当它为false时，未定义的警告会传播到外层的with-compilation-unit，
   它为true时，就会在该层被处理。
   使用:policy可以将其内部的策略绑定到当前的with-compilation-unit环境而不影响全局的策略。

   例子：
   除了safety其他都使用全局的策略，而在该单元内使用safety为2的策略，该策略不影响全局的safety
   (with-compilation-unit (:policy '(optimize））
	   (declaim (optimize (safety 2)))
	   (load "/home/nixie/workspace/source/workdir/lisp/sbclstudy.lisp"))
   除了safety其他都使用全局策略，safety在该单元内为3
   (with-compilation-unit (:policy '(optimize safety))
	   (load "/home/nixie/workspace/source/workdir/lisp/sbclstudy.lisp"))
   都使用全局策略，包括safety的改变，会影像全局策略
   (with-compilation-unit (:policy nil)
	   (declaim (optimize (safety 2)))
	   (load "/home/nixie/workspace/source/workdir/lisp/sbclstudy.lisp"))
   都不使用全局策略而使用默认策略，safety在该单元内为3
   (with-compilation-unit (:policy '(optimize safety) :override t)
	   (load "/home/nixie/workspace/source/workdir/lisp/sbclstudy.lisp"))

   注：restrict-compiler-policy并不受with-compilation-unit的影响，因此即便它在其内部，也会对全局起作用

Dec 27, 2011 Open coded vs. Closed coded
- 所谓Open coded就是指在函数调用的地方，用等价的内联代码inline code（注意这里只是指代码，而不是其他等价的函数调用）替换掉该函数的调用。
  Open coding通常是牺牲空间来换取时间的一种做法，当实现比较简单的时候通常会这么做。
- 所谓Closed coded就是指在函数调用的地方，要么没有等价的替换，要么替换只是变成调用其他等价的函数。

- open coding与inline expansion的不同
  由于CL中的标准函数都是固定的（用户不应随意修改），编译器一般可以根据情况来选择这些标准函数的内部实现，
  这些内部实现是不同情况下的不同的内联代码。在不同的情况下，选择不同的内联代码进行替换，这就是open coding的实质。
  而inline expansion通常指的是用函数体来代替函数调用的一种优化。


Dec 27, 2011 杂技巧搜集
1. 使用Xephyr实现窗口化X服务
使用Xephyr -ac -br -noreset -screen 800x600 :1&可以打开一个在:1的新的X服务在在当前X服务的一个窗口里。
然后就可以让一些应用连上去看看了。
2. Shell中的路径解析/的定义
POSIX规定一个/代表root目录，多余两个的/如///也应该当成一个/。
而两个/即//是可以由shell的实现决定其含义的。
Bash把//显示为//当作/, Zsh把//显示并且当作/
3. ping的mdev代表的是mean deviation, 是RTT的平均偏差，越大代表网速越不稳定。

Dec 28, 2011 计算理论
1. Turing Machine图灵机
   根据一个表格的规则，读取磁带输入的信息，对符号进行操作的设备。 Universal Turing Machine是能够模拟其他图灵机的图灵机。

   --------------------
   Turing在1948年写了一个简介的定义：
   被分割成一块一块square cell的无限长的磁带infinit tape提供了无限的内存容量，每个symbol都可以存储在一个cell上。
   在一个特定的时刻，只有一个符号在机器中，该符号被称为被扫描的符号(scanned)。机器可以修改这个符号，并且它自己的行为
   也依赖于这个符号，而磁带上的其他符号不能影响当前的机器。最后，磁带是可以前后移动来让机器读取的，这是机器的一个最基本的
   操作。因此，所有的符号都可以被机器扫描。

   对这段还的理解是，图灵机的构成是：
   a. 无限长的磁带（分成cells，每个cells存储有限alphabet中的symbol）
   b. 一个前后可移动的磁头（读写操作）
   c. 一个状态寄存器（记录有限个状态中的一个）
   d. 有限的指令表（迁移函数表）
      根据当前状态和读入指令动作有：移动磁头，读写符号，修改状态。
      deterministic的模型，前两个动作是二选一，最后一个动作是可以结合的；non-deterministic所有动作是可以结合的。
      有些模型里，如果符号和状态的结合没有产生动作，那么机器是可以停止halt。
   --------------------

2. Computable Function可计算的函数
   通过机械的计算设备可以在不限定时间和空间条件下被计算的函数。
   或者说通俗点是有算法描述（一定的计算步骤序列）的函数就是可计算的，它可以用纸和笔在不限定时间和空间等资源的条件下被计算出来。

   --------------------
   在历史上，曾今使用Effectively calculable来代表可计算（但是它是形象的说法）

   Rosser在1939年对Effective的描述是：Effective Method是指计算的每一步都是预先确定好的，并且能够在有限步内产生答案的方法。
   这里Effective有1. 能够产生确定的，准确的，期望的效果，2. 并且能够产生一个结果的意思。

   Turing在1939年中说:computable function的意思是可以被机器计算的函数，而使用effectively calculable来代表形象的意思在不需要特别
   指明这些定义的情况下。即：
   Every effectively calculable function is a computable function.

   a function is effectively calculable if its value can be found by some purely mechanical process.
   a purely mechanical process one which could be carried out by a machine.

   而Effective calculable的意思就是能够不管什么effective的方法产生的， Effective computable是指被图灵机或等价设备产生的。
   --------------------

   P.S.
3. total vs. partial （函数概念的扩展）
   在数学中，如果一个函数它只能把X的子集X'映射到Y，我们说它是X到Y的一个partial function。
   如果该函数X'就是X，那么它就是一个total function。

   对于partial function来说，在recursion theorists那，domain就是X'；在category theorists那，domain还是X，X'被叫做domain of definition

   在可计算理论里面，如果一个可计算函数没有接受所有可能的参数，那么它是partial computable或叫做partial recursive
   否则就是total computable或者叫total recursive

4. Turing Complete图灵完备
   通常说能够模拟turing Machine图灵机的一系列操作规则（系统）的集合是图灵完备的
   （一般有上下文相关文法，递归函数，Lambda算子）。

   Turing Completeness
   如果这套操作规则（或系统）可以计算每一个图灵机能够计算的可计算函数，那么他就是图灵完备的。

5. Turing Equivalence
   如果这套操作规则（或系统）是图灵完备的，且它能计算的每一个函数都可以被图灵机计算，那么它和图灵机是等价的。

6. University
   所谓university是针对一类系统来说，如果这类系统里的每一个可计算函数都可以被某个系统计算，那么该系统就说是在该类系统中具有university.

7. Church-Turing Thesis
   在可计算性上：
     a. 图灵机(by Alan Turing)，
     b. 递归函数(by Alonzo Church, Stephen Kleene, J.B. Rosser)，
     c. Lambda算子(by Alonzo Church)是等价的。
   这三种方法定义的函数是等价类。
   Church-Turing Thesis中指明如果有一个算法被计算，那么使用任何这三种方法都是等价的， 这个性质是作为计算理论的本质存在的，也是一个假定。

Dec 28, 2011 自动机理论
1. Automata自动机
   在离散的时间序列上接受给定的序列输入inputs，每个时间步骤上读取一个输入input（符号symbols或者是字符alphabets集合中的一个）。
   而在任何给定的时间点，所有的输入构成了一串有限的符号或者字符串这个叫做word单词。
   该状态机含有有限个状态state，每个时间步骤上它只处于一个状态。在一个时间点上，状态机读入输入后根据转移函数transition function转移状态
  （转移函数的输入是当前状态和当前输入）
   当输入串处理完后，状态机停止下来，它所处的最后的状态叫final state，有accept和reject两类。
   如果所有的word都被accept，那么也说language被accept了。

2. 根据输入、状态、转移函数和接受条件的不同可以分为不同的状态机
   输入：Finit Input, Infinit Input, Tree word Input（一次读入树的所有输入）, Infinite Tree Input
   状态：Finit States, Infinite States（不可数或者数不尽）, Stack MEmory(pushdown automaton符号可以存入栈中)
   转移：Deterministic, Non-deterministic,
                       Alternation（一种特别的non-deterministic，有existential（选择）和universal(并行)两种不同的非确定转移）
       (这三种可以通过密集构造powerset construction相互转换)

   接受：Acceptance of finite word, Acceptance of infinite word, Probabilistic acceptance
   这些分类还可以相互结合形成更复杂的分类。

  另外，1. 如果给pushdown automaton在增加一个堆栈（即两个），那么这个新的状态机将与图灵机等价。
       2. Linear bounded automaton也是一类特殊的non-deterministic图灵机
          它的意思是不能访问无限长的磁带的所有部分，而只能访问由线性函数决定的有限长度范围，
	  每个读入的输入有上下两个marker，所有的指令的操作都在这个范围内进行。

Dec 28, 2011 形式语言理论
1. Formal grammar正规文法
   由有限终结符terminal symbols, 有限非终结符non-terminal symbols, 有限的产生式集合set of production rules和开始符号构成。
   正规文法定义了正规语言，即从开始符号开始，通过使用产生式产生的有限长度的终结符号序列。
2. Chormsky Hierarchy
   Type-0 grammar(Unrestricted Grammar)（文法中包含a->b的形式, a,b为字串)
   产生能够被图灵机识别的语言，这些语言是recursively enumarable language

   Type-1 grammar(Context-Sensitive Grammar)（文法中包含aAb->arb的形式, a,r（不能为空）,b为字串, A为非终结符）
   产生能够被Linear bounded automaton识别的语言，这些语言是上下文相关语言

   Type-2 grammar(Context-Free Grammar)（文法中包含A->r的形式, A为非终结符, r为字串)
   产生能够被Non-deterministic pushdown automaton识别，这些语言是上下文无关语言

   Type-3 grammar(Regular Grammar)(文法中包含A->aB and A->a, a为终结符, A,B为非终结符）
   产生能够被Finite state automaton识别的语言，这些语言是正规语言regular language
3. Recursive Language
   I. Recursive Set
   在计算理论里，如果有一个算法能够在有限的时间内正确的确定一个给定的自然数是否属于某个自然数集合，
   那么称这个自然数集合是recursive, computable或者decidable。
   换句话说，如果存在一个total computable函数，通过该函数可以确定任意给定的自然数是否是在该自然数集合中，那么该集合就是recursive的。

   II. Recursively Enumerable Set
   在计算理论里，如果存在一个computable函数f，针对该自然数集合中的每一个自然数n, f(n)都是有定义的，且它只定义了这些自然数，
   那么称它是一个recursively enumerable, computably enumerable, 或者semidecidable的集合。
   即只有它是某个可计算函数的domain的时候，它在可能是computably enumerable。

   III. 对于Computable Language或者说Recursive Language
   就是只要有一个total function能够确定字符集alphabet中的所有symbol要么属于要么不属于该语言，那么该语言就是可计算的。
   这个感觉比Type-0还要大的语言，对应Decider(Always Halting Turing machine)

   对于Computably enumerable或者说Recursively enumerable Language
   就是说只要是在该语言里定义的symbol，都存在一个可计算函数可以对它进行计算。
   这个就是Type-0文法产生的语言

Dec 29, 2011 HTTP返回码含义
1XX 信息
2XX 成功
3XX 重定位
4XX 客户端错误
5XX 服务端错误

Dec 30, 2011 编译器优化
1. 尾调用优化Tail call optimization
针对存在尾调用Tail call的代码，通过取消为被调用者创建新栈帧（保存参数目的）直接使用调用者的栈空间的动作，
通过简单的跳转去执行被调用者的代码。

使用尾调用优化可以减少对栈空间的需求，对于递归或者深层次的函数调用节省栈的消耗。

2. 尾调用Tail call
所谓尾调用，被调用者是调用者返回前的最后一个操作，即被调用者返回后调用者就立即返回之间不再做其他操作。
尾调用的好处是被调用者的返回值可以直接作为调用者的返回值返回，所以进入被调用者后，调用者的栈空间就没有必要保存了，被调用者可以利用这一空间
（因为调用者后续没有操作，而所有的信息都已经传递给被调用者），这就为尾递归优化提供了基础。

3. Tail local call
对于CL中，即意思是通过labels, flet定义的函数存在尾调用。是一种效率很高的调用方式。

（补充：从continuation的角度理解，tail call是指在tail position的调用，
而tail position指的是当前表达式的continuation和包含它的表达式的continuation相同，
如：(if A B C)中，B的作为redex（求值后结果），它的continuation等同于这个if的continuation，所以它处在if的tail position,
B处的调用就是tail call， 符号表示为：C[B] => C[(if A B C)], 这部分详细可以参考racket reference中对于tail position的解释。)

Dec 30, 2011 CL编译、调试
(disassemble fn)
通过该函数可以输出一个函数、或者lambda生成的本地代码 (SBCL中为汇编)
(compile-file #p"path-to-src" :trace-output t)
在编译的时候会生成编译过程的log (SBCL中输出IR1和IR2的信息）

Jan 3, 2012 CL语言，生命周期
Scope vs. Extent
在CL中有Extent和Scope两个跟生命期（Reference引用的有效性）相关的概念
Scope涉及的是空间的、代码文字范围上的范围概念
Extent涉及的是时间范围的概念
- Lexical Scope
  对已经建立的实体的引用(reference to established entity)限制在与创建这个实体的构造相同的代码部分(program portions that are lexically contained within the establishing construct)。通常这个包含构造实体的代码部分构成叫做body, 而对该实体的引用就只能在这个body中。
  例子：
  函数的参数名

- Indefinite Scope
  对实体的引用可以在任何代码部分进行，没有限制。

- Dynamic Extent
  对实体的访问限定在创建实体到销毁实体的时间范围内，通常dynamic extent都遵循类似于stack的规则。
  例子：
  1. 如with-open-file会建立一个访问文件的连接，并创建流来代表这个连接，虽然流对象是indefinite extent,但这个连接是dynamic extent的。
  2. 在如用special声明的变量。

- Indefinite Extent
  实体一直存在到引用不存在为止的时间点。
  例子：
  1. 大多数的对象
  2. 函数内lexical scoped的函数参数（这些变量使得构造闭包称为可能）

除了以上这些概念，还有一个dynamic scope的概念，它indefinite scope + dynamic extent，虽然用词不当，但是已经称为传统和习惯。

Jan 3, 2012 CL语言，控制转移
1. normal return
   在执行完form后的控制和值的自然转移(natrual transfer of control and values after the completen execuation of a form)
2. non-local exit - NLX
   由除了normal return以外的原因引起的到退出点(exit point)的控制和值的转移。（通常由go, throw, return-from引起的转移）
3. exit point
   在控制form中的一个点，可以通过主动的方式（通过转移form如go, throw）或者被动方式（即通常的evaluation的顺序）将控制和值转移到该点。
   1. catch建立了个throw可以转移的退出点，该退出点名字是indefinite scope, dynamic extent即dynamic variable
   2. block建立了个return-from可以转移的退出点,该退出点名字是lexical scope, dynamic extent
   3. tagbody建立了个退出点可以用go跳转，退出点和block的退出点作用域相同
   4. unwind-protect建立了个throw可以跳转的退出点

Jan 5, 2012 CL语言，参数
函数，宏的定义都涉及到参数，参数在CL中叫做lambda list。
分为三种不同的lambda list
- Ordinary Lambda List
  即被普通的函数ordinary function使用的参数表，
  一般defun, flet, labels, lambda, handler-case, restart-case等都使用的是ordinary lambda list
  该参数表只包含如下的关键字lambda keyword:
  &optional, &rest, &key, &allow-other-keys, &aux

  标准规定处理这些parameter specifier的顺序是：
  1. 首先处理required parameter
  2. 其次是optional parameter
  3. 然后是rest 和 keyword parameter（注意这里如果有一个argument，会被同时处理到这两个parameter specifier的绑定上。）
  4. 如果keyword同名的有多个，最左边的被处理。
  5. 在这些都处理完了以后，aux parameter会被处理。（但是它不是参数，它只是用于函数内部普通变量的初始化，相当于一个let*)

  还有&allow-other-keys parameter keyword和:allow-other-keys t argument pair可以使的一个接受keyword的函数，接受与keyword parameter不匹配的keyword argument pair。

- Extended Lambda List
  就是扩展了Ordinary Lambda List的语法，增加了关键字的列表，通常defmacro使用的就是这种
  包含诸如&body, &whole这样的关键字

- Modified Lambda List
  就是从Ordinary Lambda List修改或者继承而来的参数表，通常deftype使用的就是这种

最后，
- lambda-list-keywords 可以显示实现支持的lambda list关键字都有那些
- lambda-parameters-limit 可以显示实现支持的输入参数个数最大限制。

P.S.
在SBCL中，编译前端会将lambda list参数表转换为IR1中的lambda-vars和arg-info结构(在make-lambda-vars函数中)，
每一个参数都会有自己的lambda-vars，如果是&optional, &keyword诸如这类特殊的参数，还会有对应的arg-info记录它们的额外信息（如默认值、是否提供判断，关键字等）

Jan 6, 2012 SBCL编译器，后端
在SBCL编译器的后端中，Template, VOP, VOP-INFO, primitive指的都是同样的事情，就是VOP
这些VOP定义在sb-c::*backend-template-names*哈希表中。并且可以通过%primitive访问。

Jan 19, 2012 SBCL的回归测试
文件结构
在SBCL中，对系统的回归测试都放在/sbcl/tests/文件夹下，测试文件的结构一般是<pure or impure>.<function parts>.lisp
首先测试分为pure和impure两大类，pure的测试是不产生副作用（即没有全局变量、函数、宏等的定义的）。
相反impure一般都有全局的函数、变量、类、错误等定义。
其次，根据功能，将测试分开成不同的小类，比如compiler, arith, alien, loop等不同的测试分在不同的文件中。

定义测试
定义测试需要使用with-test，它可以通过:name指定测试的名字
在定义的测试中，可以使用assert等方式来判断，如果没有一个assert失败，那么with-test就会成功。
而在assert里面，可以是任意的lisp代码。

最后，在tests目录下，还有个assertoid.lisp文件，其中定义了帮助编写rt的常用的宏。
如raise-error?用来测试代码是否产生某个错误，is测试某个op对两个输入的结果是否一致（我觉得一般op应该都是eq之类的东西）
grab-condition类似于raise-error?返回捕获的错误，assertoid功能比较多，支持一个form在不同优化条件下，等于特定的期望值或者产生期望的错误。

Jan 30, 2012 CL实现的名字，版本，机器的名字，版本，类型的获取
(lisp-implementation-type)
(lisp-implementation-version)
(machine-instance)
(machine-type)
(machine-version)

Jan 30, 2012 CL reader
- Read Table
    CL的语法是由reader的readtable决定的，readtable可分为，当前的*readtable*，标准的（默认的），和初始的三种。
    同一个时间可以有很多个readtable, 但reader只使用其中一种。因此，CL的语法可以通过readtable切换。
    以下是相关的一些函数：
    copy-readtable
    readtable-case
    readtablep
    set-dispatch-macro-character
    get-dispatch-macro-character
    make-dispatch-macro-character
    set-syntax-from-char
    set-macro-character
    get-macro-character

    readtable中每一个字符都有对应的语法类型(syntax type)，不同的类型影响reader对字符的处理。
    + constituent类型表示字符是token（如符号，数字）的一部分；
    + whitespace类型是token的分割符号；
    + macro类型，当reader遇到的时候就会将其分派(dispatch)到相应的reader macro function来处理输入。
      + non-terminating 在token中间出现时，它被当作constituent，否则是macro（如:#）。
      + terminating 会中断正在分析的token
    + escape类型，防止后续的字符被大小写转化，一般有single escape（如:\) 和multiple escape （如: |)

    对于macro类型，CL默认的标准定义有如下：
    ()'"`,#;

- 影响语法的dynamic variable
  除了Read Table还有一些全局变量影响reader，如：
  *read-base*
  *read-suppress*
  *package*
  *read-default-float-format*
  *read-eval*控制#这个macro char的启用与否

- 控制reader对大小写的处理
  除了通过escape字符来控制大小写，还可以通过控制当前readtable的readtable case，可以达到如下的效果：
  :upcase， 当使用此关键字值时，所有未被escape的符号都变成的大写
  :downcase, 类似与上面，都被转成小写
  :preserve， 所有的大小写都变化
  :invert,  所有的未被escape的符号，如果在一个token中都是同样的case, 那么就会被转换成相反的case。换言之，
            全是小写的token会被转换成大写，全是大写的会被转换成小写，有大小写混杂的则保持不变。

Jan 31, 2012 Linux Shell-Script Invoking
有三种方式可以执行一个脚本，他们的效果差别很大，
1. 使用sh命令，或者./ (默认)
   执行的脚本将会作为调用脚本进程的子进程执行，这将会影响环境变量 (父进程必须通过export传递给子进程，而子进程无法传递给父进程)
2. 使用source，或者. ./
   执行的脚本在原进程中执行，因此继承并且可以修改原进程中的所有环境变量
3. 使用exec
   执行的脚本将会替换原来执行的内容，在该命令后的原脚本的内容都将不再执行

Apr 14, 2012 ELP (Emacs Lisp Profiler)可用来对Emacs进行Profiling
有三种方式:
  - elp-instrument-package
  - elp-instrument-function
  - elp-instrument-list

通过 elp-results 可以查看对特定函数的profiling结果。
这样可以发现一些性能上的瓶颈。

Apr 17, 2012 dpkg错误处理
有时候倒霉会碰到dpkg包管理错误（比如安装时突然断电）
一旦发生这样的错误，往往后续的安装将会失败或者报错，通常情况下apt-get之类的无法修复。

以下是一些修复的方案：
1. 先尝试最基本的dpkg修复
   - 使用dpkg --audit查看错误
   - 使用dpkg --remove/--configure/--install/--purge等对出错包进行处理
2. 如果以上还不能成功
   - 使用dpkg --force all --remove
2.5 如果还不行
   - 使用aptitude update, aptitude install -f进行修复
3. 如果还不成功
   - 保存/var/lib/dpkg/status
   - 打开/var/lib/dpkg/status，找出出错的包所在的 Package: XXXX的行
   - 删除从Package: XXXX的整个该包的信息
   - 保持下一个包和上一个包仅隔一行
   - 然后使用aptitude install -f重新安装
4. 如果还不成功， 恭喜你！

Apr 19, 2012 软件介绍
unetbootin可以使得grub2加载硬盘上的iso文件，因此免去了刻盘的麻烦。
比起徒手去load各种iso镜像。方便很多。

virt-manager是一款很好的管理kvm虚拟机的软件。
但是ubuntu karmic上0.7.0的版本是破损的。

win32下可以使用Git for Windows + Toitose Git来使用git
另外，作为git server端的用户配置，可以之用gitosis
gitosis是一个在git仓库中被版本管理的管理git仓库访问权限的配置项目。

doxygen可以生成代码文档，配合emacs的doxymacs可以很轻松生成针对
代码的文档注视。需要注意doxygen -g默认生成的Doxyfile中，是不生成XML TAG
的，而doxymacs若需要扫描，就需要这个TAG。所以除非仅仅把doxymacs
当添加标准注释工具，就有必要配置配置Doxyfile.另外，使用doxygen-gui的
doxywizard可以方便的进行配置。

Apr 19, 2012 Gentoo 镜像站点
- 源镜像
  Gentoo的full source mirror大小大概240G以上，
  包括
	distfiles（源码目录140G）,
	snapshots(portage快照600M）,
	releases（正式stage, livedvd发布40～50G),
	experamental(实验性的发布， 20～30G)

  镜像站点的制作可以只包括前两者（叫做partial mirror)或者所有(叫做full mirror)
  同步镜像使用rsync工具，要求每个站点4小时同步一次。

- rsync镜像
  除了源镜像还有一种镜像是保持多个机器间的portage同步的
  通常是使用一台机器作为rsyncd服务，提供给其他机器进行同步

May 8, 2012 git submodule 相关命令
修改子模块的remote:	  更新.gitmodule后运行git submodule sync
删除子模块: 	   	  更新.gitmodule和.git/config后，使用git rm --cached 子模块路径 将其删除
忽略子模块的dirty变化：	  在.gitmodule中子项目配置下加入ignore=dirty

May 8, 2012 udev设备管理器
linux系统中的udev负责设备管理的工作，通过内核sysfs和uevent获取设备信息，根据/etc/udev/rules.d下的配置，
对设备执行相应的动作（包括在用户层将设备映射到/dev目录下的文件，执行指定的脚本等）

通过udev系统解决了两大问题：
1. /dev目录下的文件在传统unix中是固定的，因此对于添加设备文件，或许需要手动进行。还有如果某些设备的链接拓扑结构变化时，文件将指向错误的设备。
2. 当某些设备挂载到系统中时，可能需要自动执行一些初始化程序，通过udev的rules就可以轻松实现。

注：
1. 在udev出现之前，devfs在2.4内核中管理/dev目录，类似于udev，但却是内核态的。现在多数发行版已经使用udev替代它。
2. udev后续版本严重依赖于uevent，所以基本上在2.6之前的内核很可能不会支持了。
3. udev在2.6内核中一段时间使用hal层，后来hal被merge进了udev，所以现在3.0之后的基本上都看不到hal这个东西了。

May 8, 2012 linux bridging设备
linux内核可以配置成伪装的bridge设备，当启用CONFIG_BRIDGE后，
可以使用bridge-utils的brctl来给linux添加网桥。

网桥是工作在二层的设备，它能够将两个物理网段链接起来。在linux系统中的具体应用就是
通过将两块物理网卡桥接到这个虚拟的网桥中，将把两块物理网卡所在的网段在二层上打通。

注：
1. 当linux作为网桥设备时，它的两块物理网卡都处于混杂模式，且没有IP地址的。
这个时候，如果仍然想让linux工作在IP层的话，其实可以给创建的网桥配置一个IP。
这样就可以通过这个IP访问作为网桥的Linux系统了。
2. 如果应用场景是qemu-kvm之类的虚拟机环境，那么内核还需要启用CONFIG_TUN对tun/tap设备的支持。

May 8, 2012 ibus与emacs ibus-mode的冲突
当在ibus设置窗口的[Advance]页面中启用了[Share the same input method among all applications]的时候，
这个与ibus-mode中的ibus-mode-local冲突了，使得会不断的报告IMContext ID xx is mismatched的错误。
这个时候可以关掉[Share the same input method among all application]

May 15, 2012 X property和X client message
X Client可以通过property来存储一些客户端特定的数据，通常Window Manager为了管理窗口会定义
一些特定的属性。通过获取这些属性就可以了解窗口相关的信息。在cli下，可以通过xprop命令获取特定窗口的属性。

在Emacs下，可以通过x-window-property函数获取属性，要注意的是type参数一般用"AnyPropertyType"，
vector-ret-p是t，如果窗口没有属性，就会返回nil,如果返回其他的结果，则可能是type参数或者vector-p参数不正确。

另外，可以通过修改属性或者发送客户端消息的方式来修改特定的属性，在Emacs中可以使用x-send-client-message函数
来达到这个目的。

May 15, 2012 polkit与consolekit
policykit提供权限认证的API给一些拥有权限的程序(Mechanism)，让这些程序来验证那些没有权限的程序发来的动作请求。
这些请求可能通过DBUS或者Unix pipeline传来。通过验证这些请求，就可以赋予这些无权限的程序一些有权限的程序才能作
的事情。
polkit包括了一个在dbus上的认证机构authority,以及每个用户session上运行的认证代理agent。代理agent用来表明客户程序
是特定用户session下的客户程序。机构authority用来验证权限。

通过pkaction可以查看当前在polkit管辖下的动作。通过pkcheck可以检查，通过pkexec可以以另外一个用户身份执行

consolekit是用来管理用户session和权限的，通常使用它来允许一般用户mount移动存储设备或者关机重启这类一般应该由root才能
完成的动作。

May 16, 2012 gitosis管理员key变更
当gitosis的管理员key变更的时候，简单的更新key目录下的pub文件是不行的。
这个时候需要到gitosis-admin的bare目录中运行su -H -u git gitosis-init < /path/to/new_public_key.pub
重新初始化管理员使用的key。

May 16, 2012 sb-unix是内部使用的包
在SBCL中，sb-unix并不是开放给外部使用的，而是为了内部实现使用的，这个和CMUCL不同。
它的函数定义很可能会发生变化。如果需要使用类似功能，需要使用sb-posix或者直接使用FFI

May 17, 2012 racket的scribble语法
通过@表达式可以简化一般S-exp的写法，使得编写像文档一样的代码很容易。
这样通过scribble就可以生成文档。
@表达式的语法一般是@<cmd>[<datum>*]{<text-body>*}
这其实是(<cmd> <datum>* <parsed-body>*)函数调用的语法变形。

另外，@表达式还支持直接的racket模式的函数调用@(frob arg1 arg2 ...)

在@表达式中可以嵌套其他的@表达式，这将类似于在函数调用的参数中还有函数调用。
如果想要转义这种动作，可以使用|{...}|的括号形式,这样一般嵌套的@就会作为普通的字符。
如果这时还需要@表达式，就需要使用|@代替。如果|{括号形式中间包含其他诸如<<之类的字符，
那么|}和|@也必须包含这些字符的反向才能达到效果。
e.g.
	@foo|{@abc}| => (foo "@abc")
	@foo|{|@"abc"}| => (foo "abc")
	@foo|<<{|@abc}>>| => (foo "|@abc")
	@foo|!{|!@"abc"}!| => (foo "abc")

另外@| ... |可以将其中的任何内容转义为racket代码，防止{}将其视作文本，而@||可以将{}中连续的文本分开。

@表达式中的<cmd>部分也可以没有，这个时候其实类似于一个list，通常需要和quote一起使用。
当<datum>和<text-body>都省去的时候，<cmd>部分就直接以<cmd>的文字形式出现，不会外加括号。
这通常可以作为对racket中symbole的转义，e.g. @"@"

@和<cmd>之间还可以有任何的标点，如'`@@#;之类的，这些标点会被放到变换后的s-exp的最前面
e.g. @'foo{blah} => '(foo blah)
一般这样可以实现注释，@; bla bla bla或者@;{ <any>* }，注意第二种方式<any>还是需要符合@表达式语法的。

一般情况下@表达式是在scribble/base, scribble/manual, scribble/sigplan这样的包中的
也可以通过meta-lang的特性将其引入一般的module中，e.g. #lang at-exp racket

最后因为引入了@表达式的语法，一般的s-exp中的符号就不能以@开头了。如果必须以@开头，则需要通过\或者|来转义。

May 18, 2012 DrRacket中输入Latex符号
在DrRacket中可以通过\<macro> Meta-\的方式输入非ascii字符。
如: \Lambda Meta-\将会显示希腊字母兰母达。或者\smiley Meta-\输入将显示一个笑脸。
另外，也可以通过C-\迅速输入一个兰母达字符。

May 21, 2012 git refname XXX is ambiguous警告
当git中某个branch的名字是HEAD或者是origin/master的时候，
这将使得与git中固有的符号相冲突，进而在运行一些git命令的时候会报出警告。
如当运行git rev-list HEAD --not origin/master的时候，如果
有一个branch名字恰巧叫origin/master的话，就会有：
refname 'origin/master' is ambiguous 的警告。

May 22, 2012 CLHS中编译器相关

3.2.1 编译器术语

- compiler是将代码翻译成与特定实现相关（表示或者执行效率会提高）代码的过程。术语compiler指的就是compile和compile-file这两个函数。
- compiled code指的是被编译后的程序代码的对象表示，这些对象由compile或者在加载被编译文件是的load创建。
- implicit compilation指的是在evaluation时的编译处理。
- literal object指的是quoted对象或者self-evaluating对象，以及这些对象的子对像。但不包括常变量。
- coalesce指的是在源代码中两个不同(not eql)的literal object - A和B， 在被编译后对应的对象A'和B'相同了(eql)的优化
- minimal compilation指的是编译时标准规定的最少动作。

- 动词process指的就是进行minimal compilation，如确定代码求值的时间，或者对其求值（如果需要的话）
- further compilation指的是在minimal compilation之后实现相关的特殊编译过程。process并不说明完整的编译。
  诸如block compilation或者生成特定机器指令的编译过程都是further compilation的内容。further compilation可以发生在运行时。

与编译相关的环境由四种：startup environment, compilation environment, evaluation environment, runtime environment.
- startup环境指的是compiler运行启动时的Lisp image环境。
- compilation环境由编译器维护用于存储编译器内部需要的定义和声明。只有必须的部分会保存在该环境中。诸如传递给macro expander的环境参数就是compilation环境。
- evaluation环境是runtime环境的一种，所有由编译器发起的求值动作都在该环境中进行，如macro expander以及由eval-when指明的求值。
- runtime环境是指被编译的代码运行的环境。

compilation环境继承evaluation环境，它们可能相同。evaluation环境继承startup环境，它们可能相同。

- compile time指的是编译器处理源代码的时间段。在compile time中，只会有compilation和evalutaion两个环境。
- run time指的是loader加载了被编译后的代码，代码运行的时间段。在run time中，只会由runtime环境。

- run-time compiler指的是通过函数compile或者implicit compilation进行的编译，此时编译和运行时环境在同一个Lisp image中。此时runtime环境等同于startup环境。

3.2.2 编译语义

从概念上来讲，编译就是一个遍历代码、根据在compilation环境中的特定信息对代码语法语义进行分析、生成等价的更加高效的代码的过程。

3.2.2.1 compiler macro
一个compiler macro的名字也可以是function或者macro的名字。它们可以同时存在。
如果在给定的词法环境中一个函数的名字作为compiler-macro-function参数的时候，它的返回值不是nil，那么就说明在该词法环境中，存在一个compiler macro。但是新创建的local函数或者宏定义会更新当前的词法绑定(lexical binding)，以至于覆盖shadow存在的compiler macro。

由compiler-macro-function返回的结果是一个两个参数的函数，它叫做expansion function。为了展开compiler macro，需要调用macroexpand hook，并将expansion function、整个compiler macro代码以及当前的compliation环境作为参数。然后macroexpand hook会调用expansion function来展开compiler macro。返回的展开结果也许跟展开前的compiler macro代码完全相同，这个展开结果会替换原来的代码。

*macroexpand-hook* compiler-macro-function define-compiler-macro

3.2.2.1.1 compiler macro的目的
compiler macro的目的是允许通过选择性的源代码变换来优化编译。对于一个compound代码的process, 如果代码中的操作符是一个compiler macro, compiler-macro-function可能被调用来将代码展开，展开后的代码则会替换原来的代码被进一步的处理。

compiler macro function(expansion function)如同普通的macro function, 接受两个参数：一个是整个的macro代码，另外一个就是环境。
但与一般的macro function不同，compiler macro function可以拒绝展开，直接返回原来的代码。

如果compile-file选择展开一个top level form的compiler macro form。那么展开后的代码仍然被当作top level form处理。

3.2.2.1.2 compiler macro命名
compiler macro的名字可以与函数或者macro的名字相同。但是它是严格全局的。所以不可能像macrolet一样定义局部的compiler macro。想法，局部的函数定义和宏定义会覆盖（shadow）全局的compiler macro。

注意compiler macro的存在不会影响存在的同名函数和宏定义。因为compiler macro是全局的，通过compiler-macro-function足够区分它们与那些词法环境中定义的函数和宏。

3.2.2.1.3 什么时间使用compiler macro
有以下两个情况是绝对不能使用的，其他情况标准不指定：
- 当词法绑定被同名的函数或宏覆盖的时候
- 当函数名被声明为notinline，恰巧该段代码在声明中。

3.2.2.1.3.1 compiler macro实现注意
虽然技术上允许在eval的时候和compile的时候，对compiler macro做相同的处理。但是在interpreted implementation中，可不是一个好主意。
因为compiler macro是用来通过在编译期展开来优化运行时速度的，通过compiler macro编译器也许需要话更长的时间进行编译。这在interpreted implementation中eval这么做就比较低效了。

3.2.2.2 minimal compilation
minimal compilation定义如下：
- 所有出现在源代码中的compiler macro被展开。在运行时时，它们不会展开。
- 所有的macro和symbol macro都会在编译期展开，展开直到在运行时不需要再展开。
  macrolet和symbol-macrolet都被它们body部分的代码替换、这些代码中引用的宏也将被展开替换。
- 在load-time-value代码中的第一个参数，会被compile在compile time求值。但在compile-file的处理中，编译器安排它在load time求值。两种情况下，求值的结果都会被记录下来，用于在运行时execution time的load-time-value的值。

3.2.3 File Compilation
函数compile-file根据3.2.2 Compilation Semantics定义的规则编译，产生一个能被load加载的文件。
通常，在被compile-file编译的文件中的top level form不会在编译时被求值，而是在被编译的文件被加载时。但有时，一个典型的情况就是文件中的代码需要在编译期求值，然后余下的代码才能顺利的被继续编译。

eval-when特殊form就是用来控制top level form在compile time、load time的求值的。对于一个top level的eval-when代码段来说，:compile-toplevel会使其在compile time被编译器求值。:load-toplevel则会使得编译器安排它在load time求值。而对于非top level的eval-when代码段，:execute可以使其在runtime环境中被执行。


eval-when的行为可以准确的用compile-file进行process的模型来理解：有两种process模式，“not-compile-time"和“compile-time-too"

compile-file在not-compile-time工作模式下会从文件中读取代码，并将这些代码的求值安排在load time而不是在compile time中直接求值。
在compile-time-too模式下，则在load time和compile time中都会求值。

3.2.3.1 对top level form的处理

"一个top level form就是被compile-file进行特殊处理的form，进行特殊处理的目的是允许在编译期求值。个人理解就是，只有在file compilation中存在toplevel form。"

1. 如果代码是一个compiler macro form(并且没有被notinline禁止)，编译器可以选择是否展开并处理它。如果不展开，那就必须处理原先的代码。
2. 对于macro form，会将其当作toplevel form展开和处理。
3. 对于progn， 它的内部的每个form都当作toplevel form展开处理。
4. 对于locally, macrolet或者symbol-macrolet, compile-file在建立了合适的绑定后，处理器内部的form如同top level form的处理。
5. eval-when的处理:

CT LT E Mode Action New Mode
Y  Y  - -    P      compile-time-too
N  Y  Y C    P      compile-time-too
N  Y  Y N    P      not-compile-time
N  Y  N -    P      not-compile-time
Y  N  - -    E      -
N  N  Y C    E      -
N  N  Y N    D      -
N  N  N -    D      -

Y for Yes, N for No, C for compile-time-too, N for not-compile-time, P for process, E for Evaluate, D for discard
- in Mode for irrelevant, - in New Mode for remain in current mode

在compile-time-too模式下，process意味着首先编译器在evaluation环境中对其求值，然后进行minimal compile。而not-compile-time模式下，process仅仅是minimal compile。

6. 所有subform都认为是非top level form

注意:
- 对于top level form，编译器是按照在代码里出现的顺序进行处理的。而对于非top level form的subform的处理(包括宏展开)还有further compilation标准不要求顺序，只要符合compliation semantic。
- 对于非top level form, eval-when的:compile-toplevel和:load-toplevel都会被忽略(使用compile或者eval进行编译和求值时也是如此)。对于非top-level form，eval-when指定:execute的时候被当作一个implicit progn处理。

May 22, 2012 SBCL 各种编译过程IR1前的处理调用关系
1. 通过repl中输入代码的编译(implicit compilation)

							       +--<---+
							       |      |
     							       |      ^
       +------------+         +------------+         +---------+---   |     +------------+         +------------+         +------------+         +------------+        +------------+
       |            |         |            |         | simple-eval|   |     |            |         |            |         |            |	 |            |        | make-functi|
       |            |         |            |         | -in-lexenv +->-+     |            |         |compile-in- |         |            |	 |            |        |onal-from-to|
       |interactive |-------->|  eval      |-------->| or         |-------->|%simple-eval|-------->|lexenv      |-------->|actually-   |-------->| %compile   |------->|p-level-lamb|-------->
       |   -eval    |         |            |         | eval-in-lex|         |            |         |            |         |compile     |	 |            |        |da          |
       |            |         |            |         | en         |         |            |         |            |         |            |	 |            |        |            |
       +------------+         +------------+         +------------+         +------------+         +------------+         +------------+	 +------------+        +------------+

       设置repl的一些变量        设置*eval-x-x*            分派处理               创建用于求值的           编译后，设置函数          初始编译相关信息            编译开始                IR1 变换
       如：*, **, /, //        这些全局变量                                     named lambda          或宏名字与编译结果         compilation-unit
                                                                             编译后，求值            的绑定


      注：
      1. simple-eval-in-lexenv会循环调用simple-eval-progn-body, simple-eval-locally以及自身

2. 通过compile-file的编译										       +-----------+
													       |           |
										    +----<----+		    +>-+ eval-tlf  |->+
									            |         |		    |  |           |  |
										    |	      ^		    |  +-----------+  |
       +------------+         +------------+         +------------+         +-------+----+    |    +--------+---+         +---+--------+         +------------+
       |            |         |            |         |            |         |            |    |    |convert-and-|         |            |	 |            |
       |            |         | sub-compile|         |sub-sub-comp|         |process-topl+->--+    |maybe-compil|         |ir1-toplevel|	 |            |
       |compile-file|-------->| -file      |-------->|ile-file    |-------->|evel-form   |-------->|e or eval-co|-------->|            |-------->|compile-topl|-------->
       |            |         |            |         |            |         |            |         |mpile-toplev|         |            |	 |evl         |
       |            |         |            |         |            |         |            |         |el          |         |            |	 |            |
       +------------+         +------------+         +------------+         +------------+         +------------+         +------------+	 +------------+

       设置代码文件相关          动作类似于              循环处理每个toplevel     宏展开，eval-when处理         编译开始                 IR1变换                后续编译动作
       变量，source-info       actually-compile                            minimal compilation
       file-info,输出          另外，还包括dump fasl
       fasl文件等


       注：
       1. 当eval-compile-toplevel时会先求值，然后对求值部分编译。eval-tlf和eval类似，不过会设置*eval-tlf-index*，并且支持从非null-lexenv求值。
       2. process-toplevel-form会根据情况递归调用process-toplevel-progn, process-toplevel-locally及自身。这点和simple-eval-in-lexenv有点类似。

3. 通过compile的编译（run-time compilation）


       +------------+         +------------+         +------------+         +------------+        +------------+
       |            |         |            |         |            |         |            |        | make-functi|
       |            |         |compile-in- |         |            |	    |            |        |onal-from-to|
       | compile    |-------->|lexenv      |-------->|actually-   |-------->| %compile   |------->|p-level-lamb|-------->
       |            |         |            |         |compile     |	    |            |        |da          |
       |            |         |            |         |            |	    |            |        |            |
       +------------+         +------------+         +------------+	    +------------+        +------------+

        基本同1的过程的后半部分。如果是从repl输入的compile, 那么compile之前就是simple-eval-in-lexenv。


May 24, 2012 SBCL编译feature
编译sbcl源代码的时候，可以指定一些feature，如以最高debug优化等级编译sbcl
全部的feature在base-target-features.lisp-expr中定义。
通过make-config.sh --with-<feature> 以及--fancy， 可以打开一些feature。
打开后的feature在local-target-features.lisp-expr中可以找到。

如可以make-config.sh --with-sb-debug --fancy

May 29, 2012 Racket reader
在racket中宏扩展只能扩展语言，它表现出两个层面的限制：
1. 不能限制或者修改所在上下文中的既有语法以及周围的form。
2. 只能够在语言的词法规定允许的范围内进行扩展，但不能改变s-exp的使用，如()[]{}, 不能改变一些核心语法，如，identifier，keyword的写法。

因此说宏扩展是在展开器层(expander layer)上的语言扩展。
还有一种就是在读入器层(reader layer)上的语言扩展。

在racket中，宏扩展使用define-syntax和define-syntax-rule，通过操作syntax-object实现扩展。

- Reading via an Extension
而reader则通过模块和readtable来进行扩展。
#reader <module> 通过使用用户在module中自定义的read和read-syntax对其后续的代码的读入方式进行改变，这样就改变了reader原来的语法，按照用户自定义的方式读入。
另一种类似的方式是通过#lang reader <module>，类似于#reader，但整个改变了后续的语法，要求<module>的read和read-syntax产生的结果必须是个module form。
另外，若新语言是基于已有的语法的，可以使用#lang s-exp syntax/module-reader定义新语言的module，它可以在s-exp的基础上扩展部分的reader语法，这样简化了新语言的创造。
（通过重新provide新的绑定read和read-syntax以及使用readtable）。

实际上#lang reader类似于#lang s-exp，后者允许#lang使用独立的模块语言，s-exp在这里表示在reader层上使用s-exp作为基本语法，而前者则一开始就指名使用用户自定义的reader语法而不是s-exp。
在racket的scribble中就有类似的使用，@-exp, #lang @-exp 表示使用@表达式，这里reader, @exp, s-exp都被叫做meta-language。

最后，如果你想直接使用#lang <module language name>来代替#lang reader <module>，你必须安装这些<module>到collection中。
具体方法可以是：
把module文件改名，并放入如下：<module language name>/lang/reader.rkt路径中。
使用raco link <module language name>安装到collection
或
使用raco pack --collect <module language name>.plt <module language name>打包到一个.plt文件中
使用raco setup -A <module language name>.plt安装

- Readtable
默认的reader是一个递归下降分析器（recursive-descent parser）。（想像根据不同的case递归调用自己完成parse的过程）
默认的reader定义了基本的语法，包括哪些字符拥有特殊的含义。可能将(){}[]",`';以及空格定义为分隔符，另外#会是一般的宏分派字符，|\则定义了基本的转义功能。
但这些语法可以通过readtable以及其他一些参数来进行扩展。

如，修改(在readtable中的含义，通常情况下，当遇到(时，都会递归的读取后续的subform直到遇到)符号。
通过parameterize current-readtable以及make-readtable就可以修改默认的readtable来实现一些小的语法变化。

和CL readtable中众多的char type相比，racket中只有三种，
terminating-macro 使得char类似于delimiter，即便在标示符中间也会引起readtable相应的proc进行特殊处理
non-terminating-macro 仅仅出现在标示符开头时才会引起proc特殊处理
dispatch-macro如同non-terminating-macro,不过他必须出现在#后面，或者准确的说，任何行为被定义为#hash的符号后面。

- Racket的read chain
通过read读取racket的代码时，当遇到#lang 或者#reader的时候，read就会递归的调用这些语言扩展机制的模块中新定义的read，这样就完成了对不同语法的一致的read。
个人觉得这个是站在比较高的抽象层次上的一种语言机制(比起CL的reader就更加general。)
通常情况下，读取也许不被允许，这可以通过改变read-accept-lang和read-accept-reader参数来改变。

May 29, 2012 SBCL编译器术语辨析
local call指的是functional和combination在同一个component中的调用。
XEP指的是external entry point, 函数调用都是通过entry point调入被调函数体的。但是如果不是local call的时候，就需要一个外部的entry point。这个XEP就是给非local call的调用提供的entry point。
cleanup一般对应entry，它主要用于处理dynamic extent在退出范围时候的清理工作，entry就是它的messup。


May 30, 2012 racket hygeinic macro
racket的define-syntax, define-syntax-rule, syntax-rules, syntax-case, 还有with-syntax
前两个都用来引入新的macro，后面的都是辅助函数。
在racket中有两种方式可以定义hygienic macro，一个是syntax-rule，通过简单的pattern<->template match方式实现
另一个则比较复杂，syntax-case，通过操作syntax-object来实现。可以说后者就是前者的更底层。

syntax-object可以看成是包括了代码的literal表示，以及srcloc, col, pos这类代码信息的结构。
在racket中通过#'操作符可以将一个代码变成syntax-object, 我个人感觉是，这个操作符类似于quote，只不过是在语法层面上的quote。
syntax-case会将一个syntax-object与一个pattern进行match，并将pattern中的变量绑定在后续的操作中，这样就可以在后续通过pattern variable重新访问syntax-object中的对象。
with-syntax和syntax-case功能基本一样，只不过前者是用来一个一个match的，后者则match其中的一个pattern case。

在hygeinic macro中 ... 符号非常特殊，它在match pattern中用来表示一些一类，这样的概念，作为pattern variable的一种。

最后需要注意的是，由于macro是在编译期展开的，定义的helper function必须能够在编译期被访问。(理解：因为通常情况racket没有toplevel的函数定义，而modulelevel在编译期不会求值，所以必须要由个途径在编译期对helper求值。这类似于CL中的eval-when)
这就要求helper function通过begin-for-syntax或者require for-syntax这样的form将其包裹起来，前者类似begin，后者通常是用于将helper function作为独立的module使用时引入。

常用函数：
define-syntaxes, define-syntax, syntax-case, syntax-case*, with-syntax, with-syntax*, syntax-rules, syntax-id-rules
identifiers?, syntax?, syntax, quote-syntax, quasisyntax, unsyntax, unsyntax-splicing, syntax->datum, syntax-e, syntax->list, datum->syntax
syntax-source, syntax-line, syntax-column, syntax-span, generate-temporaries
bound-identifiers=?, free-identifiers=?
set!-transformer?, make-set!-transformer, set!-transformer-procedure, rename-transformer?, make-rename-transformer, rename-transformer-target, local-expand
define-syntax-parameter, syntax-parameterize, splicing-syntax-parameterize, splicing-let-syntax
syntax-property, syntax-property-keys
syntax-arm, syntax-protect, syntax-disarm, syntax-taint, syntax-tainted?
expand, expand-syntax, expand-once, format-id, define-for-syntax, begin-for-syntax, require for-syntax

May 31, 2012 racket的syntax model
racket中reader负责将文本代码转化为syntax object(通常是通过read-syntax)，
而expander主要负责将syntax object进行展开(根据它的binding information)，使得代码达到fully parsed的程度。

展开过程expansion process是由syntax object的绑定binding驱使的，当expander遇到一个绑定binding form的时候，
它会扩展子表达式的syntax object并加入新的绑定信息binding information。

* identifiers binding
  标示符identifiers在racket中可以被理解为代表程序的实体，比如代表某个变量引用，表达式form引用，或者甚至被quoted起来代表symbol或syntax object。（理解：这里的理解identifiers就是symbol或者quoted expressions）
  当一个identifiers bind另外一个identifiers的时候，前者就是后者的variable,后者就是bounded identifiers。
  绑定能够作用的代码构成了绑定的范围scope。一段代码所处在的环境environment就是包围该段代码的所有绑定构成的集合。

  绑定可以分为: top-level, module, local三种。

* phase level
  每个绑定在racket中都有一个phase level。
  模块内部宏展开期的绑定phase level为1, 这些绑定构成的环境叫transformer environment
  模块内部运行期的绑定phase level为0，这些绑定构成的环境叫base environment
  如果一个模块为了自己的phase level 1引入了另一个模块，另一个模块相对以这个模块处于phase level -1，它构成的环境叫template environment。

  local绑定只能在特定的phase level被访问。top-level和module可以构成不同phase的绑定(理解：通过require for-syntax？)

* syntax object
  就是将symbol或者form与lexical information, syntax property, tamper status, src-loc information等信息组合在一起构成的对象。
  特别的讲，identifiers本身就是将symbol与lexical及其他information组合在一起构成的syntax object。

  free-identifiers?用来判断两个identifiers是否有相同的binding
  bound-identifiers?用来判断两个identifiers是否有绑定关系

  每个syntax object有三种tamper状态，tainted, armed, 和clean。
  当处于tainted状态的时候，expander拒绝使用它作为binding或者变量。
  armed状态下，任何使用syntax-e, syntax->datum之类的操作会使得armed变成tainted, 除非先disarm

* Expansion
  展开是递归的针对某个syntax object进行的，起始时的phase level为0. syntax object的lexical information中的binding information会
  驱使展开的进行，并可能将新的binding引入其子表达式的lexical information中。

  只有三种绑定是可能能够继续下去的：
  - transformer binding
  - variable binding
  - core syntactic form

  展开的每一步还和上下文有关，对于transformer和core syntactic form，不同的上下文，展开都可能不同：
  - top-level context 代表top-level
  - module-begin context 代表在module体内唯一的begin form
  - module context 代表在module begin体内
  - internal definition context 代表在define之类的定义内
  - expression context 代表在一般表达式内

* syntax transformer (a.k.a macro)
  当使用define-syntax之类的form的时候，会在phase level 0引入transformer binding，
  如果该绑定是一个单参的procedure的话，那它就是一个syntax transformer。syntax transformer接受一个syntax object， 返回一个syntax object。
  而expander会使用其返回的syntax object继续parse。

  另外对这个单参procedure的求值是需要先展开然后再求值的，但这些都是在phase level 1中进行的。(理解：这就是为什么define-syntax syntax-case的时候，helper function要使用begin-for-syntax引入）

  在expander将一个syntax object传给syntax transformer的时候，这个syntax object是要被syntax mark的，只有当mark和binding都相同的时候，才认为是bound-identifiers?
  （理解：这个mark的过程，就是保证hygeinic macro的过程）

  hygeinic导致的问题是，在输出的syntax object(template)中，引入的变量都会重新命名(或者叫做mark)，使得不会和周围的identifier冲突，但如果需要突破这种hygeinic的限制（某些情况下想要某个id不被hygeinic）
  通常都可以在syntax-case中，使用with-syntax创建固定名称的identifier，或者仍然使用hygeinic但是使用syntax-parameter构成一个dynamically scoped的id。

Jun 1, 2012 SBCL IR1 Conversion	Call Flow
ir1tran.lisp
ir1-translators.lisp
ir1tran-lambda.lisp
main.lisp

	 +---------------------------+		         +-------------------------+-+
	 |             	       	     +--------->---------+ ir1-convert-inline-lambda |
	 |  ir1-convert-lambdalike   |	                 |                           |
	 |                           |    	 +-------+                           |
	 +-----------------------+---+        	 |       +---------------------------+
				 |	         |                                                       	                                    		                                                       							    |               |                       							                                          							                                               |               |
				 |		 |
				 |		 |
			      +--+---------------+----+
			      |                       |
			      |  ir1-convert-lambda   |
			      |                       |
			      +---------+-------------+
					|
					|
				+-------+----------+
				| make-lambda-vars |								+-----------------------------------+
				|                  |								|      	      	   	      	    |
				+-------+----------+								|  process-type-decl	      	    |
					|									|  process-package-lock-decl  	    |
					|									|  process-optimize-decl      	    |
				+-------+----------+				 +-----------------+		|  process-extent-decl	      	    |
				| process-decls    +-----------------------------+  process-1-decl +------------+  process-inline-decl	      	    |
				|                  |	                      	 |                 |		|  process-ignore-decl	      	    |
				+------------------+	            		 +-----------------+		|  process-unmuffle-condition-decl  |
				  +--------------------------------------<--------------------------------------+  process-muffle-condition-decl    |
				  |		                     						|  process-ftype-decl	      	    |
	   +----------------------+----+		    +------------------------------+			|  process-special-decl	      	    |
	   |                   	       |		    |          	       	       	   +-----------<--------+                                   |
	   |  ir1-convert-lambda-body  | 		    |   ir1-convert-hairy-lambda   |           		+-----------------------------------+
	   |                   	       |		    |          	       	       	   |
	   |                   	       |		    |                          	   |
	   +---------------+-----------+		    +--------------------------+---+
			   |							       |
			   |							       |
			   |	     +------<----+				       |
			   |	     |		 |				       |	       +-----<------+
	   +---------------+---------+------+	 |				       |	       |	    |
	   |           	       	      	    |	 ^				  +----+---------------+-------+    ^
	   |           	       	      	    |	 |				  |    	      	               |    |
	   |  ir1-convert-special-bindings  +----|				  |   ir1-convert-hairy-args   +----+
	   |           	       	      	    |					  |                            +-----------------<------------+
	   |                                |					  +-------------------+-------++			      |
	   +--------------+-----------------+							      |	      |				      |
			  |									      |	      +-------->-----------+	      ^
			  |									      |				   |	      |
	   +--------------+-----------------+							      |				   |	      |
	   |                   	       	    |						      +-------+----------+	  +--------+----------+-------------+
	   |  ir1-convert-aux-bindings 	    +---------------+				      |	                 |	  |                            	    |
	   |                   	       	    |		    |				      | ir1-convert-more | 	  | generate-optional-default-entry |
	   +--------------+-----------------+		    |				      |                  |	  |                            	    |
			  |				    |				      +-------+----------+	  +------------------+--------------+
			  |				    |					      |					     |
       +---------+	  |				    |					      |					     |
       | 	 |	  |				    |				     +--------+-------------+    	+------------+--------------+
       ^   +-----+--------+-------------+		  +-+------------------------+	     |  convert-more-entry  |    	|   convert-optional-entry  |
       |   |                            |		  |            	       	     |	     +----------------------+    	+---------------------------+
       +-<-+  ir1-convert-lambda-body   |		  | ir1-convert-progn-body   |
	   |                            |		  |            	       	     |
	   +--------------+-------------+		  +---+----------------------+
			  |				      |
			  |				      |
	   +--------------+-----------------+		      |
	   |  ir1-convert-combination-args  |		  +---+-----------+
	   |           	       	            |		  |            	  |
	   +--------------------------------+		  | ir1-convert	  |-----------------------------+---------------------+-------------------------+
							  |               |				|		      |				|
							  +---+-----------+				|		      |				|
							      | 					|		      |				|
							      | 					|		      |				|
							      |  			    +-----------+--------+    +-------+----------+     +--------+---------------+
							      |  			    |          	         |    |        	       	 |     |       	       	        |
							      |  			    |   ir1-convert-var  |    |  reference-leaf	 |     |   reference-constant   |
							      |  			    |                    |    |        	       	 |     |       	       	        |
							      |  			    +--------------------+    +------------------+     +------------------------+
							      |
					    +-----------------+--------+
					    |          	     	       |
  +-----------------------+                 |   ir1-convert-functoid   +---------------+
  | %%allocate-closures   |		    |                	       |	       |
  | multiple-value-prog1  | 		    +-----+--------------------+      +--------+-----------------+
  | progn                 |                       |                           |   careful-macro-expand   |
  | multipl-value-call    | 			  | 			      |              	         |
  | unwind-protect        | 			  | 			      +--------+-----------------+
  | quote                 | 			  | 				       |
  | function              |    +------------------+-----+	  +--------------------+----------+
  | macrolet              |    |                        |	  |            	       	       	  |
  | eval-when             |    |special-form translator |         |  ir1-convert-common-functoid  +---------------------------------+
  | global-function       +-<--+                        |	  |                    	       	  |				    |
  | let                   |    +------------------------+	  +--------+------------------+---+				    |
  | %funcall              | 						   |		      |					    |
  | %primitive            | 						   |		      |					    |
  | let*                  | 						   |		      |					    |
  | locally               | 						   |		      |					    |
  | flet                  | 			     +---------------------+--------+	   +--+------------------------------+ +----+-----------------+
  | labels                | 			     |             	      	    |	   |                   	    	     | |                      |
  | the	                  |                          |  ir1-convert-global-functoid |      |  ir1-convert-local-combination  | | ir1-convert-srctran  |
  | truly-the             | 			     |             	      	    |	   |                                 | |                      |
  | setq                  | 			     +---+--------------------+-----+	   +---------------+-----------------+ ++-----------+---------+
  | throw                 | 				 |	 	      |				   | 			|	    |
  | %with-cleanup         | 	                         |                    |                +-----------+---------------+	|	    |
  | %escape-fun           |                              |                    |                |  ir1-convert-combination  +--<-+	    |
  | %cleanup-fun          |             +----------------+-----+       +------+-------------+  +------------+--------------+		    |
  | catch                 |	        |                      |       |                    |   	    |				    |
  | if                    |	        |careful-macro-expand  |       |ir1-convert-srctran |   	    |				    |
  | block                 |             |                      |       |                    |  +------------+------------------+	+---+---+------------------------+	    +----------------------------------------+
  | return-from	          |	        |ir1-convert           |       |                    |  |                    	       |	|                                |	    |        	     	              	     |
  | tagbody               |             |                      |       |                    |  |  ir1-convert-combination-args |	|  ir1-convert-maybe-predicate   +----------+ ir1-convert-combination-checking-type  |
  | go                    |	        |                      |       |                    |  |                    	       |	|                                |	    |        	     	              	     |
  | symbol-macrolet	  |	        +----------------------+       +--------------------+  +-------------------------------+	+--------------------------------+	    +----------------------------------------+
  +-----------------------+


注释：
ir1-convert-lambdalike 用于转换lambda, named-lambda, global-function (lambda-with-lexenv)
ir1-convert-special-binding 如果由special binding，该函数会递归的处理每个special var，为每个svar创建special binding的cleanup，如果没有svar，就进入ir1-convert-aux-binding
ir1-convert-aux-binding 处理aux bindings, 对每个aux var创建一层lambda，然后创建一个combination用aux var的value作为参数调用lambda。如果没有aux var， 就进入ir1-convert-progn
ir1-convert-functoid 使用translator处理special form，或者如果碰到编译器宏，展开后使用ir1-convert-common-functoid处理。
ir1-convert-common-functoid 处理除了special form和compiler macro的其他情况。
ir1-convert-combination 处理combination中的fun部分，ir1-convert-combination-args实际创建combination并链接args和fun的lvar。
ir1-convert-srctran处理全局函数，可能进行代码变换（内联处理），或者和普通local combination处理一样（当是notinline的时候）。
ir1-convert-global-functoid 处理任何看上去像是个全局函数调用（没判断出来是个ir1-convert-srctran的情况，或者本身就是个宏的情况），如果是宏，就展开后继续处理，如果是个函数，就如同ir1-convert-src处理。
每个不同的special form translator会进行特别的处理，可能会递归的调用ir1-convert, ir1-convert-lambda（special form: function）等。


Jun 4, 2012 SBCL内部的“函数”
在IR1中函数被存在四种不同的地方：
1. *lexenv*， 通过lexenv-find可以找到这种定义在词法环境中的函数, 多为局部函数
2. *free-funs*, 在*free-funs*中的函数，为全局:defined或者是assumed的函数
3. global-var，这种就是全局的函数了
4. defined-fun，这种是定义在同一个编译块中，并且是expansion或者inline优化选项被声明的全局函数
   (注意，不管是inline还是notinline，只要声明的。)

具体有这么以下几个函数可以取得它们：
find-lexically-apparent-fun  --> find-free-fun  --> find-global-fun
			     	      +-----------> make-defined-fun

另外，在全局info数据库中，函数有三种类型，四种出处：
三种类型是：function, macro, special-from
四种出处是：assumed(还未定义，在一个函数内部调用，可能会产生warning), defined(已经定义出来的), defined-method(由CLOS定义的), declared（可能没有定义出来，但是函数类型已经通过declaim之类声明了）
通过(info :function :where-from <fun name>)取得。

最后，在最早的处理中(ir1-convert-lambdalike)其实有三种不同的lambda:
lambda			--- 普通的lambda， 这个和ANSI标准中的那个相同。
named-lambda 		--- 这个就是附带了一个名字的lambda, defun以及sb-c::%simple-eval都会生成这种lambda。
lambda-with-lexenv 	--- 这个和inline函数有关，当函数声明为inline，并且符合inline条件的时候，编译器需要保存一个inline版本的lambda，所以就会生成一个此类lambda。（生成代码在defun中。）
			    该lambda携带了其所在环境的信息，这包括decl, macro, symbol macro等信息（见maybe-inline-syntactic-closure函数）。

			    
Jun 4, 2012 SBCL INFO数据库
globaldb.lisp文件
INFO数据库提供一个函数接口来访问编译器全局的信息，这些信息可以跨编译访问。

从概念上讲，INFO被划分为class, 每个class再被划分为type, 可以针对某个符号name访问某个class的某个type的信息。
class是一个class-info结构，type是一个type-info结构。
*info-classes*存储所有class的{名字,class-info结构}哈希对。
*info-types*存储每个class的每个type, 并为其每一个分配一个type number(数组索引)。
通过define-info-class和define-info-type，可以添加新的class和info。

全局信息被存储在info-env结构中，*info-environment*中存储了所有{name, class, type}构成可以查询的信息。
通过(info class type name)函数来访问信息，通过(setf info)来存储信息，通过clear-info来清除信息。
常见的class type类型有：

|-----------------------+------------------------------|
| class                 | type                         |
|-----------------------+------------------------------|
| :function             | :type                        |
|                       | :assumed-type                |
|                       | :kind                        |
|                       | :where-from                  |
|                       | :inline-expansion-designator |
|                       | :inlinep                     |
|                       | :source-transform            |
|                       | :macro-function              |
|                       | :compiler-macro-function     |
|                       | :ir1-convert                 |
|                       | :info                        |
|                       | :definition                  |
|                       | :structure-accessor          |
|-----------------------+------------------------------|
| :variable             | :kind                        |
|                       | :always-bound                |
|                       | :type                        |
|                       | :where-from                  |
|                       | :macro-expand                |
|                       | :alien-info                  |
|                       | :documentation               |
|-----------------------+------------------------------|
| :type                 | :kind                        |
|                       | :expander                    |
|                       | :documentation               |
|                       | :translator                  |
|                       | :builtin                     |
|                       | :compiler-layout             |
|                       | :lambda-list                 |
|                       | :source-location             |
|-----------------------+------------------------------|
| :typed-structure      | :info                        |
|                       | :documentation               |
|-----------------------+------------------------------|
| :declaration          | :recognized                  |
|                       | :handler                     |
|-----------------------+------------------------------|
| :alien-type           | :translator                  |
|                       | :definition                  |
|                       | :struct                      |
|                       | :union                       |
|                       | :kind                        |
|                       | :enum                        |
|-----------------------+------------------------------|
| :setf                 | :inverse                     |
|                       | :documentation               |
|                       | :expander                    |
|-----------------------+------------------------------|
| :random-documentation | :stuff                       |
|-----------------------+------------------------------|
| :source-location      | :variable                    |
|                       | :constant                    |
|                       | :typed-structure             |
|                       | :symbol-macro                |
|-----------------------+------------------------------|

Jun 6, 2012 有趣的递归、迭代
1. 阴阳问题

(let* ((yin
        ((lambda (cc)
           (display #\@) cc)
         (let/cc c
           c)))
       (yang
        ((lambda (cc)
           (display #\#) cc)
         (let/cc c
           c))))
  (yin yang))

这段代码会不停的输出@#@##@###@####@#####......下去，
通过分析，运行的过程如同：
(yin yang)	输出@#
(yang yang')  	输出@#
(yin yang')   	输出#
(yang' yang'')	输出@#
(yang yang'') 	输出#
(yin yang'')  	输出#
(yang'' yang''')输出@#
(yang' yang''')	输出#
(yang yang''')	输出#
(yin yang''')	输出#
。。。。

理解这段代码的关键点在于理解每一次yang的continuation保存了该次对应的yin，只有yang对应的是yin, ying'以后的对应的都是实际上的yang。
所以就形成了一种循环的关系。

2. 尾递归与迭代不变式
loop invariant是用来研究迭代正确性的理论。loop invariant theorem说不变式在迭代前若为真，则在迭代后仍为真,并且在迭代的每一步都为真。
一般，递归变换成尾递归的关键就是寻找这个不变式，通过将不变式的计算在递归前完成就可以达实现尾递归。

比如下面三种不同的尾递归乘方算法：
;x^n => x*x*x...x 乘以n次， 不变式是x^(i+1) = x^i * x
(define (fast-exp-iter-v1 x n)
  (define depth 0)
  (define (iter x n r)
    (set! depth (+ depth 1))
    (cond ((= n 0) r)
          (else (iter x (- n 1) (* r x)))))
  (display (iter x n 1))
  (newline)
  (display depth)
  (newline))

;利用一个不变式是当n为2的整数倍时，x^n => x^2i => (x^2)^i => x^2*x^2*x^2...*x^2 乘以i次, 利用不变式x^2^(i+1) = x^2^i * x^2
(define (fast-exp-iter-v2 x n)
  (define depth 0)
  (define (iter x n r)
    (set! depth (+ depth 1))
    (cond ((= n 0) r)
          ((even? n) (iter (* x x) (/ n 2) r))
          (else (iter (* x x) (/ (- n 1 ) 2) (* r x)))))
  (display (iter x n 1))
  (newline)
  (display depth)
  (newline))

;该版本和上面的版本类似，只是在奇数倍时不变换。
(define (fast-exp-iter-v3 x n)
  (define depth 0)
  (define (iter x n r)
    (set! depth (+ depth 1))
    (cond ((= n 0) r)
          ((even? n) (iter (* x x) (/ n 2) r))
          (else (iter x (- n 1) (* r x)))))
  (display (iter x n 1))
  (newline)
  (display depth)
  (newline))

好好体会不变式的感觉，有助于编写更好的尾递归函数。

Jun 6, 2012 SBCL IR1对&optional, &rest, &key, &aux, special var的处理变换结果：

- 对于&optioanl, &rest, &key都是用optional-dispatch代替了原有的函数,(ir1-convert-hairy-args中完成)
  并生成了多个可接受不同参数个数的entry functional，比如

(lambda (a &optional b (c cd cs)) body)，生成的结果是:

	optional-dispatch: main, entries, more-entry
	main: (lambda (a b c cs) body)

	entry-optional1: (lambda (a b c)
	     	            (funcall
         	               (lambda (a b c cs) body)
		                  a b c t))

	entry-optional2: (lambda (a b)
			    (funcall
			       (lambda (a b c cs) body)
			          a b cd nil))

	entry-optional3: (lambda (a)
			     (funcall
			        (lambda (a b) body)
			           a nil))

  如果还有个&rest d参数，那么还会多一个more entry，并且，main entry也会随之被修改：
        main: (lambda (a b c cs &aux (keyword arg bindings) ...) body)
	
	entry-more: (lambda (a b c restcontext)
		       (loop-cond for analyzing keyword args and later
                          (funcall
			     (lambda (a b c cs &aux (keyword arg bindings) ...) body)
			        a b c t)))

- 对于&aux来说，其实它不是参数，而是额外的绑定，变换后成为一层一层的lambda和combination对(ir1-convert-aux-bindings中完成)

(lambda (a b &aux (c 1) (d 2)) body)，生成的结果是：

	(lambda (a b)
	   (funcall
	      (funcall
	         (lambda (c)
		    (lambda (d) body)) 
                 1)
	      2))

	
- 最后special var，会加入额外的cleanup code，并将其注册到当前的lexenv中：

(lambda (a b c) body),如果b为special var，那么变换后的结果是：

	(lambda (a b c)
		(%special-bind specvar-b b)
		(%cleanup-point)
		body)

Jun 7, 2012 On Lisp Notes
Chapter 2. Functions
--------------------------------------------------------------------------------
1. Common Lisp has distinct name-spaces for variables and functions. (P12)

2. A difference between lexical and dynamic scope comes down to how an
   implementation deals with free variables. (P16)

3. Closure are functions with local state. (P18)

4. A function which isn't tail-recursive can often be transformed into one
   that is by embedding in it a local function which uses an accumulator.
   In this context, an accumulator is a parameter representing the value
   computed so far. (P23)

5. However, calling compile explicitly is a drastic measure, comparable to
   calling eval, and should be viewed with the same suspicion. (P25)

6. There are two sorts of functions which you can't give as an argument to
   compile. ... , you can't compile a function "defined interpretively in
   a non-null lexical environment." ... . You also can't call compile on
   a function which is already compiled. ... "the consequences...are unspecified". (P25)

Chapter 3. Functional Programming
--------------------------------------------------------------------------------
1. Functional programming means writing programs which work
   by returnning values instead of by performing side-effects. (P28)

2. An imperative program is a functional program turned inside-out.
   An functional program is a imperative program turned outside-in. (P34)

3. Instead of treating all side-effects as equally bad, ... , we could
   say that it's harmless for a function to modify something that no
   one else own. 
   ...
   In the general case, we have to talk about ownership not by functions,
   but by invocations of functions. 
   ...
   The convension in Lisp seems to be that an invocation owns objects
   it receives as return values, but not objects passed to it as arguments.
   ...
   To write programs that are really indistinguishable from functional code,
   we have to add one more condition. Functions can't share objects with
   other code that doesn't follow the rules.
   ...
   A corollary of the convertion above is that functions shouldn't return
   anything that isn't safe to modify. Thus one should avoid writing functions
   whose return values incorporate quoted objects.

Chapter 4. Function Utilities
--------------------------------------------------------------------------------
1. Learning to write utilities would be better described as learning the habit of
   writing them, rather than the technique of writing them. (P41)

2. One of the unique characteristics of Lisp programming is the important role of
   functions as arguments. This is part of why Lisp is well-adapted to bottom-up
   programming. It's easier to abstract out the bones of a function when you can
   pass the flesh back as a functional argument. (P42)

3. If brevity is the soul of wit, it is also, along with the efficiency, the essence
   of good software. ... All other things being equal, the shorter program is the
   better. (P43)

4. a new utility must be written for the general case, not just for the problem at
   hand. Finally, like any capital expenditure, we need not be in a hurry about it. (P43)

5. In any language, the "tendency towards brevity" will cause trouble unless it is
   allowed to vent itself in new utilities. The shortest idioms are rarely the most
   efficient ones. ... it's especially important to write utilities for situations
   we might otherwise handle inefficiently. A language augmented with the right utilities
   will lead us to write more abstract programs. If these utilities are properly defined,
   it will also lead us to write more efficient ones. (P44)

6. So yes, reading a bottom-up program requires one to understand all the new operators
   defined by the author. But this will nearly always be less work than having to understand
   all the code that would have been required without them. 
   ...
   Bottom-up programming makes what would otherwise be a large program look like a small,
   simple one. This can give the impression that the program doesn't do much, and
   should therefore be easy to read. When inexperienced readers look closer and find
   that this isn't so, they react with dismay.
   ...
   Bottom-up programs are conceptually denser.(P60)

7. in a small program, a utility might not be used enough to justify including it. (P60)

Chapter 5. Returning Functions
--------------------------------------------------------------------------------
1. By defining functions to build and return new functions, we can magnify the effect
   of utilities which take functions as arguments. (P61)

2. Scheme was the first Lisp to make functions lexical closures, and it is this which
   makes it interesting to have functions as return values. (P62)

3. However, returning constant functions is the limit of what we can do with dynamic scope.
   ...
   Under lexical scope, instead of merely choosing among a group of constant functions,
   we can build new closures at runtime. With dynamic scope this technique is impossible. (P61-62)

4. Being able to pass functions as arguments is a powerful tool for abstraction.
   The ability to write functions which return functions allows us to make the most
   of it. (P62)

5. An orthogonal language is one in which you can express a lot by combining a small
   number of operators in a lot of different ways. (P63)

   "e.g. complement to *-if-not functions, setf to reading/writing datas"

6. If some function is expensive to compute, and we expect sometimes to make the
   same call more than once, then it pays to memorize: to cache the return values
   of all the previous calls, and each time the funciton is about to be called, to
   look first in the cache to see if the value is already known. (P65)
   
7. The complement of a function f is denoted ~f. Another Common operation on functions
   is composition, denoted by the operator o.
   ...
   All the functions given as arguments to compose must be functions of one argument,
   except the last. (P66)

8. Expressing functions by calls to constructors instead of sharp-quoted lambda-expressions could,
   unfortunately, entail unnecessary work at runtime. ...
   By using #., the sharp-dot read macro, we can have the new functions built at read-time. (P75)

Chapter 6. Functions as Representation
--------------------------------------------------------------------------------
1. Generally, data structures are used to represent. ... In Lisp we can sometimes
   use closures as a representation. With a closure, variable bindings can store
   information and can also play the role that pointers play in constructing complex
   data structures. By making a group of closures wich share bindings, or can refer
   to one another, we can create hybrid objects which combine the advantage of data
   structures and programs.
   Beneath the surface, shared bindings are pointers. Closures just bring us the 
   convenience of dealing with them at a higher level of abstraction. ... we can often 
   expect substantial improvements in elegance and efficiency. (P76)

2. Closures have three useful properties: they are active, they have local state, and
   we can make multiple instances of them. (P76)

3. Many programs involving networks can be implemented by compiling the nodes into
   closures. Closures are data objects, and they can be used to represent things just
   as structures can. Doing so requires some unconventional thinking, but the rewards
   are faster and more elegant programs. 
   Macros help substantially when we use closures as representations. "To represent
   with closures" is another way of saying "to compile," and since macros do their work
   at compile-time, they are a natural vehicle for this technique. (P81)


Sightworthy code
--------------------------------------------------------------------------------
1. defun same as setf symbol-function

(defun frob () ...) = (setf (symbol-function 'frob) (lambda () ...))

2. compiled defun same as compile

(defun frob () ...) = (compile 'frob (lambda () ...))

3. Utilities

   a. Operation on Lisst
      
      (defun last-car (lst)
		(car (last lst)))

      (defun singleton (lst)
		(and (consp lst) (null (cdr lst))))

      (defun appendr (lst obj)
		(append lst (list obj)))
					
      (defun nconcr (lst obj)
		(nconc lst (list obj)))

      (defun ensure-list (obj)
		(if (listp obj) obj (list obj)))

      (defun longer (x y)
		(labels ((compare (x y)
			   (and (consp x)
				(or (null y)
				    (compare (cdr x) (cdr y))))))
		  (if (and (listp x) (listp y))
		      (compare x y)
		      (> (length x) (length y)))))

      (defun filter (fn lst)
		(let ((acc nil))
		  (dolist (x lst)
		    (let ((val (funcall fn x)))
		      (if val 
			  (push val acc))))
		  (nreverse acc)))		      

      (defun group (source n)
		(if (zerop n) (error "zero length"))
		(labels ((rec (source acc)
			   (let ((rest (nthcdr n source)))
			     (if (consp rest)
				 (rec rest (cons (subseq source 0 n) acc))
				 (nreverse (cons source acc))))))
		  (and source (rec source nil))))

      (defun flatten (x)
		(labels ((rec (x acc)
			   (cond ((null x) acc)
				 ((atom x) (cons x acc))
				 (t (rec (car x) (rec (cdr x) acc))))))
		  (rec x nil)))

      (defun prune (test tree)
		(labels ((rec (tree acc)
			   (cond ((null tree) (nreverse acc))
				 ((consp (car tree)) (rec (cdr tree)
							  (cons (rec (car tree) nil) acc)))
				 (t (rec (cdr tree) (if (funcall test (car tree))
							acc
							(cons (car tree) acc)))))))
		  (rec tree nil)))

   
   b. Search
   
      (defun find2 (fn lst)
		(if (null lst)
		    nil
		    (let ((val (funcall fn (car lst))))
		      (if val
			  (values (car lst) val)
			  (find2 fn (cdr lst))))))   
      
      (defun before (x y lst &key (test #'eql))
		(and lst
		     (let ((first (car lst)))
		       (cond ((funcall test y first) nil)
			     ((funcall test x first) lst)
			     (t (before x y (cdr lst) :test test))))))
      
      (defun after (x y lst &key (test #'eql))
		(let ((rest (before y x lst :test test)))
		  (and rest (member x rest :test test))))

      (defun duplicate (obj lst &key (test #'eql))
		(member obj (cdr (member obj lst :test test)) :test test))


      (defun split-if (fn lst)
		(let ((acc nil))
		  (do ((src lst (cdr src)))
		      ((or (null src) (funcall fn (car src)))
		       (values (nreverse acc) src))
		    (push (car src) acc))))


      (defun most (fn lst)
		(if (null lst)
		    (values nil nil)
		    (let* ((win (car lst))
			   (max (funcall fn win)))
		      (dolist (obj (cdr lst))
			(let ((score (funcall fn obj)))
			  (when (> score max)
			    (setq win obj
				  max score))))
		      (values win max))))

      (defun best (fn lst)
		(if (null lst)
		    nil
		    (let* ((win (car lst)))
		      (dolist (obj (cdr lst))
			(if (funcall fn obj win)
			    (setq win obj)))
		      win)))

   c. Mapping

      (defun map0-n (fn n)
             (mapa-b fn 0 n))

      (defun mapa-b (fn a b &optional (step 1))
             (do ((i a (+ i step))
                  (restul nil))
                 ((> i b) (nreverse result))
                 (push (funcall fn i) result)))

      (defun map-> (fn start test-fn succ-fn)
             (do ((i start (funcall succ-fn i))
	          (result nil))
                 ((funcall test-fn i) (nreverse result))
                 (push (funcall fn i) result)))

      (defun mappand (fn &rest lsts)
             (apply #'append (apply #'mapcar fn lsts)))

      (defun rmapcar (fn &rest args)
             (if (some #'atom args)
                 (apply fn args)
                 (apply #'mapcar
                        #'(lambda (&rest args)
                             (apply #'rmapcar fn args))
                        args)))

   d. I/O

      (defun prompt (&rest args)
            (apply #'format *query-io* args)
            (read *query-io*))

   e. Symbols and Strings

      (defun mkstr (&rest args)
        (with-output-to-string (s)
           (dolist (obj args) (princ obj s))))

      (defun symb (&rest args)
        (values (intern (apply #'mkstr args))))

      (defun reread (&rest args)
        (values (read-from-string (apply #'mkstr args))))

4. Unify destructuring and non-destructuring interface (better orthogonality)
   Utilities:
   (defvar *!equivs* (make-hash-table))
   (defun ! (fn)
   	  (or (gethash fn *!equivs*) fn))
   (defun def! (fn fn!)
          (setf (gethash fn *!equivs*) fn!))

   Usage Code:	  
   (def! #'remove-if #'delete-if)
   (funcall (! #'remove-if) #'oddp lst)
   
5. Memoizing results
   (defun memoize (fn)
      (let ((cache (make-hash-table :test #'equal)))
         #'(lambda (&rest args)
              (multiple-value-bind (val win) (gethash args cache)
                 (if win
                     val
                     (setf (gethash args cache)
		           (apply fn args)))))))

6. Composing functions
   (defun compose (&rest fns)
   	  (if fns
	      (let ((fn1 (car (last fns)))
	      	    (fns (butlast fns)))
		    #'(lambda (&rest args)
		          (reduce #'funcall fns
			          :from-end t
                                  :initial-value (apply fn1 args))))
              #'identity))

    (defun complement (pred)
          (compose #'not pred))

    (defun fif (if then &optional else)
          #'(lambda (x)
               (if (funcall if x)
                   (funcall then x)
                   (if else (funcall else x)))))

    (defun fint (fn &rest fns)
          (if (null fns)
              fn
              (let ((chain (apply #'fint fns)))
                 #'(lambda (x)
                      (and (funcall fn x) (funcall chain x))))))

    (defun fun (fn & rest fns)
          (if (null fns)
              fn
              (let ((chain (apply #'fun fns)))
                 #'(lambda (x)
                      (or (funcall fn x)  (funcall chain x))))))

7. Recurser
   (defun trec (rec &optional (base #'identity))
          (labels ((self (tree)
                     (if (atom tree)
                         (if (functionp base) 
                             (funcall base tree)
                             base)
                         (funcall rec tree #'(lambda () (self (car tree)))
                                           #'(lambda () (if (cdr tree) (self (cdr tree))))))))
                  #'self))

8. Compiling networks

   (defvar *nodes* nil)
   (defun defnode (&rest args)
   	  (push args *nodes*)
	  args)
   (defun compile-net (root)
          (let ((node (assoc root *nodes)))
	       (if (null node)
	           nil
                   (let ((conts (second node))
		         (yes (third node))
			 (no (fourth node)))
			(if yes ; 
			    (let ((yes-fn (compile-net yes))
                                  (no-fn (compile-net no)))
                                #'(lambda ()
                                      (format t "~a~%>>" conts)
                                      (funcall (if (eq (read) 'yes)
                                                   yes-fn
                                                   no-fn))))
                            #'(lambda () conts))))))

  
  Usage code:
  (defnode 'people "Is the person a man?" 'male 'female)
  (defnode 'male "Is he living?" 'liveman 'deadman)
  ...

Jun 7, 2012 TLS & TSS Notes
The Little Schemer
--------------------------------------------------------------------------------
The First Commandment (P22)
    (preliminary)
    Always ask null? as the first question in epxressing any function.

The Second Commandment (P37)
    Use cons to build lists.

The Third Commandment (P45)
    When building a list, describe the first typical element,
    and then cons it onto the natural recursion.

The Fourth Commandment (P57)
    (priliminary)
    Always change at least one argument while recurring. It
    must be changed to be closer to termination. The changing
    argument must be tested in the termination condition:
    when using cdr, test termination with null?

The First Commandment (P64)
    (first revision)
    When recurring on a list of atoms, lat, ask two questions about it:
    (null? lat) and else.
    When recurring on a number, n, ask two questions about it:
    (zero? n) and else.

The Fourth Commandment (P65)
    (first revision)
    Always change at least onw argument while recurring. It must be changed to 
    be closer to termination. The changing argument must be tested in termination
    condition:
    when using cdr, test termination with null? and
    when using sub1, test termination with zero?.

The Fifth Commandment (P67)
    When building a value with +, always use 0 for the value of the terminating line, 
    for adding 0 does not change the value of an addition.    
    When building a value with *, always use 1 for the value of the terminating line,
    for multiplying by 1 does not change the value of a multiplication.
    When building a value with cons, always consider () for the value of terminating line.

The First Commandment (P83)
    (final revision)
    When recurring on a list of atoms, lat, ask two questions about it:
    (null? lat) and else.
    When recurring on a number, n, ask two questions about it:
    (zero? n) and else.
    When recurring on a list of S-expressions, l, ask three question about it:
    (null? l), (atom? (car l)) and else.

The Fourth Commandment (P84)
    (final revision)
    Always change at least one argument while recurring. When recurring on a list of atoms,
    lat, use (cdr lat). When recurring on a number, n, use (sub1 n). And when recurring on
    a list of S-expressions, l, use (car l) and (cdr l) if neither (null? l) nor (atom? (car l))
    are true.
    It must be changed to be closer to termination. The changing argument must be tested in
    the termination condition.
    when using cdr, test termination with null? and
    when using sub1, test termination with zero?.

The Sixth Commandment (P93)
    Simplify only after the function is correct.

The Seventh Commandment (P103)
    Recur on the subparts that area of the same nature:
    - On the sublists of a list.
    - On the subexpression of an arithmetic expression.

The Eighth Commandment (P107)
    Use help functions to abstract from representations.

The Ninth Commandment (P133)
    Abstract common patterns with a new function.

The Tenth Commandment (P140)
    Build functions to collect more than one value at a time.
    
The Seasoned Schemer
--------------------------------------------------------------------------------
The Eleventh Commandment (P11)
    Use additional arguments when a function needs to know what other arguments to the
    function have been like so far.

The Twelfth Commandment (P22)
    Use (letrec ...) to remove arguments that do not change for
    recursive applications.

The Thirteenth Commandment (P31)
    Use (letrec ...) to hide and to protect functions.

The Fourteenth Commandment (P44)
    Use (letcc ...) to return values abruptly and promptly.

The Fifteenth Commandment (P69)
    (priliminary version)
    Use (let ...) to name the values of repeated expressions.

The Fifteenth Commandment (P74)
    (revised version)
    Use (let ...) to name the values of repeated expressions in a function definition
    if they may be evaluated twice for one and the same use of the function.

The Sixteenth Commandment (P98)
    Use (set! ...) only with names defined in (let ...)s.

The Eighteenth Commandment (P104)
    Use (set! x ...) only when the value that x refers to is no longer needed.

The Nineteenth Commandment (P112)
    Use (set! ...) to remember valuable things between two distinct uses of a function.

The Twentieth Commandment (P160)
    When thinking about a value created with (letcc ...), write down the function
    that is equivalent but does not forget. Then, when you use it, remember to forget.

Sightworthy code
--------------------------------------------------------------------------------
1. 3x+1 problem

(define 3x+1
  (lambda (n)
    (letrec ((C (lambda (n d)
                  (cond
                    ((= n 1) 
                     (displayln d)
                     'convergent)
                    (else
                     (cond
                       ((even? n) (C (/ n 2) (add1 d)))
                       (else (C (add1 (* 3 n)) (add1 d)))))))))
      (C n 0))))

2. Ackermann Function

(define ackermann
  (lambda (n m)
    (cond
      ((zero? n) (add1 m))
      ((zero? m) (ackermann (sub1 n) 1))
      (else
       (ackermann (sub1 n)
                  (ackermann n (sub1 m)))))))

3. Tail recursion with collector

(define copy-tree-nt
  (lambda (tree)
    (cond ((null? tree) tree)
          ((not (or (pair? (car tree))
                    (null? (car tree))))
           (cons (car tree) (copy-tree-nt (cdr tree))))
          (else
           (cons (copy-tree-nt (car tree))
                 (copy-tree-nt (cdr tree)))))))

(define copy-tree
  (lambda (tree)
    (letrec ((cp (lambda (t col)
                   (cond ((null? t) (col t))
                         ((not (or (pair? (car t))
                                   (null? (car t))))
                          (cp (cdr t)
                              (lambda (st)
                                (col (cons (car t) st)))))
                         (else
                          (cp (car t)
                              (lambda (a-st)
                                (cp (cdr t)
                                    (lambda (d-st)
                                      (col (cons a-st d-st)))))))))))
      (cp tree identity))))

4. Halting problem

(define will-stop?
  (lambda (proc)
    ...))

(define eternity
  (lambda (x)
    (eternity x)))

(define last-try
  (lambda (x)
    (and (will-stop? last-try)
         (eternity x))))

5. Applicative-order Y-combinator

(define Y
  (lambda (one-step)
    ((lambda (f) (f f))
     (lambda (f)
       (one-step (lambda (x) ((f f) x)))))))

(define length-one-step
  (lambda (length)
    (lambda (l)
      (cond ((null? l) 0)
            (else (add1 (length (cdr l))))))))

(define length (Y length-one-step))

6. Functional cons

- immutable cons

(define cons
  (lambda (car cdr)
    (lambda (selector)
      (selector car cdr))))

(define car
  (lambda (cons)
    (cons (lambda (car cdr) car))))

(define cdr
  (lambda (cons)
    (cons (lambda (car cdr) cdr))))

- mutable cons

(define cons-car-on-empty
  (lambda (car)
    (let ((cdr empty))
      (lambda (selector)
        (selector (lambda (new-cdr) (set! cdr new-cdr)) car cdr)))))

(define set-cdr!
  (lambda (cons new-cdr)
    ((cons (lambda (set-cdr! car cdr) set-cdr!)) new-cdr)))

(define cons
  (lambda (car cdr)
    (let ((cons (cons-car-on-empty car)))
      (set-cdr! cons cdr)
      cons)))

(define car
  (lambda (cons)
    (cons (lambda (set-cdr! car cdr) car))))

(define cdr
  (lambda (cons)
    (cons (lambda (set-cdr! car cdr) cdr))))

Jun 13, 2012 Git plumbing commands
- Git main structure
  .git/objects for 3 Objects: Blob, Tree, Commit
  .git/refs for 3 Refs: head, tag, remote           (reference to commit object or other refs)
  .git/HEAD for symbolic reference to .git/refs/heads/master
  .git/index for staging area
  .git/hooks for hook scripts
  .git/config for local config
  .git/info for keep ignored files and packfiles
  .git/pack-refs packed refs
  .git/log	 storing reflogs information, if delete, git reflog will show nothing.
  .git/refs/remotes/origin/ the refs here is the same as the refs in remote's .git/refs/heads/  see refspec

- Plumbing commands
echo <content> | git hash-object -w --stdin    Store plan blob object
git cat-file -p <objects' SHA-1>               View object content
git cat-file -p master^{tree}                  View tree object last commit object pointint to
git cat-file -t <objects' SHA-1>	       View object type
git update-index --add <file>		       Add new file to staging area
git update-index --add --cacheinfo <100644|120000|100755> <SHA-1> <file>  Add blob to staging area
git write-tree	       		   	       Write staging area to a tree object
git read-tree <tree SHA-1>		       Read a tree to staging area
echo "commit msg" | git commit-tree <tree SHA-1> Create a commit object pointing to specified tree
git update-refs <refs/path> <commit SHA-1>	 Create a refs to a commit
git symbolic-ref <refs path>	    		 Find the target of the symbolic reference
git gc --auto	       				 Collect loose objects and make packfiles
git verify-pack -v <path/to/packfile>		 Look into packed objects in a packfile
git reflog	   				 HEAD change history, useful when recover some lost commit or HEAD
git log -g					 like git reflog but more information
git fsck --full					 show dangling commit, useful when reflog has nothing to tell you.
git count-objects				 count size and objects
git rev-list --objects				 list all chronological commits and its related files
git filter-branch --index-filter "filter commands" -- <commit SHA>^..  do filter on each commit since specified one.
git rev-parse	  		 	 	 show the commit the ref pointing to
git ls-tree <treeish>				 list content of tree

- refspecs
  format [+]<remote's refs/heads/>:<local's refs/remotes/origin/>
  + is optional and refers to forcibly fetch even non-fastforward.
  
git fetch origin <refspecs> [\ <refspecs]...    Fetch remotes according to refspecs
git push origin <refspecs>     			Push to remotes according to refspecs
git push origin :<remote refs>			Delete remotes' refs

Jun 13, 2012 Git　常用命令和revision selection
git clean -ffxd 删除目录中没有track的文件，包括ignored那些
rm -rf * && git reset --hard  清空工作目录并重新从repo中取得HEAD
git archive --format=tar <refs>:<tree path> 对某个ref的某个目录下的文件打包
git blame 查看每一行代码都是谁改的
git branch --merged 查看已经合并过的分支，可以删除它了意味着。
git show <object>   显示对象

版本指定
revision 可以是 commit或者ref
revision^ 显示早它前一个的revision的第一个parent
revision^2 早它前一个的revision的第二个parent
revision~ 显示早它前一个的revision的第一个parent
revision~3 显示早它前三个的revision的第一个parent
ref@{<time> or <order>} 显示引用日志中的引用以前的历史，这对于HEAD来说比较有用。

提交范围
refa..refb 所有在refb中，但不在refa中的提交
^refa 所有不在refa中的提交
refa...refb 被两者包含，都又不都在两者中的提交