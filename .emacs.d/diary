Aug 20, 2010 Swap Caps Lock and left Ctrl under X11
1. edit .xmodmap under your home dir; add:
remove Lock = Caps_Lock
remove Control = Control_L
keysym Control_L = Caps_Lock
keysym Caps_Lock = Control_L
add Lock = Caps_Lock
add Control = Control_L

2. edit /etc/rc.local; add:
xmodmap ~/.xmodmap 2 > /dev/null

Aug 21, 2010 Rule For Software Tool
1. Only Do One Thing At A Time
2. Process Text Not Binary
3. Use Regular Expression(Posix Support Two Form: Bre And Ere)
4. Use Standard Output/Input As Default
5. Don'T Bothering(No Need Interaction)
6. Make Output Format Consistent With Required Input Format
7. Let Tool To Do The Most Difficult Thing
8. Before Create Specialized Tool, Think More

Aug 25, 2010 Emacs Basics
Emacs Regex Function
      (string-match REGEXP STRING &optional START)
      (match-string NUM &optional STRING)
      (match-end SUBEXP)
      (match-beginning SUBEXP)
Emacs Hook Function
      (add-hook HOOK FUNCTION &optional APPEND LOCAL)
      (run-hooks &rest HOOKS)
      (run-hook-with-args HOOK &rest ARGS)
Emacs Compile Function
      (compile COMMAND &optional COMINT)

Aug 30, 2010 Shell Programming - trap, pid, and print format
1. trap
   fmt: trap "cmd" signal.
   meaning: trap a signal and run the cmd
2. process variable
   $$ variable is process id
3. printf
   %-39s means left-aligning, 39 fixed char length

Aug 31, 2010 Shell Programming - embeded document
1. embedded document
   fmt: use << and EOFILE
   meaning: in a shell script to insert document with variable substitution
2. word dict
   /usr/share/dict/
   /usr/dict/
   /usr/share/lib/dict/
   /usr/local/share/dict

Mar 10, 2011 CUPS debugging technique
1. Attach filter process
   sleep filter until you can attach from gdb
2. Send print result to a file
   1). listen on a local port, "nc -l -p 20000 > filename"
   2). set printer's device uri to this local port, "socket://localhost:20000"
   3). print
3. Use FileDevice URI
   enable FileDevice in /etc/cups/cups.config

Mar 15, 2011 Network Port Range
IANA divides port numbers into three ranges:
0~1023       for common, well-known services, 3FF, On Unix-like operating system, require superuser
1024~49151   for IANA registered services, BFFF
49152~65535  for services not officially designated, such as ephemeral ports, FFFF

Mar 16, 2011 Pipeline subshell: Bash vs Ksh
When doing pipelines, ksh will run each pipeline in current process,
in contrary, bash will run each pipeline in a subshell environment.

This difference direct consequnce is when setting some variable in a pipeline in bash,
it may not reflect the value in the parent scripts.

e.g.
------------------------------------------------
echo "bla bla bla.." | while read one two three
do
    result=$one $two $three
done

echo $result
------------------------------------------------

in ksh, you got bla bla bla..
in bash, you got nothing

Mar 21, 2011 Robotics simulation toolkits
Open Sourced:
ODE, Open Dynamics Engine, written in C++, an open source physics engine, LGPLed or BSD, industrial-quality
Simbad robot simulator, written in Java, featured with an visulization console, GPLed
Teambots, portable multi-agent robotic simulator
Carmen, Carnegie Mellon Robot Navigation Toolkit

Commercial:
Khepera

Jun 8, 2011  Git 断点续传
通过git init && git fetch <url>可以实现git下载的断点续传(反馈：尝试了，貌似不能！)
git clone不具备这个功能

Jul 25, 2011 SBCL build process
cross compiling phase:
make-host-1  ---->  make-target-1

target system compiling phase:
make-host-2 ----> make-genesis-2  ----> make-target-2

Jul 26, 2011 Git (v1.6.6 above) SMART HTTP PROXY
1. use http_proxy environment variables and http as the clone protocol
2. use GIT_CURL_VERBOSE to output verbose information

Jul 27, 2011 SSH 通过公私钥代替密码登录认证
1. 在.ssh/config文件中，通过IdentityFile使得ssh客户端能够自动选择与登录服务端相匹配的密钥
如：
IdentityFile ~/.ssh/ids/%h/id_rsa
IdentityFile ~/.ssh/id_rsa
2. 创建目录，将私钥按照主机或者用户进行分类存放
3. 在服务器端，.ssh/authorized_keys文件中，每一行记录一个允许通过公私钥登录的客户端对应的公钥

Jul 27, 2011 SSH 常见用法
1. 创建隧道
ssh -N -L2011:localhost:80 somemachine 创建从本地2011到远端80端口的隧道, localhost部分其实指的是服务端
ssh -N -R2011:localhost:80 somemachine 创建从远端2011端口到本地80端口的隧道, localhost指的是本地客户端
可以用nc来进行测试，如：
nc -l -p 80 在某一端监听
nc localhost 2011 发送消息到隧道里

2. 比较远程和本地文件
ssh user@remote cat /path/to/somefile1 | diff /path/to/somefile2 -

3. 将远程的内容复制到粘帖版
ssh user@remote cat /path/to/somefile | xclip

Jul 27, 2011 DBUS的概念
DBUS称为消息总线，分为系统总线和会话总线。
用于实现进程间的1对1通信，连接到总线上的进程通过提供服务和获取服务来交换信息。
服务连接有一个BUS全局名称，而每个连接都有个唯一私有名称，
通过全局名称琐定服务后，指定服务的对象，接口，以及方法来进行信息获取。
dbus-send和dbus-monitor是两个实用的调试工具

Jul 29, 2011 CRON计划任务之at
通过at命令可以进行简单的计划任务
1. at now+1minutes -f <command>
2. at -t "MMDDmmss" -f <command>
如果没有f指定作业文件，则从标准输入中读取

Jul 29, 2011 DBUS的Session地址
在dbus-send的参数里除了--system和--session还有一个--address
这个参数没有很好的文档说明，它实际上就是dbus进行消息传递的文件的地址(socket方式)
另外，还有一个环境变量叫做DBUS_SESSION_BUS_ADDRESS是表示当前session的dbus的地址

最后通过dbus-daemon --print-address也可以显示当前开启的dbus对应的地址

有关session bus address的信息其实存放在~/.dbus/session-bus/$(dbus-uuidgen --get)-[$HOST]-$(DISPLAY)
这个文件里面。

发现一个奇怪的现象，
通过ssh remote dbus-send --sesion ..bla.bla.bla的方式
在ubuntu9.10上返回一个错误，提示说session dbus是null的，
这是由于在ssh运行dbus-send的时候，环境变量可能还没有准备好，
因此，可以通过读取上面的文件来获取dbus

Jul 29, 2011 GIT获取revision和commit信息的相关的命令
git log 获取commit的log信息，通过-p -2可以对最近两个版本进行比较， --since与--until可以对日期进行过滤
git rev-list 获取从某个commit回溯可以到达的revisions的历史列表， 通过--not可以指定过滤显示到达不了的那些历史列表
git rev-parse 显示一个commit的全局唯一哈希码, --short可以仅显示部分这个码
git describe 显示一个revision的tag名，可以是轻量级的，使用--tags, --all, --dirty可以显示各种不同级别的tag, 一般情况下显示离当前签入的commit最近的过去时间中的revision， 如果使用--contain则显示最近的未来时间的revision, --abbrev=0使用短格式显示revision tag

Aug 3, 2011 Send message to users on unix
command:
wall       send all user a message
mesg       disable/enable message receiving
write user [tty]  send a message to a user

Aug 4, 2011 Echo KnowHow
Echo has two options very useful
-n  stop output trailing newline
-e  enable escape character

e.g. echo -ne '\032\032'

Aug 19, 2011 X开发中 Display的指定
OpenDisplay的时候，
host为空的情况，会打开本地默认的0号display，
不管是否指定display，也不管本地默认Xserver是否监听网络，还是限制访问
host为localhost或者本机ip的时候，需要指定display,
并可以在指定display上显示，但前提是该display上的Xserver监听网络，并且无网络限制。


Aug 27, 2011 Emacs Tramp for SSH
C-x C-f and then type /ssh:<user>@<host>:<files>
it can open remote files by ssh.

Nov 16, 2011 LINUX GIT
最近的一些经验：
1. dd_rescue 可以用来从坏扇区恢复一些数据

2. 在1.7以后git可以通过ssl代替ssh推送数据，具体的是在url中指定用户名，git会询问passwd
   如 ：git clone https://myname@github.com/XXX/XXX.git
   这样就等同于使用ssh，可以进行推送了。

3. 使用https协议穿过代理的时候，可以设定http.proxy, http.sslCAInfo, http.sslCAPath等变量
   后两个是指定认证根文件，和目录的所在位置

4. 可以使用--track在本地创建一个跟踪本地upstream的分支，以使用pull，这默认只对远程分支有用
   使用git branch -vv，两个v可以看到upstream

5. 当使用--amend重新commit的时候，切记仅在本地操作，如果已经推送到远程源，那么只能在push的时候--force
   但是这样实际改变了之前的commit

Nov 22, 2011 SBCL
SBCL中关于IR2之后的一些文件
system.lisp定义了一些vop操作, 用于访问vm层的对象和信息
objdef.lisp中定义了在vm层中支持的原生C结构的对象
meta-vmdef.lisp定义了vm.lisp中用于定义SB,SC的操作
vm.lisp定义了SB,SC具体有哪些内容
vop.lisp定义了IR2转换时候的结构对象，SB, SC, TN, Template, VOP-Info等对象结构
assem.lisp和insts.lisp定义了80x86指令结构，具体的操作指令inst，以及对应的op code等信息

一些碰到的名词
Storage Base, Storage Class, Temporary Name, Template, TN-Ref, Effective Address
Virtual Operation, Primitive types, Instruction
emitter, printer, prefilter, generator

Nov 24, 2011 SBCL
在SBCL中定义新的VOP的方法
在SB-VM包中，
首先调用defknown声明该VOP是一个已知的操作
通过define-vop定义新的操作，然后通过defun定义上层函数

如：
声明我的VOP接受一个系统区域指针，返回一个系统区域指针
(defknown myvop (system-area-pointer) system-area-pointer (flushable movable))
定义我的操作，意思是接受线程的系统区域指针，并且返回它 (相当没意义的操作)
(define-vop (myvop)
	 (:args (thread :scs (sap-reg) :target int))
	 (:arg-types system-area-pointer)
	 (:results (int :scs (sap-reg)))
	 (:result-types system-area-pointer)
	 (:translate myvop)
	 (:policy :fast-safe)
	 (:generator 1
		     (move int thread)))
声明高层函数
(defun myvop (thread)
	     (myvop thread))

不明白的是什么是flushable, movable, foldable属性？

Nov 24, 2011 SBCL
SAP相关操作
可以通过SAP-REF-*之类的，来读取某个SAP指针偏移处的内存的内容
另外，对于在C空间中的变量，可以通过alien-sap和extern-alien
来获取它的地址， extern-alien对于类型的要求可以在sb-alien包
中找到，或者使用(* t)，另外还支持对函数的获取，指定函数类型

如对于函数：
(extern-alien "getcwd" (function (* char) (* char) size-t))
如对于变量：
(alien-sap (extern-alien "all_threads"  (* t)))

Nov 28, 2011 SBCL
SBCL编译器叫做Python compiler(和python语言可没关系哦)
编译分为两个阶段phase，分别处理两种不同的中间语言IR:
IR1 (Implicit Continuation Representation)
IR2 (Virtual Machine Representation)

编译器前端frontend主要负责IR1变换，后端backend则负责IR2变换
ICR相当于一个CL的子集，以流程图flow graph的形式描述被编译代码的语法\语义
VMR则是一些虚拟机操作码 (不同体系的汇编)的模板，将代码翻译成虚拟机的语言

================================================================
具体的语言变换过程：

     IR1                    IR2
  /------\    /--------------------------------\
 / 	  \  /   			        \
CL -> ICR -> VMR -> assembly instruction -> OP code

IR1 phase
1. ICR conversion - 进行宏展开和代码到代码的变换，将被编译代码转换为ICR形式 （解决命名冲突问题） - ir1tran, srctran, typetran
2. Local call analysis - 寻找对本地函数的调用，分析关键字参数，将仅调用一次的函数识别为let，创建XEP - locall
3. Find components - 寻找flow graph中的组块component，区分top level和run time代码，确定top level的components - dfo
4. ICR optimization - ir1opt, ir1tran, typetran, seqtran, vm/vm-tran
5. Type constraint propagation - 使用global flow analysis传播lexical 变量的类型信息，取消不必要的类型检查 - constraint
6. Type check generation - 对在后端中比较难检查的类型，产生检查这些类型的ICR代码 - checkgen
7. Event driven operation - 重新计算一些ICR部分 - ir1util, ir1opt
8. ICR finalize - 在所有components都被编译后，寻找全局变量引用中的未定义的变量和不兼容的函数定义 - ir1final, main
9. Environment analysis - 分析需要创建的不同环境以及其上下文， 探测非本地退出以及设置闭包变量 - envanal

IR2 phase
10. Global TN allocation - 遍历所有定义的函数，确定调用规约，给本地变量分配TN - gtn
11. Local TN allocation - 根据类型和policy决定对已知函数使用什么VMR翻译，创建表达式评估时需要的TN - ltn
12. Control analysis - 线性化flow graph，尽量减少其分支。block级的flow graph在这确定下来。 -  control
13. Stack analysis - 针对unknown-values continuation维护堆栈？ - stack
14. Entry analysis - 搜集外部函数调用的信息
15. VMR conversion - 通过将flow graph中的节点转换为VOP将ICR转换为VMR - ir2tran, vmdef
16. Copy propagation - 通过flow analysis删除不需要的TN
17. Representation selection - 根据对TN的引用，确定哪个表示的cost最低。选择相应的VOP
18. Lifetime analysis - 通过flow analysis找到生命期重叠的TN的集合，标注那些需要存储TN的VOP调用 - life
19. Pack - 寻找合适的寄存器分配 - pack
20. Code generation - 调用VOP产生器生成代码 - codegen
21. Pipeline reorganization - assem-opt
22. Assembly - 解决分支，转化为object code以及fixup信息 - assembler
23. Dump - 将编译后的内容输出到object file或者in-core函数 - debug-dump, dump, vm/core
=================================================================

Nov 28, 2011 Compiler, SBCL
- Peephole optimization的意思是针对一段产生的代码中的一小部分指令进行优化，这一小部分指令常称为peephole。
  通常优化是指，识别无效的指令以及选择轻量级的等价指令。

- Partial evaluation是一种在编译期将常量表达式替换掉constant folding的优化方法，该方法不仅优化完整的常量表达式，还根据
  任何代码（表达式）中常量部分对这部分代码整体进行优化，主要表现为常量（值，函数都可）替换，无用表达式的删除，常量条件分支删除等

- Inline expansion是指函数在调用处展开为代码的优化。

- Meta-programming是指通过开发一种语言的特定领域扩展 Domain-specific extension来编程的方法。 (我猜lisp里就是特别指macro编程了吧，反馈：macro是其中一种机制)

- Block compilation就是在假定全局函数global function不会重定义的情况下，优化掉函数边界。把defuned的函数编译成如flet, labels定义的
  函数块。该优化可以将函数调用转化为本地jump跳转，取消参数检查。另外，也将partial evaluation和type inference的边界扩展到block而不是函数。

Nov 29, 2011 Compiler, Type system
- Type checking是检验类型规则限制的过程，可以发生在编译期，或者运行时。
  - Static typing静态类型，是指在编译器进行类型检查的类型，与之相关的类型检查错误是compile time type error。
  - Dynamic typing动态类型，是指在绝大多数类型检查在运行期间完成，与之相关的类型检查错误是runtime type error。
    动态类型中，一般变量是没有类型的，有类型的是值。
    - Duck typing是OO编程中，源于duck test的概念，即不管是什么对象，只要它走起来，叫起来，游起来像个鸭子，就叫它鸭子。
      是一种动态类型检查，即由当前对象的行为和属性来决定值语义，而不是继承。
  - Strong typing与weak typing是类型系统的另外一个纬度关注的问题。

- Type inference是一种编译期自动对表达式的类型进行部分或者完全推导的功能。编译器通过推导使得显示的类型声明type annotation可以省略掉。一般类型推导用于静态类型语言。

- Polymorpism是OO编程中，指同一个操作可以应用于多个类型的对象，或者同一个数据结构可以包含多个类型的元素。

Nov 29, 2011 SBCL调试
可以通过enable-debugger, disable-debugger, invoke-debugger显示的启用调试 (默认)，禁止调试，以及调用调试
另外通过(define-alien-routine ("ldb_monitor" ldb_monitor) void)定义一个调用low level debugger的函数
可以引起low level debugger.

Nov 29, 2011 Programming, Compiler, First Class
First Class Object

在程序语言中，如果一个对象支持以下内容，它就是一级的：
1. 能够存储到变量或数据结构中
2. 能够作为参数传递给子过程
3. 能够作为子过程的返回值
4. 能够在运行时创建
5. 具备intrinsic identity（唯一的标示？）

具体到特定的程序元素，有
first class function
first class value
first class continuation
first class data type

Dec 27, 2011 从用户的角度控制SBCL编译器
1. 控制编译时输出的信息Verbosity：
基础知识：
在SBCL中有四种编译时的检查输出compiler diagnostic severity: error, warning, style warning, note

前三种都对应的是ANSI CL标准中的condition, 意思是报告编译时发生了错误级别error severity的严重问题。
第四个note通常是编译器提示的一些提示信息hint, 如如何改善代码以达到期望的性能、编译器优化掉的无用代码信息等。

note从condition继承，基类为sb-ext::compiler-note，其中有个子类是code-deletion-note。

对于输出，一般分为6个部分
1. file: 标示错误所在的文件
2. in: 标示错误发生的top level的definition或者form
3. 之后缩进两格的是错误发生的最直接的form的原始代码（未经过宏展开和代码变换的）
   注：这个信息里form是包含错误的最小的form，所以错误只会发生在这个form上，而不会发生在其包含的form中。
4. --> 处理路径processing path， 显示在编译过程中，进行宏展开的每步的动作，该行中的每一个单词是展开一次的最外层的头一个form
5. ==> 展开后的实际出错的代码
6. 错误的类型和错误信息

方法：
a. 通过在declare或者declaim中使用muffle-condition/unmuffle-condition来声明屏蔽输出哪些编译的diagnostics检查
b. 通过修改*compiler-print-variable-alist*来绑定一些*print-xxx*变量来控制编译时的输出
----------------------------------------------------------------------
2. 控制类型检查
默认的情况下，SBCL并不盲目相信声明的类型declared types，而是把他们当成需要在运行期检查的assertions（但因为一些原因，这个规则是有出入的）, 对这些类型声明，将使用如同typep一样的严格精准的检查策略，如果一个对象有多个类型声明，那么每个都必须符合。

类型检查有三类，
全类型检查Full Type Checks, 条件：当优化级别safety>=2 或 safety>=speed>=1时（默认的方式）
弱类型检查Weak Type Checks（简化为检查更宽泛的类型限制）, 条件：当优化级别safety<2并且safety<speed时
无检查No Type Checks, 条件：safety=0
----------------------------------------------------------------------
3. 控制编译器策略
知识：
使用optimize优化声明，可以控制ANSI CL标准定义的四种不同的优化策略：safety, speed, space, debug
通常speed优化策略过高时，编译器会提示用户一些它无法进行的优化提示，以告知修改代码来实现期望的优化。
通常space优化策略影响内联函数的展开，将会增大编译后的代码大小。小心使用space=0，因为编译器会不分情况的进行内联，可能减慢程序执行速度。

方法：
1. 通过declare\declaim声明优化策略
2. 通过declare-compiler-policy输出当前上下文的优化策略
3. 通过restrict-compiler-policy限定指定的策略类型的最小级别。 如果没有指定，将会取消先前的指定（即设定为0），否则设定为1~3中的一个。
4. 通过with-compilation-unit将编译策略声明的影响限定到它的上下文中。
   使用:override有两个作用，其一，延迟其内部的警告的发生，并且当它为false时，未定义的警告会传播到外层的with-compilation-unit，
   它为true时，就会在该层被处理。
   使用:policy可以将其内部的策略绑定到当前的with-compilation-unit环境而不影响全局的策略。

   例子：
   除了safety其他都使用全局的策略，而在该单元内使用safety为2的策略，该策略不影响全局的safety
   (with-compilation-unit (:policy '(optimize））
	   (declaim (optimize (safety 2)))
	   (load "/home/nixie/workspace/source/workdir/lisp/sbclstudy.lisp"))
   除了safety其他都使用全局策略，safety在该单元内为3
   (with-compilation-unit (:policy '(optimize safety))
	   (load "/home/nixie/workspace/source/workdir/lisp/sbclstudy.lisp"))
   都使用全局策略，包括safety的改变，会影像全局策略
   (with-compilation-unit (:policy nil)
	   (declaim (optimize (safety 2)))
	   (load "/home/nixie/workspace/source/workdir/lisp/sbclstudy.lisp"))
   都不使用全局策略而使用默认策略，safety在该单元内为3
   (with-compilation-unit (:policy '(optimize safety) :override t)
	   (load "/home/nixie/workspace/source/workdir/lisp/sbclstudy.lisp"))

   注：restrict-compiler-policy并不受with-compilation-unit的影响，因此即便它在其内部，也会对全局起作用

Dec 27, 2011 Open coded vs. Closed coded
- 所谓Open coded就是指在函数调用的地方，用等价的内联代码inline code（注意这里只是指代码，而不是其他等价的函数调用）替换掉该函数的调用。
  Open coding通常是牺牲空间来换取时间的一种做法，当实现比较简单的时候通常会这么做。
- 所谓Closed coded就是指在函数调用的地方，要么没有等价的替换，要么替换只是变成调用其他等价的函数。

- open coding与inline expansion的不同
  由于CL中的标准函数都是固定的（用户不应随意修改），编译器一般可以根据情况来选择这些标准函数的内部实现，
  这些内部实现是不同情况下的不同的内联代码。在不同的情况下，选择不同的内联代码进行替换，这就是open coding的实质。
  而inline expansion通常指的是用函数体来代替函数调用的一种优化。


Dec 27, 2011 杂技巧搜集
1. 使用Xephyr实现窗口化X服务
使用Xephyr -ac -br -noreset -screen 800x600 :1&可以打开一个在:1的新的X服务在在当前X服务的一个窗口里。
然后就可以让一些应用连上去看看了。
2. Shell中的路径解析/的定义
POSIX规定一个/代表root目录，多余两个的/如///也应该当成一个/。
而两个/即//是可以由shell的实现决定其含义的。
Bash把//显示为//当作/, Zsh把//显示并且当作/
3. ping的mdev代表的是mean deviation, 是RTT的平均偏差，越大代表网速越不稳定。

Dec 28, 2011 计算理论
1. Turing Machine图灵机
   根据一个表格的规则，读取磁带输入的信息，对符号进行操作的设备。 Universal Turing Machine是能够模拟其他图灵机的图灵机。

   --------------------
   Turing在1948年写了一个简介的定义：
   被分割成一块一块square cell的无限长的磁带infinit tape提供了无限的内存容量，每个symbol都可以存储在一个cell上。
   在一个特定的时刻，只有一个符号在机器中，该符号被称为被扫描的符号(scanned)。机器可以修改这个符号，并且它自己的行为
   也依赖于这个符号，而磁带上的其他符号不能影响当前的机器。最后，磁带是可以前后移动来让机器读取的，这是机器的一个最基本的
   操作。因此，所有的符号都可以被机器扫描。

   对这段还的理解是，图灵机的构成是：
   a. 无限长的磁带（分成cells，每个cells存储有限alphabet中的symbol）
   b. 一个前后可移动的磁头（读写操作）
   c. 一个状态寄存器（记录有限个状态中的一个）
   d. 有限的指令表（迁移函数表）
      根据当前状态和读入指令动作有：移动磁头，读写符号，修改状态。
      deterministic的模型，前两个动作是二选一，最后一个动作是可以结合的；non-deterministic所有动作是可以结合的。
      有些模型里，如果符号和状态的结合没有产生动作，那么机器是可以停止halt。
   --------------------

2. Computable Function可计算的函数
   通过机械的计算设备可以在不限定时间和空间条件下被计算的函数。
   或者说通俗点是有算法描述（一定的计算步骤序列）的函数就是可计算的，它可以用纸和笔在不限定时间和空间等资源的条件下被计算出来。

   --------------------
   在历史上，曾今使用Effectively calculable来代表可计算（但是它是形象的说法）

   Rosser在1939年对Effective的描述是：Effective Method是指计算的每一步都是预先确定好的，并且能够在有限步内产生答案的方法。
   这里Effective有1. 能够产生确定的，准确的，期望的效果，2. 并且能够产生一个结果的意思。

   Turing在1939年中说:computable function的意思是可以被机器计算的函数，而使用effectively calculable来代表形象的意思在不需要特别
   指明这些定义的情况下。即：
   Every effectively calculable function is a computable function.

   a function is effectively calculable if its value can be found by some purely mechanical process.
   a purely mechanical process one which could be carried out by a machine.

   而Effective calculable的意思就是能够不管什么effective的方法产生的， Effective computable是指被图灵机或等价设备产生的。
   --------------------

   P.S.
3. total vs. partial （函数概念的扩展）
   在数学中，如果一个函数它只能把X的子集X'映射到Y，我们说它是X到Y的一个partial function。
   如果该函数X'就是X，那么它就是一个total function。

   对于partial function来说，在recursion theorists那，domain就是X'；在category theorists那，domain还是X，X'被叫做domain of definition

   在可计算理论里面，如果一个可计算函数没有接受所有可能的参数，那么它是partial computable或叫做partial recursive
   否则就是total computable或者叫total recursive

4. Turing Complete图灵完备
   通常说能够模拟turing Machine图灵机的一系列操作规则（系统）的集合是图灵完备的
   （一般有上下文相关文法，递归函数，Lambda算子）。

   Turing Completeness
   如果这套操作规则（或系统）可以计算每一个图灵机能够计算的可计算函数，那么他就是图灵完备的。

5. Turing Equivalence
   如果这套操作规则（或系统）是图灵完备的，且它能计算的每一个函数都可以被图灵机计算，那么它和图灵机是等价的。

6. University
   所谓university是针对一类系统来说，如果这类系统里的每一个可计算函数都可以被某个系统计算，那么该系统就说是在该类系统中具有university.

7. Church-Turing Thesis
   在可计算性上：
     a. 图灵机(by Alan Turing)，
     b. 递归函数(by Alonzo Church, Stephen Kleene, J.B. Rosser)，
     c. Lambda算子(by Alonzo Church)是等价的。
   这三种方法定义的函数是等价类。
   Church-Turing Thesis中指明如果有一个算法被计算，那么使用任何这三种方法都是等价的， 这个性质是作为计算理论的本质存在的，也是一个假定。

Dec 28, 2011 自动机理论
1. Automata自动机
   在离散的时间序列上接受给定的序列输入inputs，每个时间步骤上读取一个输入input（符号symbols或者是字符alphabets集合中的一个）。
   而在任何给定的时间点，所有的输入构成了一串有限的符号或者字符串这个叫做word单词。
   该状态机含有有限个状态state，每个时间步骤上它只处于一个状态。在一个时间点上，状态机读入输入后根据转移函数transition function转移状态
  （转移函数的输入是当前状态和当前输入）
   当输入串处理完后，状态机停止下来，它所处的最后的状态叫final state，有accept和reject两类。
   如果所有的word都被accept，那么也说language被accept了。

2. 根据输入、状态、转移函数和接受条件的不同可以分为不同的状态机
   输入：Finit Input, Infinit Input, Tree word Input（一次读入树的所有输入）, Infinite Tree Input
   状态：Finit States, Infinite States（不可数或者数不尽）, Stack MEmory(pushdown automaton符号可以存入栈中)
   转移：Deterministic, Non-deterministic,
                       Alternation（一种特别的non-deterministic，有existential（选择）和universal(并行)两种不同的非确定转移）
       (这三种可以通过密集构造powerset construction相互转换)

   接受：Acceptance of finite word, Acceptance of infinite word, Probabilistic acceptance
   这些分类还可以相互结合形成更复杂的分类。

  另外，1. 如果给pushdown automaton在增加一个堆栈（即两个），那么这个新的状态机将与图灵机等价。
       2. Linear bounded automaton也是一类特殊的non-deterministic图灵机
          它的意思是不能访问无限长的磁带的所有部分，而只能访问由线性函数决定的有限长度范围，
	  每个读入的输入有上下两个marker，所有的指令的操作都在这个范围内进行。

Dec 28, 2011 形式语言理论
1. Formal grammar正规文法
   由有限终结符terminal symbols, 有限非终结符non-terminal symbols, 有限的产生式集合set of production rules和开始符号构成。
   正规文法定义了正规语言，即从开始符号开始，通过使用产生式产生的有限长度的终结符号序列。
2. Chormsky Hierarchy
   Type-0 grammar(Unrestricted Grammar)（文法中包含a->b的形式, a,b为字串)
   产生能够被图灵机识别的语言，这些语言是recursively enumarable language

   Type-1 grammar(Context-Sensitive Grammar)（文法中包含aAb->arb的形式, a,r（不能为空）,b为字串, A为非终结符）
   产生能够被Linear bounded automaton识别的语言，这些语言是上下文相关语言

   Type-2 grammar(Context-Free Grammar)（文法中包含A->r的形式, A为非终结符, r为字串)
   产生能够被Non-deterministic pushdown automaton识别，这些语言是上下文无关语言

   Type-3 grammar(Regular Grammar)(文法中包含A->aB and A->a, a为终结符, A,B为非终结符）
   产生能够被Finite state automaton识别的语言，这些语言是正规语言regular language
3. Recursive Language
   I. Recursive Set
   在计算理论里，如果有一个算法能够在有限的时间内正确的确定一个给定的自然数是否属于某个自然数集合，
   那么称这个自然数集合是recursive, computable或者decidable。
   换句话说，如果存在一个total computable函数，通过该函数可以确定任意给定的自然数是否是在该自然数集合中，那么该集合就是recursive的。

   II. Recursively Enumerable Set
   在计算理论里，如果存在一个computable函数f，针对该自然数集合中的每一个自然数n, f(n)都是有定义的，且它只定义了这些自然数，
   那么称它是一个recursively enumerable, computably enumerable, 或者semidecidable的集合。
   即只有它是某个可计算函数的domain的时候，它在可能是computably enumerable。

   III. 对于Computable Language或者说Recursive Language
   就是只要有一个total function能够确定字符集alphabet中的所有symbol要么属于要么不属于该语言，那么该语言就是可计算的。
   这个感觉比Type-0还要大的语言，对应Decider(Always Halting Turing machine)

   对于Computably enumerable或者说Recursively enumerable Language
   就是说只要是在该语言里定义的symbol，都存在一个可计算函数可以对它进行计算。
   这个就是Type-0文法产生的语言

Dec 29, 2011 HTTP返回码含义
1XX 信息
2XX 成功
3XX 重定位
4XX 客户端错误
5XX 服务端错误

Dec 30, 2011 编译器优化
1. 尾调用优化Tail call optimization
针对存在尾调用Tail call的代码，通过取消为被调用者创建新栈帧（保存参数目的）直接使用调用者的栈空间的动作，
通过简单的跳转去执行被调用者的代码。

使用尾调用优化可以减少对栈空间的需求，对于递归或者深层次的函数调用节省栈的消耗。

2. 尾调用Tail call
所谓尾调用，被调用者是调用者返回前的最后一个操作，即被调用者返回后调用者就立即返回之间不再做其他操作。
尾调用的好处是被调用者的返回值可以直接作为调用者的返回值返回，所以进入被调用者后，调用者的栈空间就没有必要保存了，被调用者可以利用这一空间
（因为调用者后续没有操作，而所有的信息都已经传递给被调用者），这就为尾递归优化提供了基础。

3. Tail local call
对于CL中，即意思是通过labels, flet定义的函数存在尾调用。是一种效率很高的调用方式。

（补充：从continuation的角度理解，tail call是指在tail position的调用，
而tail position指的是当前表达式的continuation和包含它的表达式的continuation相同，
如：(if A B C)中，B的作为redex（求值后结果），它的continuation等同于这个if的continuation，所以它处在if的tail position,
B处的调用就是tail call， 符号表示为：C[B] => C[(if A B C)], 这部分详细可以参考racket reference中对于tail position的解释。)

Dec 30, 2011 CL编译、调试
(disassemble fn)
通过该函数可以输出一个函数、或者lambda生成的本地代码 (SBCL中为汇编)
(compile-file #p"path-to-src" :trace-output t)
在编译的时候会生成编译过程的log (SBCL中输出IR1和IR2的信息）

Jan 3, 2012 CL语言，生命周期
Scope vs. Extent
在CL中有Extent和Scope两个跟生命期（Reference引用的有效性）相关的概念
Scope涉及的是空间的、代码文字范围上的范围概念
Extent涉及的是时间范围的概念
- Lexical Scope
  对已经建立的实体的引用(reference to established entity)限制在与创建这个实体的构造相同的代码部分(program portions that are lexically contained within the establishing construct)。通常这个包含构造实体的代码部分构成叫做body, 而对该实体的引用就只能在这个body中。
  例子：
  函数的参数名

- Indefinite Scope
  对实体的引用可以在任何代码部分进行，没有限制。

- Dynamic Extent
  对实体的访问限定在创建实体到销毁实体的时间范围内，通常dynamic extent都遵循类似于stack的规则。
  例子：
  1. 如with-open-file会建立一个访问文件的连接，并创建流来代表这个连接，虽然流对象是indefinite extent,但这个连接是dynamic extent的。
  2. 在如用special声明的变量。

- Indefinite Extent
  实体一直存在到引用不存在为止的时间点。
  例子：
  1. 大多数的对象
  2. 函数内lexical scoped的函数参数（这些变量使得构造闭包称为可能）

除了以上这些概念，还有一个dynamic scope的概念，它indefinite scope + dynamic extent，虽然用词不当，但是已经称为传统和习惯。

Jan 3, 2012 CL语言，控制转移
1. normal return
   在执行完form后的控制和值的自然转移(natrual transfer of control and values after the completen execuation of a form)
2. non-local exit - NLX
   由除了normal return以外的原因引起的到退出点(exit point)的控制和值的转移。（通常由go, throw, return-from引起的转移）
3. exit point
   在控制form中的一个点，可以通过主动的方式（通过转移form如go, throw）或者被动方式（即通常的evaluation的顺序）将控制和值转移到该点。
   1. catch建立了个throw可以转移的退出点，该退出点名字是indefinite scope, dynamic extent即dynamic variable
   2. block建立了个return-from可以转移的退出点,该退出点名字是lexical scope, dynamic extent
   3. tagbody建立了个退出点可以用go跳转，退出点和block的退出点作用域相同
   4. unwind-protect建立了个throw可以跳转的退出点

Jan 5, 2012 CL语言，参数
函数，宏的定义都涉及到参数，参数在CL中叫做lambda list。
分为三种不同的lambda list
- Ordinary Lambda List
  即被普通的函数ordinary function使用的参数表，
  一般defun, flet, labels, lambda, handler-case, restart-case等都使用的是ordinary lambda list
  该参数表只包含如下的关键字lambda keyword:
  &optional, &rest, &key, &allow-other-keys, &aux

  标准规定处理这些parameter specifier的顺序是：
  1. 首先处理required parameter
  2. 其次是optional parameter
  3. 然后是rest 和 keyword parameter（注意这里如果有一个argument，会被同时处理到这两个parameter specifier的绑定上。）
  4. 如果keyword同名的有多个，最左边的被处理。
  5. 在这些都处理完了以后，aux parameter会被处理。（但是它不是参数，它只是用于函数内部普通变量的初始化，相当于一个let*)

  还有&allow-other-keys parameter keyword和:allow-other-keys t argument pair可以使的一个接受keyword的函数，接受与keyword parameter不匹配的keyword argument pair。

- Extended Lambda List
  就是扩展了Ordinary Lambda List的语法，增加了关键字的列表，通常defmacro使用的就是这种
  包含诸如&body, &whole这样的关键字

- Modified Lambda List
  就是从Ordinary Lambda List修改或者继承而来的参数表，通常deftype使用的就是这种

最后，
- lambda-list-keywords 可以显示实现支持的lambda list关键字都有那些
- lambda-parameters-limit 可以显示实现支持的输入参数个数最大限制。

另外，对于defstruct创建的constructor，还有一种叫做boa lambda list的东西，它其实相当于ordinary lambda list, 只不过
该参数列表中的参数用于constructor中初始化成员，而这个初始化是要与成员的顺序一一对应的。BOA的意思是By Order of Arugments。
对于deftype中使用到的deftype lambda list，它相当于macro lambda list，只是&optional和&keyword的默认值没有指定时，默认为*而不是nil。

P.S.
在SBCL中，编译前端会将lambda list参数表转换为IR1中的lambda-vars和arg-info结构(在make-lambda-vars函数中)，
每一个参数都会有自己的lambda-vars，如果是&optional, &keyword诸如这类特殊的参数，还会有对应的arg-info记录它们的额外信息（如默认值、是否提供判断，关键字等）

Jan 6, 2012 SBCL编译器，后端
在SBCL编译器的后端中，Template, VOP, VOP-INFO, primitive指的都是同样的事情，就是VOP
这些VOP定义在sb-c::*backend-template-names*哈希表中。并且可以通过%primitive访问。

Jan 19, 2012 SBCL的回归测试
文件结构
在SBCL中，对系统的回归测试都放在/sbcl/tests/文件夹下，测试文件的结构一般是<pure or impure>.<function parts>.lisp
首先测试分为pure和impure两大类，pure的测试是不产生副作用（即没有全局变量、函数、宏等的定义的）。
相反impure一般都有全局的函数、变量、类、错误等定义。
其次，根据功能，将测试分开成不同的小类，比如compiler, arith, alien, loop等不同的测试分在不同的文件中。

定义测试
定义测试需要使用with-test，它可以通过:name指定测试的名字
在定义的测试中，可以使用assert等方式来判断，如果没有一个assert失败，那么with-test就会成功。
而在assert里面，可以是任意的lisp代码。

最后，在tests目录下，还有个assertoid.lisp文件，其中定义了帮助编写rt的常用的宏。
如raise-error?用来测试代码是否产生某个错误，is测试某个op对两个输入的结果是否一致（我觉得一般op应该都是eq之类的东西）
grab-condition类似于raise-error?返回捕获的错误，assertoid功能比较多，支持一个form在不同优化条件下，等于特定的期望值或者产生期望的错误。

Jan 30, 2012 CL实现的名字，版本，机器的名字，版本，类型的获取
(lisp-implementation-type)
(lisp-implementation-version)
(machine-instance)
(machine-type)
(machine-version)

Jan 30, 2012 CL reader
- Read Table
    CL的语法是由reader的readtable决定的，readtable可分为，当前的*readtable*，标准的（默认的），和初始的三种。
    同一个时间可以有很多个readtable, 但reader只使用其中一种。因此，CL的语法可以通过readtable切换。
    以下是相关的一些函数：
    copy-readtable
    readtable-case
    readtablep
    set-dispatch-macro-character
    get-dispatch-macro-character
    make-dispatch-macro-character
    set-syntax-from-char
    set-macro-character
    get-macro-character

    readtable中每一个字符都有对应的语法类型(syntax type)，不同的类型影响reader对字符的处理。
    + constituent类型表示字符是token（如符号，数字）的一部分；
    + whitespace类型是token的分割符号；
    + macro类型，当reader遇到的时候就会将其分派(dispatch)到相应的reader macro function来处理输入。
      + non-terminating 在token中间出现时，它被当作constituent，否则是macro（如:#）。
      + terminating 会中断正在分析的token
    + escape类型，防止后续的字符被大小写转化，一般有single escape（如:\) 和multiple escape （如: |)

    对于macro类型，CL默认的标准定义有如下：
    ()'"`,#;

- 影响语法的dynamic variable
  除了Read Table还有一些全局变量影响reader，如：
  *read-base*
  *read-suppress*
  *package*
  *read-default-float-format*
  *read-eval*控制#这个macro char的启用与否

- 控制reader对大小写的处理
  除了通过escape字符来控制大小写，还可以通过控制当前readtable的readtable case，可以达到如下的效果：
  :upcase， 当使用此关键字值时，所有未被escape的符号都变成的大写
  :downcase, 类似与上面，都被转成小写
  :preserve， 所有的大小写都变化
  :invert,  所有的未被escape的符号，如果在一个token中都是同样的case, 那么就会被转换成相反的case。换言之，
            全是小写的token会被转换成大写，全是大写的会被转换成小写，有大小写混杂的则保持不变。

Jan 31, 2012 Linux Shell-Script Invoking
有三种方式可以执行一个脚本，他们的效果差别很大，
1. 使用sh命令，或者./ (默认)
   执行的脚本将会作为调用脚本进程的子进程执行，这将会影响环境变量 (父进程必须通过export传递给子进程，而子进程无法传递给父进程)
2. 使用source，或者. ./
   执行的脚本在原进程中执行，因此继承并且可以修改原进程中的所有环境变量
3. 使用exec
   执行的脚本将会替换原来执行的内容，在该命令后的原脚本的内容都将不再执行

Apr 14, 2012 ELP (Emacs Lisp Profiler)可用来对Emacs进行Profiling
有三种方式:
  - elp-instrument-package
  - elp-instrument-function
  - elp-instrument-list

通过 elp-results 可以查看对特定函数的profiling结果。
这样可以发现一些性能上的瓶颈。

Apr 17, 2012 dpkg错误处理
有时候倒霉会碰到dpkg包管理错误（比如安装时突然断电）
一旦发生这样的错误，往往后续的安装将会失败或者报错，通常情况下apt-get之类的无法修复。

以下是一些修复的方案：
1. 先尝试最基本的dpkg修复
   - 使用dpkg --audit查看错误
   - 使用dpkg --remove/--configure/--install/--purge等对出错包进行处理
2. 如果以上还不能成功
   - 使用dpkg --force all --remove
2.5 如果还不行
   - 使用aptitude update, aptitude install -f进行修复
3. 如果还不成功
   - 保存/var/lib/dpkg/status
   - 打开/var/lib/dpkg/status，找出出错的包所在的 Package: XXXX的行
   - 删除从Package: XXXX的整个该包的信息
   - 保持下一个包和上一个包仅隔一行
   - 然后使用aptitude install -f重新安装
4. 如果还不成功， 恭喜你！

Apr 19, 2012 软件介绍
unetbootin可以使得grub2加载硬盘上的iso文件，因此免去了刻盘的麻烦。
比起徒手去load各种iso镜像。方便很多。

virt-manager是一款很好的管理kvm虚拟机的软件。
但是ubuntu karmic上0.7.0的版本是破损的。

win32下可以使用Git for Windows + Toitose Git来使用git
另外，作为git server端的用户配置，可以之用gitosis
gitosis是一个在git仓库中被版本管理的管理git仓库访问权限的配置项目。

doxygen可以生成代码文档，配合emacs的doxymacs可以很轻松生成针对
代码的文档注视。需要注意doxygen -g默认生成的Doxyfile中，是不生成XML TAG
的，而doxymacs若需要扫描，就需要这个TAG。所以除非仅仅把doxymacs
当添加标准注释工具，就有必要配置配置Doxyfile.另外，使用doxygen-gui的
doxywizard可以方便的进行配置。

Apr 19, 2012 Gentoo 镜像站点
- 源镜像
  Gentoo的full source mirror大小大概240G以上，
  包括
	distfiles（源码目录140G）,
	snapshots(portage快照600M）,
	releases（正式stage, livedvd发布40～50G),
	experamental(实验性的发布， 20～30G)

  镜像站点的制作可以只包括前两者（叫做partial mirror)或者所有(叫做full mirror)
  同步镜像使用rsync工具，要求每个站点4小时同步一次。

- rsync镜像
  除了源镜像还有一种镜像是保持多个机器间的portage同步的
  通常是使用一台机器作为rsyncd服务，提供给其他机器进行同步

May 8, 2012 git submodule 相关命令
修改子模块的remote:	  更新.gitmodule后运行git submodule sync
删除子模块: 	   	  更新.gitmodule和.git/config后，使用git rm --cached 子模块路径 将其删除
忽略子模块的dirty变化：	  在.gitmodule中子项目配置下加入ignore=dirty

May 8, 2012 udev设备管理器
linux系统中的udev负责设备管理的工作，通过内核sysfs和uevent获取设备信息，根据/etc/udev/rules.d下的配置，
对设备执行相应的动作（包括在用户层将设备映射到/dev目录下的文件，执行指定的脚本等）

通过udev系统解决了两大问题：
1. /dev目录下的文件在传统unix中是固定的，因此对于添加设备文件，或许需要手动进行。还有如果某些设备的链接拓扑结构变化时，文件将指向错误的设备。
2. 当某些设备挂载到系统中时，可能需要自动执行一些初始化程序，通过udev的rules就可以轻松实现。

注：
1. 在udev出现之前，devfs在2.4内核中管理/dev目录，类似于udev，但却是内核态的。现在多数发行版已经使用udev替代它。
2. udev后续版本严重依赖于uevent，所以基本上在2.6之前的内核很可能不会支持了。
3. udev在2.6内核中一段时间使用hal层，后来hal被merge进了udev，所以现在3.0之后的基本上都看不到hal这个东西了。

May 8, 2012 linux bridging设备
linux内核可以配置成伪装的bridge设备，当启用CONFIG_BRIDGE后，
可以使用bridge-utils的brctl来给linux添加网桥。

网桥是工作在二层的设备，它能够将两个物理网段链接起来。在linux系统中的具体应用就是
通过将两块物理网卡桥接到这个虚拟的网桥中，将把两块物理网卡所在的网段在二层上打通。

注：
1. 当linux作为网桥设备时，它的两块物理网卡都处于混杂模式，且没有IP地址的。
这个时候，如果仍然想让linux工作在IP层的话，其实可以给创建的网桥配置一个IP。
这样就可以通过这个IP访问作为网桥的Linux系统了。
2. 如果应用场景是qemu-kvm之类的虚拟机环境，那么内核还需要启用CONFIG_TUN对tun/tap设备的支持。

May 8, 2012 ibus与emacs ibus-mode的冲突
当在ibus设置窗口的[Advance]页面中启用了[Share the same input method among all applications]的时候，
这个与ibus-mode中的ibus-mode-local冲突了，使得会不断的报告IMContext ID xx is mismatched的错误。
这个时候可以关掉[Share the same input method among all application]

May 15, 2012 X property和X client message
X Client可以通过property来存储一些客户端特定的数据，通常Window Manager为了管理窗口会定义
一些特定的属性。通过获取这些属性就可以了解窗口相关的信息。在cli下，可以通过xprop命令获取特定窗口的属性。

在Emacs下，可以通过x-window-property函数获取属性，要注意的是type参数一般用"AnyPropertyType"，
vector-ret-p是t，如果窗口没有属性，就会返回nil,如果返回其他的结果，则可能是type参数或者vector-p参数不正确。

另外，可以通过修改属性或者发送客户端消息的方式来修改特定的属性，在Emacs中可以使用x-send-client-message函数
来达到这个目的。

May 15, 2012 polkit与consolekit
policykit提供权限认证的API给一些拥有权限的程序(Mechanism)，让这些程序来验证那些没有权限的程序发来的动作请求。
这些请求可能通过DBUS或者Unix pipeline传来。通过验证这些请求，就可以赋予这些无权限的程序一些有权限的程序才能作
的事情。
polkit包括了一个在dbus上的认证机构authority,以及每个用户session上运行的认证代理agent。代理agent用来表明客户程序
是特定用户session下的客户程序。机构authority用来验证权限。

通过pkaction可以查看当前在polkit管辖下的动作。通过pkcheck可以检查，通过pkexec可以以另外一个用户身份执行

consolekit是用来管理用户session和权限的，通常使用它来允许一般用户mount移动存储设备或者关机重启这类一般应该由root才能
完成的动作。

May 16, 2012 gitosis管理员key变更
当gitosis的管理员key变更的时候，简单的更新key目录下的pub文件是不行的。
这个时候需要到gitosis-admin的bare目录中运行su -H -u git gitosis-init < /path/to/new_public_key.pub
重新初始化管理员使用的key。

May 16, 2012 sb-unix是内部使用的包
在SBCL中，sb-unix并不是开放给外部使用的，而是为了内部实现使用的，这个和CMUCL不同。
它的函数定义很可能会发生变化。如果需要使用类似功能，需要使用sb-posix或者直接使用FFI

May 17, 2012 racket的scribble语法
通过@表达式可以简化一般S-exp的写法，使得编写像文档一样的代码很容易。
这样通过scribble就可以生成文档。
@表达式的语法一般是@<cmd>[<datum>*]{<text-body>*}
这其实是(<cmd> <datum>* <parsed-body>*)函数调用的语法变形。

另外，@表达式还支持直接的racket模式的函数调用@(frob arg1 arg2 ...)

在@表达式中可以嵌套其他的@表达式，这将类似于在函数调用的参数中还有函数调用。
如果想要转义这种动作，可以使用|{...}|的括号形式,这样一般嵌套的@就会作为普通的字符。
如果这时还需要@表达式，就需要使用|@代替。如果|{括号形式中间包含其他诸如<<之类的字符，
那么|}和|@也必须包含这些字符的反向才能达到效果。
e.g.
	@foo|{@abc}| => (foo "@abc")
	@foo|{|@"abc"}| => (foo "abc")
	@foo|<<{|@abc}>>| => (foo "|@abc")
	@foo|!{|!@"abc"}!| => (foo "abc")

另外@| ... |可以将其中的任何内容转义为racket代码，防止{}将其视作文本，而@||可以将{}中连续的文本分开。

@表达式中的<cmd>部分也可以没有，这个时候其实类似于一个list，通常需要和quote一起使用。
当<datum>和<text-body>都省去的时候，<cmd>部分就直接以<cmd>的文字形式出现，不会外加括号。
这通常可以作为对racket中symbole的转义，e.g. @"@"

@和<cmd>之间还可以有任何的标点，如'`@@#;之类的，这些标点会被放到变换后的s-exp的最前面
e.g. @'foo{blah} => '(foo blah)
一般这样可以实现注释，@; bla bla bla或者@;{ <any>* }，注意第二种方式<any>还是需要符合@表达式语法的。

一般情况下@表达式是在scribble/base, scribble/manual, scribble/sigplan这样的包中的
也可以通过meta-lang的特性将其引入一般的module中，e.g. #lang at-exp racket

最后因为引入了@表达式的语法，一般的s-exp中的符号就不能以@开头了。如果必须以@开头，则需要通过\或者|来转义。

May 18, 2012 DrRacket中输入Latex符号
在DrRacket中可以通过\<macro> Meta-\的方式输入非ascii字符。
如: \Lambda Meta-\将会显示希腊字母兰母达。或者\smiley Meta-\输入将显示一个笑脸。
另外，也可以通过C-\迅速输入一个兰母达字符。

May 21, 2012 git refname XXX is ambiguous警告
当git中某个branch的名字是HEAD或者是origin/master的时候，
这将使得与git中固有的符号相冲突，进而在运行一些git命令的时候会报出警告。
如当运行git rev-list HEAD --not origin/master的时候，如果
有一个branch名字恰巧叫origin/master的话，就会有：
refname 'origin/master' is ambiguous 的警告。

May 22, 2012 CLHS中编译器相关

3.2.1 编译器术语

- compiler是将代码翻译成与特定实现相关（表示或者执行效率会提高）代码的过程。术语compiler指的就是compile和compile-file这两个函数。
- compiled code指的是被编译后的程序代码的对象表示，这些对象由compile或者在加载被编译文件是的load创建。
- implicit compilation指的是在evaluation时的编译处理。
- literal object指的是quoted对象或者self-evaluating对象，以及这些对象的子对像。但不包括常变量。
- coalesce指的是在源代码中两个不同(not eql)的literal object - A和B， 在被编译后对应的对象A'和B'相同了(eql)的优化
- minimal compilation指的是编译时标准规定的最少动作。

- 动词process指的就是进行minimal compilation，如确定代码求值的时间，或者对其求值（如果需要的话）
- further compilation指的是在minimal compilation之后实现相关的特殊编译过程。process并不说明完整的编译。
  诸如block compilation或者生成特定机器指令的编译过程都是further compilation的内容。further compilation可以发生在运行时。

与编译相关的环境由四种：startup environment, compilation environment, evaluation environment, runtime environment.
- startup环境指的是compiler运行启动时的Lisp image环境。
- compilation环境由编译器维护用于存储编译器内部需要的定义和声明。只有必须的部分会保存在该环境中。诸如传递给macro expander的环境参数就是compilation环境。
- evaluation环境是runtime环境的一种，所有由编译器发起的求值动作都在该环境中进行，如macro expander以及由eval-when指明的求值。
- runtime环境是指被编译的代码运行的环境。

compilation环境继承evaluation环境，它们可能相同。evaluation环境继承startup环境，它们可能相同。

- compile time指的是编译器处理源代码的时间段。在compile time中，只会有compilation和evalutaion两个环境。
- run time指的是loader加载了被编译后的代码，代码运行的时间段。在run time中，只会由runtime环境。

- run-time compiler指的是通过函数compile或者implicit compilation进行的编译，此时编译和运行时环境在同一个Lisp image中。此时runtime环境等同于startup环境。

3.2.2 编译语义

从概念上来讲，编译就是一个遍历代码、根据在compilation环境中的特定信息对代码语法语义进行分析、生成等价的更加高效的代码的过程。

3.2.2.1 compiler macro
一个compiler macro的名字也可以是function或者macro的名字。它们可以同时存在。
如果在给定的词法环境中一个函数的名字作为compiler-macro-function参数的时候，它的返回值不是nil，那么就说明在该词法环境中，存在一个compiler macro。但是新创建的local函数或者宏定义会更新当前的词法绑定(lexical binding)，以至于覆盖shadow存在的compiler macro。

由compiler-macro-function返回的结果是一个两个参数的函数，它叫做expansion function。为了展开compiler macro，需要调用macroexpand hook，并将expansion function、整个compiler macro代码以及当前的compliation环境作为参数。然后macroexpand hook会调用expansion function来展开compiler macro。返回的展开结果也许跟展开前的compiler macro代码完全相同，这个展开结果会替换原来的代码。

*macroexpand-hook* compiler-macro-function define-compiler-macro

3.2.2.1.1 compiler macro的目的
compiler macro的目的是允许通过选择性的源代码变换来优化编译。对于一个compound代码的process, 如果代码中的操作符是一个compiler macro, compiler-macro-function可能被调用来将代码展开，展开后的代码则会替换原来的代码被进一步的处理。

compiler macro function(expansion function)如同普通的macro function, 接受两个参数：一个是整个的macro代码，另外一个就是环境。
但与一般的macro function不同，compiler macro function可以拒绝展开，直接返回原来的代码。

如果compile-file选择展开一个top level form的compiler macro form。那么展开后的代码仍然被当作top level form处理。

3.2.2.1.2 compiler macro命名
compiler macro的名字可以与函数或者macro的名字相同。但是它是严格全局的。所以不可能像macrolet一样定义局部的compiler macro。想法，局部的函数定义和宏定义会覆盖（shadow）全局的compiler macro。

注意compiler macro的存在不会影响存在的同名函数和宏定义。因为compiler macro是全局的，通过compiler-macro-function足够区分它们与那些词法环境中定义的函数和宏。

3.2.2.1.3 什么时间使用compiler macro
有以下两个情况是绝对不能使用的，其他情况标准不指定：
- 当词法绑定被同名的函数或宏覆盖的时候
- 当函数名被声明为notinline，恰巧该段代码在声明中。

3.2.2.1.3.1 compiler macro实现注意
虽然技术上允许在eval的时候和compile的时候，对compiler macro做相同的处理。但是在interpreted implementation中，可不是一个好主意。
因为compiler macro是用来通过在编译期展开来优化运行时速度的，通过compiler macro编译器也许需要话更长的时间进行编译。这在interpreted implementation中eval这么做就比较低效了。

3.2.2.2 minimal compilation
minimal compilation定义如下：
- 所有出现在源代码中的compiler macro被展开。在运行时时，它们不会展开。
- 所有的macro和symbol macro都会在编译期展开，展开直到在运行时不需要再展开。
  macrolet和symbol-macrolet都被它们body部分的代码替换、这些代码中引用的宏也将被展开替换。
- 在load-time-value代码中的第一个参数，会被compile在compile time求值。但在compile-file的处理中，编译器安排它在load time求值。两种情况下，求值的结果都会被记录下来，用于在运行时execution time的load-time-value的值。

3.2.3 File Compilation
函数compile-file根据3.2.2 Compilation Semantics定义的规则编译，产生一个能被load加载的文件。
通常，在被compile-file编译的文件中的top level form不会在编译时被求值，而是在被编译的文件被加载时。但有时，一个典型的情况就是文件中的代码需要在编译期求值，然后余下的代码才能顺利的被继续编译。

eval-when特殊form就是用来控制top level form在compile time、load time的求值的。对于一个top level的eval-when代码段来说，:compile-toplevel会使其在compile time被编译器求值。:load-toplevel则会使得编译器安排它在load time求值。而对于非top level的eval-when代码段，:execute可以使其在runtime环境中被执行。


eval-when的行为可以准确的用compile-file进行process的模型来理解：有两种process模式，“not-compile-time"和“compile-time-too"

compile-file在not-compile-time工作模式下会从文件中读取代码，并将这些代码的求值安排在load time而不是在compile time中直接求值。
在compile-time-too模式下，则在load time和compile time中都会求值。

3.2.3.1 对top level form的处理

"一个top level form就是被compile-file进行特殊处理的form，进行特殊处理的目的是允许在编译期求值。个人理解就是，只有在file compilation中存在toplevel form。"

1. 如果代码是一个compiler macro form(并且没有被notinline禁止)，编译器可以选择是否展开并处理它。如果不展开，那就必须处理原先的代码。
2. 对于macro form，会将其当作toplevel form展开和处理。
3. 对于progn， 它的内部的每个form都当作toplevel form展开处理。
4. 对于locally, macrolet或者symbol-macrolet, compile-file在建立了合适的绑定后，处理器内部的form如同top level form的处理。
5. eval-when的处理:

CT LT E Mode Action New Mode
Y  Y  - -    P      compile-time-too
N  Y  Y C    P      compile-time-too
N  Y  Y N    P      not-compile-time
N  Y  N -    P      not-compile-time
Y  N  - -    E      -
N  N  Y C    E      -
N  N  Y N    D      -
N  N  N -    D      -

Y for Yes, N for No, C for compile-time-too, N for not-compile-time, P for process, E for Evaluate, D for discard
- in Mode for irrelevant, - in New Mode for remain in current mode

在compile-time-too模式下，process意味着首先编译器在evaluation环境中对其求值，然后进行minimal compile。而not-compile-time模式下，process仅仅是minimal compile。

6. 所有subform都认为是非top level form

注意:
- 对于top level form，编译器是按照在代码里出现的顺序进行处理的。而对于非top level form的subform的处理(包括宏展开)还有further compilation标准不要求顺序，只要符合compliation semantic。
- 对于非top level form, eval-when的:compile-toplevel和:load-toplevel都会被忽略(使用compile或者eval进行编译和求值时也是如此)。对于非top-level form，eval-when指定:execute的时候被当作一个implicit progn处理。

May 22, 2012 SBCL 各种编译过程IR1前的处理调用关系
1. 通过repl中输入代码的编译(implicit compilation)

							       +--<---+
							       |      |
     							       |      ^
       +------------+         +------------+         +---------+---   |     +------------+         +------------+         +------------+         +------------+        +------------+
       |            |         |            |         | simple-eval|   |     |            |         |            |         |            |	 |            |        | make-functi|
       |            |         |            |         | -in-lexenv +->-+     |            |         |compile-in- |         |            |	 |            |        |onal-from-to|
       |interactive |-------->|  eval      |-------->| or         |-------->|%simple-eval|-------->|lexenv      |-------->|actually-   |-------->| %compile   |------->|p-level-lamb|-------->
       |   -eval    |         |            |         | eval-in-lex|         |            |         |            |         |compile     |	 |            |        |da          |
       |            |         |            |         | en         |         |            |         |            |         |            |	 |            |        |            |
       +------------+         +------------+         +------------+         +------------+         +------------+         +------------+	 +------------+        +------------+

       设置repl的一些变量        设置*eval-x-x*            分派处理               创建用于求值的           编译后，设置函数          初始编译相关信息            编译开始                IR1 变换
       如：*, **, /, //        这些全局变量                                     named lambda          或宏名字与编译结果         compilation-unit
                                                                             编译后，求值            的绑定


      注：
      1. simple-eval-in-lexenv会循环调用simple-eval-progn-body, simple-eval-locally以及自身

2. 通过compile-file的编译										       +-----------+
													       |           |
										    +----<----+		    +>-+ eval-tlf  |->+
									            |         |		    |  |           |  |
										    |	      ^		    |  +-----------+  |
       +------------+         +------------+         +------------+         +-------+----+    |    +--------+---+         +---+--------+         +------------+
       |            |         |            |         |            |         |            |    |    |convert-and-|         |            |	 |            |
       |            |         | sub-compile|         |sub-sub-comp|         |process-topl+->--+    |maybe-compil|         |ir1-toplevel|	 |            |
       |compile-file|-------->| -file      |-------->|ile-file    |-------->|evel-form   |-------->|e or eval-co|-------->|            |-------->|compile-topl|-------->
       |            |         |            |         |            |         |            |         |mpile-toplev|         |            |	 |evl         |
       |            |         |            |         |            |         |            |         |el          |         |            |	 |            |
       +------------+         +------------+         +------------+         +------------+         +------------+         +------------+	 +------------+

       设置代码文件相关          动作类似于              循环处理每个toplevel     宏展开，eval-when处理         编译开始                 IR1变换                后续编译动作
       变量，source-info       actually-compile                            minimal compilation
       file-info,输出          另外，还包括dump fasl
       fasl文件等


       注：
       1. 当eval-compile-toplevel时会先求值，然后对求值部分编译。eval-tlf和eval类似，不过会设置*eval-tlf-index*，并且支持从非null-lexenv求值。
       2. process-toplevel-form会根据情况递归调用process-toplevel-progn, process-toplevel-locally及自身。这点和simple-eval-in-lexenv有点类似。

3. 通过compile的编译（run-time compilation）


       +------------+         +------------+         +------------+         +------------+        +------------+
       |            |         |            |         |            |         |            |        | make-functi|
       |            |         |compile-in- |         |            |	    |            |        |onal-from-to|
       | compile    |-------->|lexenv      |-------->|actually-   |-------->| %compile   |------->|p-level-lamb|-------->
       |            |         |            |         |compile     |	    |            |        |da          |
       |            |         |            |         |            |	    |            |        |            |
       +------------+         +------------+         +------------+	    +------------+        +------------+

        基本同1的过程的后半部分。如果是从repl输入的compile, 那么compile之前就是simple-eval-in-lexenv。


May 24, 2012 SBCL编译feature
编译sbcl源代码的时候，可以指定一些feature，如以最高debug优化等级编译sbcl
全部的feature在base-target-features.lisp-expr中定义。
通过make-config.sh --with-<feature> 以及--fancy， 可以打开一些feature。
打开后的feature在local-target-features.lisp-expr中可以找到。

如可以make-config.sh --with-sb-debug --fancy

May 29, 2012 Racket reader
在racket中宏扩展只能扩展语言，它表现出两个层面的限制：
1. 不能限制或者修改所在上下文中的既有语法以及周围的form。
2. 只能够在语言的词法规定允许的范围内进行扩展，但不能改变s-exp的使用，如()[]{}, 不能改变一些核心语法，如，identifier，keyword的写法。

因此说宏扩展是在展开器层(expander layer)上的语言扩展。
还有一种就是在读入器层(reader layer)上的语言扩展。

在racket中，宏扩展使用define-syntax和define-syntax-rule，通过操作syntax-object实现扩展。

- Reading via an Extension
而reader则通过模块和readtable来进行扩展。
#reader <module> 通过使用用户在module中自定义的read和read-syntax对其后续的代码的读入方式进行改变，这样就改变了reader原来的语法，按照用户自定义的方式读入。
另一种类似的方式是通过#lang reader <module>，类似于#reader，但整个改变了后续的语法，要求<module>的read和read-syntax产生的结果必须是个module form。
另外，若新语言是基于已有的语法的，可以使用#lang s-exp syntax/module-reader定义新语言的module，它可以在s-exp的基础上扩展部分的reader语法，这样简化了新语言的创造。
（通过重新provide新的绑定read和read-syntax以及使用readtable）。

实际上#lang reader类似于#lang s-exp，后者允许#lang使用独立的模块语言，s-exp在这里表示在reader层上使用s-exp作为基本语法，而前者则一开始就指名使用用户自定义的reader语法而不是s-exp。
在racket的scribble中就有类似的使用，@-exp, #lang @-exp 表示使用@表达式，这里reader, @exp, s-exp都被叫做meta-language。

最后，如果你想直接使用#lang <module language name>来代替#lang reader <module>，你必须安装这些<module>到collection中。
具体方法可以是：
把module文件改名，并放入如下：<module language name>/lang/reader.rkt路径中。
使用raco link <module language name>安装到collection
或
使用raco pack --collect <module language name>.plt <module language name>打包到一个.plt文件中
使用raco setup -A <module language name>.plt安装

- Readtable
默认的reader是一个递归下降分析器（recursive-descent parser）。（想像根据不同的case递归调用自己完成parse的过程）
默认的reader定义了基本的语法，包括哪些字符拥有特殊的含义。可能将(){}[]",`';以及空格定义为分隔符，另外#会是一般的宏分派字符，|\则定义了基本的转义功能。
但这些语法可以通过readtable以及其他一些参数来进行扩展。

如，修改(在readtable中的含义，通常情况下，当遇到(时，都会递归的读取后续的subform直到遇到)符号。
通过parameterize current-readtable以及make-readtable就可以修改默认的readtable来实现一些小的语法变化。

和CL readtable中众多的char type相比，racket中只有三种，
terminating-macro 使得char类似于delimiter，即便在标示符中间也会引起readtable相应的proc进行特殊处理
non-terminating-macro 仅仅出现在标示符开头时才会引起proc特殊处理
dispatch-macro如同non-terminating-macro,不过他必须出现在#后面，或者准确的说，任何行为被定义为#hash的符号后面。

- Racket的read chain
通过read读取racket的代码时，当遇到#lang 或者#reader的时候，read就会递归的调用这些语言扩展机制的模块中新定义的read，这样就完成了对不同语法的一致的read。
个人觉得这个是站在比较高的抽象层次上的一种语言机制(比起CL的reader就更加general。)
通常情况下，读取也许不被允许，这可以通过改变read-accept-lang和read-accept-reader参数来改变。

May 29, 2012 SBCL编译器术语辨析
local call指的是functional和combination在同一个component中的调用。
XEP指的是external entry point, 函数调用都是通过entry point调入被调函数体的。但是如果不是local call的时候，就需要一个外部的entry point。这个XEP就是给非local call的调用提供的entry point。
cleanup一般对应entry，它主要用于处理dynamic extent在退出范围时候的清理工作，entry就是它的messup。


May 30, 2012 racket hygeinic macro
racket的define-syntax, define-syntax-rule, syntax-rules, syntax-case, 还有with-syntax
前两个都用来引入新的macro，后面的都是辅助函数。
在racket中有两种方式可以定义hygienic macro，一个是syntax-rule，通过简单的pattern<->template match方式实现
另一个则比较复杂，syntax-case，通过操作syntax-object来实现。可以说后者就是前者的更底层。

syntax-object可以看成是包括了代码的literal表示，以及srcloc, col, pos这类代码信息的结构。
在racket中通过#'操作符可以将一个代码变成syntax-object, 我个人感觉是，这个操作符类似于quote，只不过是在语法层面上的quote。
syntax-case会将一个syntax-object与一个pattern进行match，并将pattern中的变量绑定在后续的操作中，这样就可以在后续通过pattern variable重新访问syntax-object中的对象。
with-syntax和syntax-case功能基本一样，只不过前者是用来一个一个match的，后者则match其中的一个pattern case。

在hygeinic macro中 ... 符号非常特殊，它在match pattern中用来表示一些一类，这样的概念，作为pattern variable的一种。

最后需要注意的是，由于macro是在编译期展开的，定义的helper function必须能够在编译期被访问。(理解：因为通常情况racket没有toplevel的函数定义，而modulelevel在编译期不会求值，所以必须要由个途径在编译期对helper求值。这类似于CL中的eval-when)
这就要求helper function通过begin-for-syntax或者require for-syntax这样的form将其包裹起来，前者类似begin，后者通常是用于将helper function作为独立的module使用时引入。

常用函数：
define-syntaxes, define-syntax, syntax-case, syntax-case*, with-syntax, with-syntax*, syntax-rules, syntax-id-rules
identifiers?, syntax?, syntax, quote-syntax, quasisyntax, unsyntax, unsyntax-splicing, syntax->datum, syntax-e, syntax->list, datum->syntax
syntax-source, syntax-line, syntax-column, syntax-span, generate-temporaries
bound-identifiers=?, free-identifiers=?
set!-transformer?, make-set!-transformer, set!-transformer-procedure, rename-transformer?, make-rename-transformer, rename-transformer-target, local-expand
define-syntax-parameter, syntax-parameterize, splicing-syntax-parameterize, splicing-let-syntax
syntax-property, syntax-property-keys
syntax-arm, syntax-protect, syntax-disarm, syntax-taint, syntax-tainted?
expand, expand-syntax, expand-once, format-id, define-for-syntax, begin-for-syntax, require for-syntax

May 31, 2012 racket的syntax model
racket中reader负责将文本代码转化为syntax object(通常是通过read-syntax)，
而expander主要负责将syntax object进行展开(根据它的binding information)，使得代码达到fully parsed的程度。

展开过程expansion process是由syntax object的绑定binding驱使的，当expander遇到一个绑定binding form的时候，
它会扩展子表达式的syntax object并加入新的绑定信息binding information。

* identifiers binding
  标示符identifiers在racket中可以被理解为代表程序的实体，比如代表某个变量引用，表达式form引用，或者甚至被quoted起来代表symbol或syntax object。（理解：这里的理解identifiers就是symbol或者quoted expressions）
  当一个identifiers bind另外一个identifiers的时候，前者就是后者的variable,后者就是bounded identifiers。
  绑定能够作用的代码构成了绑定的范围scope。一段代码所处在的环境environment就是包围该段代码的所有绑定构成的集合。

  绑定可以分为: top-level, module, local三种。

* phase level
  每个绑定在racket中都有一个phase level。
  模块内部宏展开期的绑定phase level为1, 这些绑定构成的环境叫transformer environment
  模块内部运行期的绑定phase level为0，这些绑定构成的环境叫base environment
  如果一个模块为了自己的phase level 1引入了另一个模块，另一个模块相对以这个模块处于phase level -1，它构成的环境叫template environment。

  local绑定只能在特定的phase level被访问。top-level和module可以构成不同phase的绑定(理解：通过require for-syntax？)

* syntax object
  就是将symbol或者form与lexical information, syntax property, tamper status, src-loc information等信息组合在一起构成的对象。
  特别的讲，identifiers本身就是将symbol与lexical及其他information组合在一起构成的syntax object。

  free-identifiers?用来判断两个identifiers是否有相同的binding
  bound-identifiers?用来判断两个identifiers是否有绑定关系

  每个syntax object有三种tamper状态，tainted, armed, 和clean。
  当处于tainted状态的时候，expander拒绝使用它作为binding或者变量。
  armed状态下，任何使用syntax-e, syntax->datum之类的操作会使得armed变成tainted, 除非先disarm

* Expansion
  展开是递归的针对某个syntax object进行的，起始时的phase level为0. syntax object的lexical information中的binding information会
  驱使展开的进行，并可能将新的binding引入其子表达式的lexical information中。

  只有三种绑定是可能能够继续下去的：
  - transformer binding
  - variable binding
  - core syntactic form

  展开的每一步还和上下文有关，对于transformer和core syntactic form，不同的上下文，展开都可能不同：
  - top-level context 代表top-level
  - module-begin context 代表在module体内唯一的begin form
  - module context 代表在module begin体内
  - internal definition context 代表在define之类的定义内
  - expression context 代表在一般表达式内

* syntax transformer (a.k.a macro)
  当使用define-syntax之类的form的时候，会在phase level 0引入transformer binding，
  如果该绑定是一个单参的procedure的话，那它就是一个syntax transformer。syntax transformer接受一个syntax object， 返回一个syntax object。
  而expander会使用其返回的syntax object继续parse。

  另外对这个单参procedure的求值是需要先展开然后再求值的，但这些都是在phase level 1中进行的。(理解：这就是为什么define-syntax syntax-case的时候，helper function要使用begin-for-syntax引入）

  在expander将一个syntax object传给syntax transformer的时候，这个syntax object是要被syntax mark的，只有当mark和binding都相同的时候，才认为是bound-identifiers?
  （理解：这个mark的过程，就是保证hygeinic macro的过程）

  hygeinic导致的问题是，在输出的syntax object(template)中，引入的变量都会重新命名(或者叫做mark)，使得不会和周围的identifier冲突，但如果需要突破这种hygeinic的限制（某些情况下想要某个id不被hygeinic）
  通常都可以在syntax-case中，使用with-syntax创建固定名称的identifier，或者仍然使用hygeinic但是使用syntax-parameter构成一个dynamically scoped的id。

Jun 1, 2012 SBCL IR1 Conversion	Call Flow
ir1tran.lisp
ir1-translators.lisp
ir1tran-lambda.lisp
main.lisp

	 +---------------------------+		         +-------------------------+-+
	 |             	       	     +--------->---------+ ir1-convert-inline-lambda |
	 |  ir1-convert-lambdalike   |	                 |                           |
	 |                           |    	 +-------+                           |
	 +-----------------------+---+        	 |       +---------------------------+
				 |	         |                                                       	                                    		                                                       							    |               |                       							                                          							                                               |               |
				 |		 |
				 |		 |
			      +--+---------------+----+
			      |                       |
			      |  ir1-convert-lambda   |
			      |                       |
			      +---------+-------------+
					|
					|
				+-------+----------+
				| make-lambda-vars |								+-----------------------------------+
				|                  |								|      	      	   	      	    |
				+-------+----------+								|  process-type-decl	      	    |
					|									|  process-package-lock-decl  	    |
					|									|  process-optimize-decl      	    |
				+-------+----------+				 +-----------------+		|  process-extent-decl	      	    |
				| process-decls    +-----------------------------+  process-1-decl +------------+  process-inline-decl	      	    |
				|                  |	                      	 |                 |		|  process-ignore-decl	      	    |
				+------------------+	            		 +-----------------+		|  process-unmuffle-condition-decl  |
				  +--------------------------------------<--------------------------------------+  process-muffle-condition-decl    |
				  |		                     						|  process-ftype-decl	      	    |
	   +----------------------+----+		    +------------------------------+			|  process-special-decl	      	    |
	   |                   	       |		    |          	       	       	   +-----------<--------+                                   |
	   |  ir1-convert-lambda-body  | 		    |   ir1-convert-hairy-lambda   |           		+-----------------------------------+
	   |                   	       |		    |          	       	       	   |
	   |                   	       |		    |                          	   |
	   +---------------+-----------+		    +--------------------------+---+
			   |							       |
			   |							       |
			   |	     +------<----+				       |
			   |	     |		 |				       |	       +-----<------+
	   +---------------+---------+------+	 |				       |	       |	    |
	   |           	       	      	    |	 ^				  +----+---------------+-------+    ^
	   |           	       	      	    |	 |				  |    	      	               |    |
	   |  ir1-convert-special-bindings  +----|				  |   ir1-convert-hairy-args   +----+
	   |           	       	      	    |					  |                            +-----------------<------------+
	   |                                |					  +-------------------+-------++			      |
	   +--------------+-----------------+							      |	      |				      |
			  |									      |	      +-------->-----------+	      ^
			  |									      |				   |	      |
	   +--------------+-----------------+							      |				   |	      |
	   |                   	       	    |						      +-------+----------+	  +--------+----------+-------------+
	   |  ir1-convert-aux-bindings 	    +---------------+				      |	                 |	  |                            	    |
	   |                   	       	    |		    |				      | ir1-convert-more | 	  | generate-optional-default-entry |
	   +--------------+-----------------+		    |				      |                  |	  |                            	    |
			  |				    |				      +-------+----------+	  +------------------+--------------+
			  |				    |					      |					     |
       +---------+	  |				    |					      |					     |
       | 	 |	  |				    |				     +--------+-------------+    	+------------+--------------+
       ^   +-----+--------+-------------+		  +-+------------------------+	     |  convert-more-entry  |    	|   convert-optional-entry  |
       |   |                            |		  |            	       	     |	     +----------------------+    	+---------------------------+
       +-<-+  ir1-convert-lambda-body   |		  | ir1-convert-progn-body   |
	   |                            |		  |            	       	     |
	   +--------------+-------------+		  +---+----------------------+
			  |				      |
			  |				      |
	   +--------------+-----------------+		      |
	   |  ir1-convert-combination-args  |		  +---+-----------+
	   |           	       	            |		  |            	  |
	   +--------------------------------+		  | ir1-convert	  |-----------------------------+---------------------+-------------------------+
							  |               |				|		      |				|
							  +---+-----------+				|		      |				|
							      | 					|		      |				|
							      | 					|		      |				|
							      |  			    +-----------+--------+    +-------+----------+     +--------+---------------+
							      |  			    |          	         |    |        	       	 |     |       	       	        |
							      |  			    |   ir1-convert-var  |    |  reference-leaf	 |     |   reference-constant   |
							      |  			    |                    |    |        	       	 |     |       	       	        |
							      |  			    +--------------------+    +------------------+     +------------------------+
							      |
					    +-----------------+--------+
					    |          	     	       |
  +-----------------------+                 |   ir1-convert-functoid   +---------------+
  | %%allocate-closures   |		    |                	       |	       |
  | multiple-value-prog1  | 		    +-----+--------------------+      +--------+-----------------+
  | progn                 |                       |                           |   careful-macro-expand   |
  | multipl-value-call    | 			  | 			      |              	         |
  | unwind-protect        | 			  | 			      +--------+-----------------+
  | quote                 | 			  | 				       |
  | function              |    +------------------+-----+	  +--------------------+----------+
  | macrolet              |    |                        |	  |            	       	       	  |
  | eval-when             |    |special-form translator |         |  ir1-convert-common-functoid  +---------------------------------+
  | global-function       +-<--+                        |	  |                    	       	  |				    |
  | let                   |    +------------------------+	  +--------+------------------+---+				    |
  | %funcall              | 						   |		      |					    |
  | %primitive            | 						   |		      |					    |
  | let*                  | 						   |		      |					    |
  | locally               | 						   |		      |					    |
  | flet                  | 			     +---------------------+--------+	   +--+------------------------------+ +----+-----------------+
  | labels                | 			     |             	      	    |	   |                   	    	     | |                      |
  | the	                  |                          |  ir1-convert-global-functoid |      |  ir1-convert-local-combination  | | ir1-convert-srctran  |
  | truly-the             | 			     |             	      	    |	   |                                 | |                      |
  | setq                  | 			     +---+--------------------+-----+	   +---------------+-----------------+ ++-----------+---------+
  | throw                 | 				 |	 	      |				   | 			|	    |
  | %with-cleanup         | 	                         |                    |                +-----------+---------------+	|	    |
  | %escape-fun           |                              |                    |                |  ir1-convert-combination  +--<-+	    |
  | %cleanup-fun          |             +----------------+-----+       +------+-------------+  +------------+--------------+		    |
  | catch                 |	        |                      |       |                    |   	    |				    |
  | if                    |	        |careful-macro-expand  |       |ir1-convert-srctran |   	    |				    |
  | block                 |             |                      |       |                    |  +------------+------------------+	+---+---+------------------------+	    +----------------------------------------+
  | return-from	          |	        |ir1-convert           |       |                    |  |                    	       |	|                                |	    |        	     	              	     |
  | tagbody               |             |                      |       |                    |  |  ir1-convert-combination-args |	|  ir1-convert-maybe-predicate   +----------+ ir1-convert-combination-checking-type  |
  | go                    |	        |                      |       |                    |  |                    	       |	|                                |	    |        	     	              	     |
  | symbol-macrolet	  |	        +----------------------+       +--------------------+  +-------------------------------+	+--------------------------------+	    +----------------------------------------+
  +-----------------------+


注释：
ir1-convert-lambdalike 用于转换lambda, named-lambda, global-function (lambda-with-lexenv)
ir1-convert-special-binding 如果由special binding，该函数会递归的处理每个special var，为每个svar创建special binding的cleanup，如果没有svar，就进入ir1-convert-aux-binding
ir1-convert-aux-binding 处理aux bindings, 对每个aux var创建一层lambda，然后创建一个combination用aux var的value作为参数调用lambda。如果没有aux var， 就进入ir1-convert-progn
ir1-convert-functoid 使用translator处理special form，或者如果碰到编译器宏，展开后使用ir1-convert-common-functoid处理。
ir1-convert-common-functoid 处理除了special form和compiler macro的其他情况。
ir1-convert-combination 处理combination中的fun部分，ir1-convert-combination-args实际创建combination并链接args和fun的lvar。
ir1-convert-srctran处理全局函数，可能进行代码变换（内联处理），或者和普通local combination处理一样（当是notinline的时候）。
ir1-convert-global-functoid 处理任何看上去像是个全局函数调用（没判断出来是个ir1-convert-srctran的情况，或者本身就是个宏的情况），如果是宏，就展开后继续处理，如果是个函数，就如同ir1-convert-src处理。
每个不同的special form translator会进行特别的处理，可能会递归的调用ir1-convert, ir1-convert-lambda（special form: function）等。


Jun 4, 2012 SBCL内部的“函数”
在IR1中函数被存在四种不同的地方：
1. *lexenv*， 通过lexenv-find可以找到这种定义在词法环境中的函数, 多为局部函数
2. *free-funs*, 在*free-funs*中的函数，为全局:defined或者是assumed的函数
3. global-var，这种就是全局的函数了
4. defined-fun，这种是定义在同一个编译块中，并且是expansion或者inline优化选项被声明的全局函数
   (注意，不管是inline还是notinline，只要声明的。)

具体有这么以下几个函数可以取得它们：
find-lexically-apparent-fun  --> find-free-fun  --> find-global-fun
			     	      +-----------> make-defined-fun

另外，在全局info数据库中，函数有三种类型，四种出处：
三种类型是：function, macro, special-from
四种出处是：assumed(还未定义，在一个函数内部调用，可能会产生warning), defined(已经定义出来的), defined-method(由CLOS定义的), declared（可能没有定义出来，但是函数类型已经通过declaim之类声明了）
通过(info :function :where-from <fun name>)取得。

最后，在最早的处理中(ir1-convert-lambdalike)其实有三种不同的lambda:
lambda			--- 普通的lambda， 这个和ANSI标准中的那个相同。
named-lambda 		--- 这个就是附带了一个名字的lambda, defun以及sb-c::%simple-eval都会生成这种lambda。
lambda-with-lexenv 	--- 这个和inline函数有关，当函数声明为inline，并且符合inline条件的时候，编译器需要保存一个inline版本的lambda，所以就会生成一个此类lambda。（生成代码在defun中。）
			    该lambda携带了其所在环境的信息，这包括decl, macro, symbol macro等信息（见maybe-inline-syntactic-closure函数）。

			    
Jun 4, 2012 SBCL INFO数据库
globaldb.lisp文件
INFO数据库提供一个函数接口来访问编译器全局的信息，这些信息可以跨编译访问。

从概念上讲，INFO被划分为class, 每个class再被划分为type, 可以针对某个符号name访问某个class的某个type的信息。
class是一个class-info结构，type是一个type-info结构。
*info-classes*存储所有class的{名字,class-info结构}哈希对。
*info-types*存储每个class的每个type, 并为其每一个分配一个type number(数组索引)。
通过define-info-class和define-info-type，可以添加新的class和info。

全局信息被存储在info-env结构中，*info-environment*中存储了所有{name, class, type}构成可以查询的信息。
通过(info class type name)函数来访问信息，通过(setf info)来存储信息，通过clear-info来清除信息。
常见的class type类型有：

|-----------------------+------------------------------|
| class                 | type                         |
|-----------------------+------------------------------|
| :function             | :type                        |
|                       | :assumed-type                |
|                       | :kind                        |
|                       | :where-from                  |
|                       | :inline-expansion-designator |
|                       | :inlinep                     |
|                       | :source-transform            |
|                       | :macro-function              |
|                       | :compiler-macro-function     |
|                       | :ir1-convert                 |
|                       | :info                        |
|                       | :definition                  |
|                       | :structure-accessor          |
|-----------------------+------------------------------|
| :variable             | :kind                        |
|                       | :always-bound                |
|                       | :type                        |
|                       | :where-from                  |
|                       | :macro-expand                |
|                       | :alien-info                  |
|                       | :documentation               |
|-----------------------+------------------------------|
| :type                 | :kind                        |
|                       | :expander                    |
|                       | :documentation               |
|                       | :translator                  |
|                       | :builtin                     |
|                       | :compiler-layout             |
|                       | :lambda-list                 |
|                       | :source-location             |
|-----------------------+------------------------------|
| :typed-structure      | :info                        |
|                       | :documentation               |
|-----------------------+------------------------------|
| :declaration          | :recognized                  |
|                       | :handler                     |
|-----------------------+------------------------------|
| :alien-type           | :translator                  |
|                       | :definition                  |
|                       | :struct                      |
|                       | :union                       |
|                       | :kind                        |
|                       | :enum                        |
|-----------------------+------------------------------|
| :setf                 | :inverse                     |
|                       | :documentation               |
|                       | :expander                    |
|-----------------------+------------------------------|
| :random-documentation | :stuff                       |
|-----------------------+------------------------------|
| :source-location      | :variable                    |
|                       | :constant                    |
|                       | :typed-structure             |
|                       | :symbol-macro                |
|-----------------------+------------------------------|

Jun 6, 2012 有趣的递归、迭代
1. 阴阳问题

(let* ((yin
        ((lambda (cc)
           (display #\@) cc)
         (let/cc c
           c)))
       (yang
        ((lambda (cc)
           (display #\#) cc)
         (let/cc c
           c))))
  (yin yang))

这段代码会不停的输出@#@##@###@####@#####......下去，
通过分析，运行的过程如同：
(yin yang)	输出@#
(yang yang')  	输出@#
(yin yang')   	输出#
(yang' yang'')	输出@#
(yang yang'') 	输出#
(yin yang'')  	输出#
(yang'' yang''')输出@#
(yang' yang''')	输出#
(yang yang''')	输出#
(yin yang''')	输出#
。。。。

理解这段代码的关键点在于理解每一次yang的continuation保存了该次对应的yin，只有yang对应的是yin, ying'以后的对应的都是实际上的yang。
所以就形成了一种循环的关系。

2. 尾递归与迭代不变式
loop invariant是用来研究迭代正确性的理论。loop invariant theorem说不变式在迭代前若为真，则在迭代后仍为真,并且在迭代的每一步都为真。
一般，递归变换成尾递归的关键就是寻找这个不变式，通过将不变式的计算在递归前完成就可以达实现尾递归。

比如下面三种不同的尾递归乘方算法：
;x^n => x*x*x...x 乘以n次， 不变式是x^(i+1) = x^i * x
(define (fast-exp-iter-v1 x n)
  (define depth 0)
  (define (iter x n r)
    (set! depth (+ depth 1))
    (cond ((= n 0) r)
          (else (iter x (- n 1) (* r x)))))
  (display (iter x n 1))
  (newline)
  (display depth)
  (newline))

;利用一个不变式是当n为2的整数倍时，x^n => x^2i => (x^2)^i => x^2*x^2*x^2...*x^2 乘以i次, 利用不变式x^2^(i+1) = x^2^i * x^2
(define (fast-exp-iter-v2 x n)
  (define depth 0)
  (define (iter x n r)
    (set! depth (+ depth 1))
    (cond ((= n 0) r)
          ((even? n) (iter (* x x) (/ n 2) r))
          (else (iter (* x x) (/ (- n 1 ) 2) (* r x)))))
  (display (iter x n 1))
  (newline)
  (display depth)
  (newline))

;该版本和上面的版本类似，只是在奇数倍时不变换。
(define (fast-exp-iter-v3 x n)
  (define depth 0)
  (define (iter x n r)
    (set! depth (+ depth 1))
    (cond ((= n 0) r)
          ((even? n) (iter (* x x) (/ n 2) r))
          (else (iter x (- n 1) (* r x)))))
  (display (iter x n 1))
  (newline)
  (display depth)
  (newline))

好好体会不变式的感觉，有助于编写更好的尾递归函数。

Jun 6, 2012 SBCL IR1对&optional, &rest, &key, &aux, special var的处理变换结果：

- 对于&optioanl, &rest, &key都是用optional-dispatch代替了原有的函数,(ir1-convert-hairy-args中完成)
  并生成了多个可接受不同参数个数的entry functional，比如

(lambda (a &optional b (c cd cs)) body)，生成的结果是:

	optional-dispatch: main, entries, more-entry
	main: (lambda (a b c cs) body)

	entry-optional1: (lambda (a b c)
	     	            (funcall
         	               (lambda (a b c cs) body)
		                  a b c t))

	entry-optional2: (lambda (a b)
			    (funcall
			       (lambda (a b c cs) body)
			          a b cd nil))

	entry-optional3: (lambda (a)
			     (funcall
			        (lambda (a b) body)
			           a nil))

  如果还有个&rest d参数，那么还会多一个more entry，并且，main entry也会随之被修改：
        main: (lambda (a b c cs &aux (keyword arg bindings) ...) body)
	
	entry-more: (lambda (a b c restcontext)
		       (loop-cond for analyzing keyword args and later
                          (funcall
			     (lambda (a b c cs &aux (keyword arg bindings) ...) body)
			        a b c t)))

- 对于&aux来说，其实它不是参数，而是额外的绑定，变换后成为一层一层的lambda和combination对(ir1-convert-aux-bindings中完成)

(lambda (a b &aux (c 1) (d 2)) body)，生成的结果是：

	(lambda (a b)
	   (funcall
	      (funcall
	         (lambda (c)
		    (lambda (d) body)) 
                 1)
	      2))

	
- 最后special var，会加入额外的cleanup code，并将其注册到当前的lexenv中：

(lambda (a b c) body),如果b为special var，那么变换后的结果是：

	(lambda (a b c)
		(%special-bind specvar-b b)
		(%cleanup-point)
		body)

Jun 7, 2012 On Lisp Notes
Chapter 2. Functions
--------------------------------------------------------------------------------
1. Common Lisp has distinct name-spaces for variables and functions. (P12)

2. A difference between lexical and dynamic scope comes down to how an
   implementation deals with free variables. (P16)

3. Closure are functions with local state. (P18)

4. A function which isn't tail-recursive can often be transformed into one
   that is by embedding in it a local function which uses an accumulator.
   In this context, an accumulator is a parameter representing the value
   computed so far. (P23)

5. However, calling compile explicitly is a drastic measure, comparable to
   calling eval, and should be viewed with the same suspicion. (P25)

6. There are two sorts of functions which you can't give as an argument to
   compile. ... , you can't compile a function "defined interpretively in
   a non-null lexical environment." ... . You also can't call compile on
   a function which is already compiled. ... "the consequences...are unspecified". (P25)

Chapter 3. Functional Programming
--------------------------------------------------------------------------------
1. Functional programming means writing programs which work
   by returnning values instead of by performing side-effects. (P28)

2. An imperative program is a functional program turned inside-out.
   An functional program is a imperative program turned outside-in. (P34)

3. Instead of treating all side-effects as equally bad, ... , we could
   say that it's harmless for a function to modify something that no
   one else own. 
   ...
   In the general case, we have to talk about ownership not by functions,
   but by invocations of functions. 
   ...
   The convension in Lisp seems to be that an invocation owns objects
   it receives as return values, but not objects passed to it as arguments.
   ...
   To write programs that are really indistinguishable from functional code,
   we have to add one more condition. Functions can't share objects with
   other code that doesn't follow the rules.
   ...
   A corollary of the convertion above is that functions shouldn't return
   anything that isn't safe to modify. Thus one should avoid writing functions
   whose return values incorporate quoted objects.

Chapter 4. Function Utilities
--------------------------------------------------------------------------------
1. Learning to write utilities would be better described as learning the habit of
   writing them, rather than the technique of writing them. (P41)

2. One of the unique characteristics of Lisp programming is the important role of
   functions as arguments. This is part of why Lisp is well-adapted to bottom-up
   programming. It's easier to abstract out the bones of a function when you can
   pass the flesh back as a functional argument. (P42)

3. If brevity is the soul of wit, it is also, along with the efficiency, the essence
   of good software. ... All other things being equal, the shorter program is the
   better. (P43)

4. a new utility must be written for the general case, not just for the problem at
   hand. Finally, like any capital expenditure, we need not be in a hurry about it. (P43)

5. In any language, the "tendency towards brevity" will cause trouble unless it is
   allowed to vent itself in new utilities. The shortest idioms are rarely the most
   efficient ones. ... it's especially important to write utilities for situations
   we might otherwise handle inefficiently. A language augmented with the right utilities
   will lead us to write more abstract programs. If these utilities are properly defined,
   it will also lead us to write more efficient ones. (P44)

6. So yes, reading a bottom-up program requires one to understand all the new operators
   defined by the author. But this will nearly always be less work than having to understand
   all the code that would have been required without them. 
   ...
   Bottom-up programming makes what would otherwise be a large program look like a small,
   simple one. This can give the impression that the program doesn't do much, and
   should therefore be easy to read. When inexperienced readers look closer and find
   that this isn't so, they react with dismay.
   ...
   Bottom-up programs are conceptually denser.(P60)

7. in a small program, a utility might not be used enough to justify including it. (P60)

Chapter 5. Returning Functions
--------------------------------------------------------------------------------
1. By defining functions to build and return new functions, we can magnify the effect
   of utilities which take functions as arguments. (P61)

2. Scheme was the first Lisp to make functions lexical closures, and it is this which
   makes it interesting to have functions as return values. (P62)

3. However, returning constant functions is the limit of what we can do with dynamic scope.
   ...
   Under lexical scope, instead of merely choosing among a group of constant functions,
   we can build new closures at runtime. With dynamic scope this technique is impossible. (P61-62)

4. Being able to pass functions as arguments is a powerful tool for abstraction.
   The ability to write functions which return functions allows us to make the most
   of it. (P62)

5. An orthogonal language is one in which you can express a lot by combining a small
   number of operators in a lot of different ways. (P63)

   "e.g. complement to *-if-not functions, setf to reading/writing datas"

6. If some function is expensive to compute, and we expect sometimes to make the
   same call more than once, then it pays to memorize: to cache the return values
   of all the previous calls, and each time the funciton is about to be called, to
   look first in the cache to see if the value is already known. (P65)
   
7. The complement of a function f is denoted ~f. Another Common operation on functions
   is composition, denoted by the operator o.
   ...
   All the functions given as arguments to compose must be functions of one argument,
   except the last. (P66)

8. Expressing functions by calls to constructors instead of sharp-quoted lambda-expressions could,
   unfortunately, entail unnecessary work at runtime. ...
   By using #., the sharp-dot read macro, we can have the new functions built at read-time. (P75)

Chapter 6. Functions as Representation
--------------------------------------------------------------------------------
1. Generally, data structures are used to represent. ... In Lisp we can sometimes
   use closures as a representation. With a closure, variable bindings can store
   information and can also play the role that pointers play in constructing complex
   data structures. By making a group of closures wich share bindings, or can refer
   to one another, we can create hybrid objects which combine the advantage of data
   structures and programs.
   Beneath the surface, shared bindings are pointers. Closures just bring us the 
   convenience of dealing with them at a higher level of abstraction. ... we can often 
   expect substantial improvements in elegance and efficiency. (P76)

2. Closures have three useful properties: they are active, they have local state, and
   we can make multiple instances of them. (P76)

3. Many programs involving networks can be implemented by compiling the nodes into
   closures. Closures are data objects, and they can be used to represent things just
   as structures can. Doing so requires some unconventional thinking, but the rewards
   are faster and more elegant programs. 
   Macros help substantially when we use closures as representations. "To represent
   with closures" is another way of saying "to compile," and since macros do their work
   at compile-time, they are a natural vehicle for this technique. (P81)


Sightworthy code
--------------------------------------------------------------------------------
1. defun same as setf symbol-function

(defun frob () ...) = (setf (symbol-function 'frob) (lambda () ...))

2. compiled defun same as compile

(defun frob () ...) = (compile 'frob (lambda () ...))

3. Utilities

   a. Operation on Lisst
      
      (defun last-car (lst)
		(car (last lst)))

      (defun singleton (lst)
		(and (consp lst) (null (cdr lst))))

      (defun appendr (lst obj)
		(append lst (list obj)))
					
      (defun nconcr (lst obj)
		(nconc lst (list obj)))

      (defun ensure-list (obj)
		(if (listp obj) obj (list obj)))

      (defun longer (x y)
		(labels ((compare (x y)
			   (and (consp x)
				(or (null y)
				    (compare (cdr x) (cdr y))))))
		  (if (and (listp x) (listp y))
		      (compare x y)
		      (> (length x) (length y)))))

      (defun filter (fn lst)
		(let ((acc nil))
		  (dolist (x lst)
		    (let ((val (funcall fn x)))
		      (if val 
			  (push val acc))))
		  (nreverse acc)))		      

      (defun group (source n)
		(if (zerop n) (error "zero length"))
		(labels ((rec (source acc)
			   (let ((rest (nthcdr n source)))
			     (if (consp rest)
				 (rec rest (cons (subseq source 0 n) acc))
				 (nreverse (cons source acc))))))
		  (and source (rec source nil))))

      (defun flatten (x)
		(labels ((rec (x acc)
			   (cond ((null x) acc)
				 ((atom x) (cons x acc))
				 (t (rec (car x) (rec (cdr x) acc))))))
		  (rec x nil)))

      (defun prune (test tree)
		(labels ((rec (tree acc)
			   (cond ((null tree) (nreverse acc))
				 ((consp (car tree)) (rec (cdr tree)
							  (cons (rec (car tree) nil) acc)))
				 (t (rec (cdr tree) (if (funcall test (car tree))
							acc
							(cons (car tree) acc)))))))
		  (rec tree nil)))

   
   b. Search
   
      (defun find2 (fn lst)
		(if (null lst)
		    nil
		    (let ((val (funcall fn (car lst))))
		      (if val
			  (values (car lst) val)
			  (find2 fn (cdr lst))))))   
      
      (defun before (x y lst &key (test #'eql))
		(and lst
		     (let ((first (car lst)))
		       (cond ((funcall test y first) nil)
			     ((funcall test x first) lst)
			     (t (before x y (cdr lst) :test test))))))
      
      (defun after (x y lst &key (test #'eql))
		(let ((rest (before y x lst :test test)))
		  (and rest (member x rest :test test))))

      (defun duplicate (obj lst &key (test #'eql))
		(member obj (cdr (member obj lst :test test)) :test test))


      (defun split-if (fn lst)
		(let ((acc nil))
		  (do ((src lst (cdr src)))
		      ((or (null src) (funcall fn (car src)))
		       (values (nreverse acc) src))
		    (push (car src) acc))))


      (defun most (fn lst)
		(if (null lst)
		    (values nil nil)
		    (let* ((win (car lst))
			   (max (funcall fn win)))
		      (dolist (obj (cdr lst))
			(let ((score (funcall fn obj)))
			  (when (> score max)
			    (setq win obj
				  max score))))
		      (values win max))))

      (defun best (fn lst)
		(if (null lst)
		    nil
		    (let* ((win (car lst)))
		      (dolist (obj (cdr lst))
			(if (funcall fn obj win)
			    (setq win obj)))
		      win)))

   c. Mapping

      (defun map0-n (fn n)
             (mapa-b fn 0 n))

      (defun mapa-b (fn a b &optional (step 1))
             (do ((i a (+ i step))
                  (restul nil))
                 ((> i b) (nreverse result))
                 (push (funcall fn i) result)))

      (defun map-> (fn start test-fn succ-fn)
             (do ((i start (funcall succ-fn i))
	          (result nil))
                 ((funcall test-fn i) (nreverse result))
                 (push (funcall fn i) result)))

      (defun mappand (fn &rest lsts)
             (apply #'append (apply #'mapcar fn lsts)))

      (defun rmapcar (fn &rest args)
             (if (some #'atom args)
                 (apply fn args)
                 (apply #'mapcar
                        #'(lambda (&rest args)
                             (apply #'rmapcar fn args))
                        args)))

   d. I/O

      (defun prompt (&rest args)
            (apply #'format *query-io* args)
            (read *query-io*))

   e. Symbols and Strings

      (defun mkstr (&rest args)
        (with-output-to-string (s)
           (dolist (obj args) (princ obj s))))

      (defun symb (&rest args)
        (values (intern (apply #'mkstr args))))

      (defun reread (&rest args)
        (values (read-from-string (apply #'mkstr args))))

4. Unify destructuring and non-destructuring interface (better orthogonality)
   Utilities:
   (defvar *!equivs* (make-hash-table))
   (defun ! (fn)
   	  (or (gethash fn *!equivs*) fn))
   (defun def! (fn fn!)
          (setf (gethash fn *!equivs*) fn!))

   Usage Code:	  
   (def! #'remove-if #'delete-if)
   (funcall (! #'remove-if) #'oddp lst)
   
5. Memoizing results
   (defun memoize (fn)
      (let ((cache (make-hash-table :test #'equal)))
         #'(lambda (&rest args)
              (multiple-value-bind (val win) (gethash args cache)
                 (if win
                     val
                     (setf (gethash args cache)
		           (apply fn args)))))))

6. Composing functions
   (defun compose (&rest fns)
   	  (if fns
	      (let ((fn1 (car (last fns)))
	      	    (fns (butlast fns)))
		    #'(lambda (&rest args)
		          (reduce #'funcall fns
			          :from-end t
                                  :initial-value (apply fn1 args))))
              #'identity))

    (defun complement (pred)
          (compose #'not pred))

    (defun fif (if then &optional else)
          #'(lambda (x)
               (if (funcall if x)
                   (funcall then x)
                   (if else (funcall else x)))))

    (defun fint (fn &rest fns)
          (if (null fns)
              fn
              (let ((chain (apply #'fint fns)))
                 #'(lambda (x)
                      (and (funcall fn x) (funcall chain x))))))

    (defun fun (fn & rest fns)
          (if (null fns)
              fn
              (let ((chain (apply #'fun fns)))
                 #'(lambda (x)
                      (or (funcall fn x)  (funcall chain x))))))

7. Recurser
   (defun trec (rec &optional (base #'identity))
          (labels ((self (tree)
                     (if (atom tree)
                         (if (functionp base) 
                             (funcall base tree)
                             base)
                         (funcall rec tree #'(lambda () (self (car tree)))
                                           #'(lambda () (if (cdr tree) (self (cdr tree))))))))
                  #'self))

8. Compiling networks

   (defvar *nodes* nil)
   (defun defnode (&rest args)
   	  (push args *nodes*)
	  args)
   (defun compile-net (root)
          (let ((node (assoc root *nodes)))
	       (if (null node)
	           nil
                   (let ((conts (second node))
		         (yes (third node))
			 (no (fourth node)))
			(if yes ; 
			    (let ((yes-fn (compile-net yes))
                                  (no-fn (compile-net no)))
                                #'(lambda ()
                                      (format t "~a~%>>" conts)
                                      (funcall (if (eq (read) 'yes)
                                                   yes-fn
                                                   no-fn))))
                            #'(lambda () conts))))))

  
  Usage code:
  (defnode 'people "Is the person a man?" 'male 'female)
  (defnode 'male "Is he living?" 'liveman 'deadman)
  ...

Jun 7, 2012 TLS & TSS Notes
The Little Schemer
--------------------------------------------------------------------------------
The First Commandment (P22)
    (preliminary)
    Always ask null? as the first question in epxressing any function.

The Second Commandment (P37)
    Use cons to build lists.

The Third Commandment (P45)
    When building a list, describe the first typical element,
    and then cons it onto the natural recursion.

The Fourth Commandment (P57)
    (priliminary)
    Always change at least one argument while recurring. It
    must be changed to be closer to termination. The changing
    argument must be tested in the termination condition:
    when using cdr, test termination with null?

The First Commandment (P64)
    (first revision)
    When recurring on a list of atoms, lat, ask two questions about it:
    (null? lat) and else.
    When recurring on a number, n, ask two questions about it:
    (zero? n) and else.

The Fourth Commandment (P65)
    (first revision)
    Always change at least onw argument while recurring. It must be changed to 
    be closer to termination. The changing argument must be tested in termination
    condition:
    when using cdr, test termination with null? and
    when using sub1, test termination with zero?.

The Fifth Commandment (P67)
    When building a value with +, always use 0 for the value of the terminating line, 
    for adding 0 does not change the value of an addition.    
    When building a value with *, always use 1 for the value of the terminating line,
    for multiplying by 1 does not change the value of a multiplication.
    When building a value with cons, always consider () for the value of terminating line.

The First Commandment (P83)
    (final revision)
    When recurring on a list of atoms, lat, ask two questions about it:
    (null? lat) and else.
    When recurring on a number, n, ask two questions about it:
    (zero? n) and else.
    When recurring on a list of S-expressions, l, ask three question about it:
    (null? l), (atom? (car l)) and else.

The Fourth Commandment (P84)
    (final revision)
    Always change at least one argument while recurring. When recurring on a list of atoms,
    lat, use (cdr lat). When recurring on a number, n, use (sub1 n). And when recurring on
    a list of S-expressions, l, use (car l) and (cdr l) if neither (null? l) nor (atom? (car l))
    are true.
    It must be changed to be closer to termination. The changing argument must be tested in
    the termination condition.
    when using cdr, test termination with null? and
    when using sub1, test termination with zero?.

The Sixth Commandment (P93)
    Simplify only after the function is correct.

The Seventh Commandment (P103)
    Recur on the subparts that area of the same nature:
    - On the sublists of a list.
    - On the subexpression of an arithmetic expression.

The Eighth Commandment (P107)
    Use help functions to abstract from representations.

The Ninth Commandment (P133)
    Abstract common patterns with a new function.

The Tenth Commandment (P140)
    Build functions to collect more than one value at a time.
    
The Seasoned Schemer
--------------------------------------------------------------------------------
The Eleventh Commandment (P11)
    Use additional arguments when a function needs to know what other arguments to the
    function have been like so far.

The Twelfth Commandment (P22)
    Use (letrec ...) to remove arguments that do not change for
    recursive applications.

The Thirteenth Commandment (P31)
    Use (letrec ...) to hide and to protect functions.

The Fourteenth Commandment (P44)
    Use (letcc ...) to return values abruptly and promptly.

The Fifteenth Commandment (P69)
    (priliminary version)
    Use (let ...) to name the values of repeated expressions.

The Fifteenth Commandment (P74)
    (revised version)
    Use (let ...) to name the values of repeated expressions in a function definition
    if they may be evaluated twice for one and the same use of the function.

The Sixteenth Commandment (P98)
    Use (set! ...) only with names defined in (let ...)s.

The Eighteenth Commandment (P104)
    Use (set! x ...) only when the value that x refers to is no longer needed.

The Nineteenth Commandment (P112)
    Use (set! ...) to remember valuable things between two distinct uses of a function.

The Twentieth Commandment (P160)
    When thinking about a value created with (letcc ...), write down the function
    that is equivalent but does not forget. Then, when you use it, remember to forget.

Sightworthy code
--------------------------------------------------------------------------------
1. 3x+1 problem

(define 3x+1
  (lambda (n)
    (letrec ((C (lambda (n d)
                  (cond
                    ((= n 1) 
                     (displayln d)
                     'convergent)
                    (else
                     (cond
                       ((even? n) (C (/ n 2) (add1 d)))
                       (else (C (add1 (* 3 n)) (add1 d)))))))))
      (C n 0))))

2. Ackermann Function

(define ackermann
  (lambda (n m)
    (cond
      ((zero? n) (add1 m))
      ((zero? m) (ackermann (sub1 n) 1))
      (else
       (ackermann (sub1 n)
                  (ackermann n (sub1 m)))))))

3. Tail recursion with collector

(define copy-tree-nt
  (lambda (tree)
    (cond ((null? tree) tree)
          ((not (or (pair? (car tree))
                    (null? (car tree))))
           (cons (car tree) (copy-tree-nt (cdr tree))))
          (else
           (cons (copy-tree-nt (car tree))
                 (copy-tree-nt (cdr tree)))))))

(define copy-tree
  (lambda (tree)
    (letrec ((cp (lambda (t col)
                   (cond ((null? t) (col t))
                         ((not (or (pair? (car t))
                                   (null? (car t))))
                          (cp (cdr t)
                              (lambda (st)
                                (col (cons (car t) st)))))
                         (else
                          (cp (car t)
                              (lambda (a-st)
                                (cp (cdr t)
                                    (lambda (d-st)
                                      (col (cons a-st d-st)))))))))))
      (cp tree identity))))

4. Halting problem

(define will-stop?
  (lambda (proc)
    ...))

(define eternity
  (lambda (x)
    (eternity x)))

(define last-try
  (lambda (x)
    (and (will-stop? last-try)
         (eternity x))))

5. Applicative-order Y-combinator

(define Y
  (lambda (one-step)
    ((lambda (f) (f f))
     (lambda (f)
       (one-step (lambda (x) ((f f) x)))))))

(define length-one-step
  (lambda (length)
    (lambda (l)
      (cond ((null? l) 0)
            (else (add1 (length (cdr l))))))))

(define length (Y length-one-step))

6. Functional cons

- immutable cons

(define cons
  (lambda (car cdr)
    (lambda (selector)
      (selector car cdr))))

(define car
  (lambda (cons)
    (cons (lambda (car cdr) car))))

(define cdr
  (lambda (cons)
    (cons (lambda (car cdr) cdr))))

- mutable cons

(define cons-car-on-empty
  (lambda (car)
    (let ((cdr empty))
      (lambda (selector)
        (selector (lambda (new-cdr) (set! cdr new-cdr)) car cdr)))))

(define set-cdr!
  (lambda (cons new-cdr)
    ((cons (lambda (set-cdr! car cdr) set-cdr!)) new-cdr)))

(define cons
  (lambda (car cdr)
    (let ((cons (cons-car-on-empty car)))
      (set-cdr! cons cdr)
      cons)))

(define car
  (lambda (cons)
    (cons (lambda (set-cdr! car cdr) car))))

(define cdr
  (lambda (cons)
    (cons (lambda (set-cdr! car cdr) cdr))))

Jun 13, 2012 Git plumbing commands
- Git main structure
  .git/objects for 3 Objects: Blob, Tree, Commit
  .git/refs for 3 Refs: head, tag, remote           (reference to commit object or other refs)
  .git/HEAD for symbolic reference to .git/refs/heads/master
  .git/index for staging area
  .git/hooks for hook scripts
  .git/config for local config
  .git/info for keep ignored files and packfiles
  .git/pack-refs packed refs
  .git/log	 storing reflogs information, if delete, git reflog will show nothing.
  .git/refs/remotes/origin/ the refs here is the same as the refs in remote's .git/refs/heads/  see refspec

- Plumbing commands
echo <content> | git hash-object -w --stdin    Store plan blob object
git cat-file -p <objects' SHA-1>               View object content
git cat-file -p master^{tree}                  View tree object last commit object pointint to
git cat-file -t <objects' SHA-1>	       View object type
git update-index --add <file>		       Add new file to staging area
git update-index --add --cacheinfo <100644|120000|100755> <SHA-1> <file>  Add blob to staging area
git write-tree	       		   	       Write staging area to a tree object
git read-tree <tree SHA-1>		       Read a tree to staging area
echo "commit msg" | git commit-tree <tree SHA-1> Create a commit object pointing to specified tree
git update-refs <refs/path> <commit SHA-1>	 Create a refs to a commit
git symbolic-ref <refs path>	    		 Find the target of the symbolic reference
git gc --auto	       				 Collect loose objects and make packfiles
git verify-pack -v <path/to/packfile>		 Look into packed objects in a packfile
git reflog	   				 HEAD change history, useful when recover some lost commit or HEAD
git log -g					 like git reflog but more information
git fsck --full					 show dangling commit, useful when reflog has nothing to tell you.
git count-objects				 count size and objects
git rev-list --objects				 list all chronological commits and its related files
git filter-branch --index-filter "filter commands" -- <commit SHA>^..  do filter on each commit since specified one.
git rev-parse	  		 	 	 show the commit the ref pointing to
git ls-tree <treeish>				 list content of tree

- refspecs
  format [+]<remote's refs/heads/>:<local's refs/remotes/origin/>
  + is optional and refers to forcibly fetch even non-fastforward.
  
git fetch origin <refspecs> [\ <refspecs]...    Fetch remotes according to refspecs
git push origin <refspecs>     			Push to remotes according to refspecs
git push origin :<remote refs>			Delete remotes' refs

Jun 13, 2012 Git　常用命令和revision selection
git clean -ffxd 删除目录中没有track的文件，包括ignored那些
rm -rf * && git reset --hard  清空工作目录并重新从repo中取得HEAD
git archive --format=tar <refs>:<tree path> 对某个ref的某个目录下的文件打包
git blame 查看每一行代码都是谁改的
git branch --merged 查看已经合并过的分支，可以删除它了意味着。
git show <object>   显示对象

版本指定
revision 可以是 commit或者ref
revision^ 显示早它前一个的revision的第一个parent
revision^2 早它前一个的revision的第二个parent
revision~ 显示早它前一个的revision的第一个parent
revision~3 显示早它前三个的revision的第一个parent
ref@{<time> or <order>} 显示引用日志中的引用以前的历史，这对于HEAD来说比较有用。

提交范围
refa..refb 所有在refb中，但不在refa中的提交
^refa 所有不在refa中的提交
refa...refb 被两者包含，但又不同时在两者中的提交
Jul 20, 2012 修改mysql管理员密码
方法一：
$ mysqladmin -u root NEWPASSWORD
或者
$ mysqladmin -u root -p'oldpassword' password NEWPASSWORD

方法二：
1) Login mysql server
$ mysql -u root -p

2) Use mysql database
mysql> use mysql;

3) Change password
mysql> update user set password=PASSWORD("NEWPASSWORD") where user='root';

4) Finally, reload the privildegs;
mysql> flush privileges;
mysql> quit;

Jul 20, 2012 mysql 常用命令
help 列出帮助
     - help show;
show 显示状态
     - show tables;
     - show databases;

Jul 23, 2012 Racklog语言 和 Datalog语言 以及 Production system
Racklog是Racket语言中支持prolog风格的逻辑编程范式的语言。
它除了支持racket的对象外，还有两类特殊的对象，就是目标goal和断言predicate。

目标是可以判别真假性的对象，基本对象是%true和%fail，
通过%which和%more可以判断一个goal的真假。

断言是用来构建目标的对象，当把断言作用于其他对象时就创建了一个对象（断言类似于一个函数）。
基本的断言有%=!=, %<, %>等算数断言，%is支持使用普通的racket表达式作为断言， %member判断成员的断言，
%constant， %compound对象类型断言，%and, %or 组合断言。

Racklog中的断言不同于Racket断言的一点是它产生的是目标，而不是真假值。
通常可以使用%rel关系来创造新断言，可以创造fact或者rule两类。

在逻辑推演过程中Unification的目的就是匹配输入查询和目标语句左式，只有当匹配的时候，才会
继续subgoal的推演。判断匹配的时候，总有一些未被绑定的逻辑变量，这些变量在这个时候就
必须绑定到左式的某些值上，这个过程就是Unification。这有点类似于racket中的match作的事情。
racklog提供了一个断言%=来完成Unification的过程，因此Unification其实也是一类目标。而且
是在推演中非常基本的一类目标。（因为推演过程就是目标-子目标的一级一级拆分，而Unification在其中
起到了粘合剂的作用）

cut目标用来去除后续不必要的查询或者逻辑推演过程。它的返回类似于一个%true目标，但是在这之后将不再会有%more。
可以把它想象成在一个树上作元素查找，当找到某个后面有cut的匹配元素后，这个查找就将结束，不会继续后续的查找过程。
cut通常比较危险，所以一般隐藏在一些construct之后，比如%if-then-else，或者%not
e.g.
(define %if-then-else
  (%rel (p q r)
    [(p q r) p ! q]
    [(p q r) r]))

这个断言是个接受断言的断言。因此不属于first-order。

(define %not
  (%rel ()
    [(g) g ! %fail]
    [(g) %true]))

注意这种 ! %fail 用法，它是让cut返回%fail的common idiom。

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Datalog是一种基于逻辑范式的声明式语言又是一个推演数据库系统。它既可以用于查询，也可以直接加入新的规则更新数据库。
它的语法是prolog语言语法的子集。它可以根据显示Explicit的Fact和隐含Implicit的Rule来完成对数据库查询的推演。

在datalog中，一个literal就是一个predicate(字符串或者标示符)加上括号后面跟着逗号分割的term，
term可以是变量(大写字母开头)或者常量（字符串或者标示符）。

一个clause就是由左式literal :- 右式literals ...构成的语句，没有右式的语句就是fact，有右式的语句就是rule
对于一个clause变成一条statement只要给其后加上. ? 或者~即可。.表示assert，即加入一条clause到数据库中。
~表示retraction将clause从数据库中去除。而? - query则是对数据库进行查询。

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Production System是一类提供某种形式人工智能的系统，它由描述了系统行为的规则rules构成，。
规则正式称为productions，由两部分组成：前提条件precondition和动作action。如果一个前提条件满足了
世界的当前状态(the current state of the world)，该条规则就被触发trigger，如果规则的action被执行
就说这个规则被发动fire。通常production system都有一个数据库，称为working memory，包含当前状态或知识，
而动作通常会改变这个working memory。

Jul 23, 2012 CLIM中的重要概念

CLIM 是一个分层的GUI toolkit。
顶层通常由frames, panes, gadgets这些与传统视窗系统中概念相类似的内容构成。
在该层之下，则是由command, presentation, stream, sheet, medium, output recording这些更加基本的概念构成。

- sheet, stream, medium

  sheet在CLIM中是基本的类视窗对象，它主要有两个性质：区域region和相对父sheet的坐标系统的坐标系统变换transformation。
  stream扩展了sheet(可以理解为sheet的子类)，除了上述性质外，它还包括了诸如当前光标位置(current cursor position)这类状态。

  medium在CLIM中是基本的画图对象，相当于画板的概念。它有如下属性：画图平面drawing plane，medium的前后景foreground/background，
  画图墨水drawing ink，变换transformation，剪裁区域clipping region，线风格line style，文本风格text style等。
  
  通常支持描画的sheet或stream都有一个medium对象。

- input-context
  
  就是某种要求用户输入，并对用户输入的内容加以限制的上下文。这种限制是通过presentation-type来实现的。
  通常使用with-input-context来创建input-context，而accept, accept-for-string, command的输入参数,
  define-application-frame都是创建input-context的common idiom和应用场景。

- presentation, presentation translator, command, command-table

  - presentation

    presentation是CLIM中的核心概念。

    传统的GUI toolkit通常只包含了有限对象(button, checkbox之类)的图形化表示，而CLIM提供了更高级的抽象，它可以将应用程序的业务逻辑
    application business logic中的任何对象（比如某个业务系统中的“会员”对象）图形化表示出来，这个就是presentation的作用。

    presentation通过presentation-type将GUI在画图平面上的描画结果与应用程序内的对象相联系。这样画出的图形就是应用程序内部对象的外在的图形化表现。
    CLIM中提供了基本的presentation-type，而每个通过defclass产生的新类都有与自己对应的presentation-type。

    通过presentation-type，诸如command或者accept这类要求用户输入的construct
    (提供了某种上下文敏感的input-context，即只有与之要求的presentation-type相一致的对象（的图形表示）才可以作为输入），就可以直接以
    这些（对象或者）它的图形表示作为输入了。

  - command
    传统的GUI toolkit是基于事件驱动的模型，而CLIM通常情况下程序员不需要关心事件驱动，因为它在底层。
    CLIM中的command是比事件驱动更加抽象的一个概念。它表示的是对用户交互的反应，对业务逻辑的更新操作，(可以把它理解为一个能与人交互的函数)。
    command是在以presentation-type为'command'的对象作为要求输入的command-loop中被执行的，即command对象也是有自己的presentation-type的，
    在被要求自己的input-context中被获取，被执行。它也被纳入CLIM基本的input-context和presentation的概念中。（这个对后续理解presentation translator很重要），
    另外，command本身可能要求一些参数这些参数需以presentation-type作为限定，这就构成了这个command的input-context。

    command的外在表现形式，即交互风格是与它具体动作执行分开的，每个command都可以有四种不同的交互风格：
    - 用鼠标操作menu或者dialog,
    - 用快捷键keystroke,
    - 用鼠标和command translator交互，
    - 从命令行command-line通过键盘输入。
  
  - command-table就是将command， command的交互风格， input-context（accept, top-level app frame）相联系的对象。
    command-table可以以继承方式将若干command-table构建成更大的command集合。

    每个input-context都可以有某个command-table，每个command-table中，都包含有若干command，每个command都可以不止一次出现在command-table中，
    并拥有不同的style。

    define-application-frame会默认创建一个command-table和command-definer用于增加在其input-context下的command。

  - presentation translator
    通常情况下，CLIM中除了command以外的presentation都是作为command的参数的。而业务逻辑的动作都靠command来完成，
    如果你想实现点击某个“会员”的图标就显示他的详细信息这样简单了当的动作就必须使用presentation translator。
    
    对presentation translator的简单理解就是它能把input-context中对某个presentation的要求转化为对另一个presentation的要求。
    打个比方： 当前command-loop等待查看会员详细信息的命令时，如果没有translator你就必须先输入这个命令，然后点击这个会员的头像。
    而有translator时，你直接点击这个会员头像就可以显示详细信息了。

    当然translator不只是将一种presentation翻译成命令，其实可以做为任意两种presentation之间的转换。

- frame, pane, gadget and make-pane

  - frame是CLIM中顶层的概念，相当于传统GUI Toolkit中的窗口的概念，frame中含有各种pane，pane可以是stream-pane或者各种gadget。
    frame的内的所有GUI元素的显示风格是由frame-manager定义和管理的。
  
  - pane即stream pane也是CLIM中的顶层概念，相当于传统GUI Toolkit中的各种空间的概念，各种gadget即是使用pane表现出来的传统控件。
    pane可以有composite pane用于控制布局，还有leaf pane用于实现各种功能控件或者用户交互。有一种abstract pane抽象pane，主要用来
    定义pane的行为protocol，这类pane通常作为基类，其具体表现由子类实现。

  - gadget即是实现各种传统GUI中的通用组件(如按钮，滚动条)的pane。它们通常是abstract pane，只定义这些通用组件的行为。这些行为一般是一些
    回调函数（类似于事件驱动GUI中的event handler），如push-button提供activate-callback来响应按下的动作。

    创建gadget具体对象的过程实际上是依赖于gadget类下面的实现类，因此，通常gadget使用make-pane函数来创建，该函数接受一个gadget类（抽象pane类）
    来创建与之相应的具体类的对象。而这个创建过程是在with-look-and-feel-realization的词法上下文中进行的，define-application-frame自动创建这个环境。

- output recording vs. incremental-redisplay

  在CLIM里，当你使用各种描画函数进行描画的时候，不仅仅描画的结果体现在某个sheet的medium上。每个描画函数的调用的过程（作为closure）被记录在一个历史列表中。
  这个历史列表叫做output history。这一过程就是output recording。

  这一机制的目的是当需要在该sheet上重新描画的时候（比如re-exposure, slide bar的移动等），只需根据output history中的记录回放即可。

  这一机制在stream上是默认开启的。你也可以创建额外的output-record来捕获或者重放描画。

  对于application-pane (即stream)来说，重画的时间通常是command-loop中执行完一个command后，可以通过display-time和display-function来控制
  在这个stream上的描画的时机。

  如果整个描画内容都使用output recording来重画，这个过程可能会很抵消，导致不必要的闪屏。incremental-redisplay就是为了减少不必要的
  重画而存在的机制，通过使用incremental-redisplay，程序员告诉CLIM图形中哪部分内容需要重画，哪些部分不需要，然后CLIM就只会重画要求的部分。
  这通常是使用updating-output来实现的，它接受id来区分一次描画的各个部分，接受cache来区分前后两次某个部分是否有更新。

- drawing options
  
  通常的描画，如画线、画矩形等都有许多不同的描画选项，如坐标的放射变换、线宽、颜色、字体等，这些都是由drawing options来控制的。
  通常drawing options会创造一个dynamic extent的环境，在该环境下的所有描画都会默认应用该drawing option的描画选项。

- 常用函数、宏

  - frame相关
    define-application-frame
    make-application-frame
    run-frame-top-level
    find-application-frame
    frame-exit
    *application-frame*
    with-application-frame
    map-over-frames
    raise-frame
    bury-frame
    frame-name
    frame-pretty-name
    frame-state
    frame-current-panes
    get-frame-pane
    find-pane-named
    frame-command-table
    default-frame-top-level
    redisplay-frame-panes
    
  - pane相关
    pane-frame
    make-clim-stream-pane
    make-clim-interactor-pane
    make-clim-application-pane
    pane-viewport

  - layout相关
    make-space-requirement
    compose-space
    allocate-space
    change-space-requirements
    frame-current-layout
    frame-all-layouts
    vertically
    horizontally
    tabling
    outlining
    spacing
    labelling
    scrolling

  - command
     define-command
     command-table-inherit-from
     command-table-name
     find-command-table
     define-command-table
     make-command-table
     add-command-to-command-table
     remove-command-from-command-table
     command-present-in-command-table-p
     command-accessible-in-command-table-p
     map-over-command-table-commands
     global-command-table
     display-command-table-menu
     display-command-menu
     add-menu-item-to-command-table
     remove-menu-item-from-command-table
     find-menu-item
     find-command-from-command-line-name
     map-over-command-table-names
     add-keystroke-to-command-table
     find-keystroke-item
     read-command
     read-frame-command
     execute-frame-command
     
   - presentation
     with-output-as-presentation
     present
     present-to-string
     presentation-object
     presentation-type
     *input-context*
     with-input-context
     accept
     accept-from-string
     t null boolean symbol keyword number complex real ratio character pathname
     completion member-alist member-sequence subset-completion subset
     sequence 
     or and type-or-string null-or-type token-or-type
     expression form
     define-presentation-type
     define-presentation-type-abbreviation
     presentation-typep
     presentation-subtypep
     describe-presentation-type
     highlight-presentation
     read-token
     write-token
     complete-input
     complete-from-generator
     complete-from-possibilities
     complete-from-suggestions
     suggest
     replace-input
     textual-view
     textual-dialog-view
     gadget-view
     gadget-dialog-view
     pointer-document-view
     stream-default-view
     define-presentation-translator
     define-presentation-to-command-translator
     define-drag-and-drop-translator
     find-presentation-translator
     black-area
     define-gesture-name
     add-gesture-name
     event-type
     event-sheet
     event-modifier-state
     keyboard-event-key-name
     keyboard-event-character
     pointer-event-x
     pointer-event-y
     pointer-event-button
     pointer-boundary-event-kind
     
  - gadget
    gadget-id
    gadget-client
    armed-callback
    disarmed-callback
    activate-gadget
    deactivate-gadget
    gadget-value
    value-changed-callback
    drag-callback
    activate-callback
    gadget-orientation
    gadget-rows
    gadget-label
    gadget-min-value
    gadget-max-value
    make-pane
    with-radio-box
    with-output-as-gadget
    
  - output recording
    with-new-output-record
    invoke-with-new-output-record
    with-output-to-output-record
    with-output-recording-options
    replay
    replay-output-record
    output-record-parent
    output-record-children
    add-output-record
    erase-output-record
    map-over-output-records
    map-over-output-records-containing-position
    tree-recompute-extent
    output-recording-stream-p
    stream-output-history
    stream-replay
    copy-textual-output-history
    
  - drawing options
    medium-foreground
    medium-background
    medium-ink
    medium-transformation
    medium-clipping-region
    medium-line-style
    medium-text-style
    with-drawing-options
    invoke-with-drawing-options
    make-line-style
    line-style-unit
    make-translation-transformation
    make-rotation-transformation
    make-scaling-transformation
    make-reflection-transformation
    make-transformation
    make-3-point-transformation
    +identity-transformation+
    compose-transformations
    compose-translation-with-transformation
    compose-scaling-with-transformation
    compose-transformation-with-scaling
    invert-transformation
    with-rotation
    with-translation
    with-scaling
    with-room-for-graphics
    with-local-coordinates
    with-first-quadrant-coordinates
    transform-region
    untransform-region
    transform-position
    transform-distance
    transform-rectangle
    with-text-style
    
Sep 20, 2012 在ubuntu等系统中添加启动时运行的脚本
通过update-rc.d命令，可以快速的把在/etc/init.d/ 中自定义的脚本添加到某个RC级别中去。
如 update-rc.d <script name> defaults 99

Sep 20, 2012 Common Lisp Quiz

======== backquote-comma-dot ====

Something about ,. vs. ,@ in backquotes.

A: ,. is destructive version of ,@

======== binding-streams ====

Which standardized stream variable may not be bound or assigned?

- *debug-io*

- *terminal-io*

- *query-io*

- None of the above

Ref: 21.1.2: "User programs may assign or bind any standardized stream
variable except *terminal-io*."

======== boa-acronym ====

For a "BOA constructor", what does BOA stand for?

- Beginning Of Array

- By Order of Arguments

- Bounded Operation Accessor

- Bidirectional Open Atom

Ref: defstruct

A: By Order of Arguments

======== char-code ====

What value is acceptable as the return value of (char-int #\a)?

- 32

- 97

- 10

- All of the above

Ref: The manner in which the integer is computed is implementation-dependent. If 
character has no implementation-defined attribute, the result of char-int and char-code are the same.

A: All of the above

======== cl-package-constraints-title ====

What is the title of section 11.1.2.1.2 in the CLHS?

- Constraints on the COMMON-LISP Package for Conforming Programs

- LOOP Value Accumulation Clauses

- Examples of Suppressing Keyword Argument Checking

- None of the above

Ref: 11.1.2.1.2

A: Constraints on the COMMON-LISP Package for Conorming Programs

======== cl-user-default-packages ====

What packages are in the COMMON-LISP-USER package use list?

- It is implementation-defined and no specific packages are specified

- It is implementation-defined but must include the COMMON-LISP
  package

- No packages

- COMMON-LISP and one of EXT, SYS, or IMPL

Ref: 11.1.2.2

A: It is implementation-defined but must include the COMMON-LISP package

======== deftype-optional-default ====

What is the default value for optional and keyword arguments in
DEFTYPE where no default is explicitly provided in the deftype lambda
list?

- T

- NIL

- *

- None of the above

Ref: deftype

A: *

======== digit-char-p ====

What function will return the integer 5 given the character #\5?

- PARSE-INTEGER

- CHAR-DIGIT-WEIGHT

- DIGIT-CHAR-P

- CHAR-CODE

Ref: digit-char-p

A: digit-char-p, PARSE-INTEGER is for string type.

======== dot-dot-dot-reading ====

11:01 [tcr] There's possibly another one: "Why is
          '.. or '... not valid syntax to denote a symbol?" Answer: it's
          explicitly forbidden so READ will choke on the attempt to read print
          representations of forms where the printer introduced abbreviations
          due to *print-length*/*print-level*
11:04 [tcr]
          http://www.lispworks.com/documentation/HyperSpec/Body/02_di.htm

Note that the Lisp reader will generally signal an error of type read-error when reading
an expression that been abbreviated because of length or level limits (see *print-level*,
*print-length*, and *print-lines*) due to restrictions on "..", "...", "#" followed by whitespace, and "#)".

======== eql-is-default ====

What is the default test function for most operations? [be more
precise, maybe per 17.2.1]

- EQ

- EQL

- EQUALP

- =

Ref: 17.2.1

A: EQL

======== file-position-designator ====

Which of the following is not a file position designator?

- 42

- :start

- :end

- None of the above

Ref:
file position designator n. (in a stream) a designator for a file position in that stream; that is, the symbol :statrt 
(denoting 0, the first position in the stream) , the symbol :end (denoting the last file position in that stream; i.e.,
 the position following the last element of the stream), or a file position (denoting itself)

file position n. (in a stream) a non negative integer that represents a position in the stream. ...

A: None of the above

======== format-empty-curlybrace ====

In a format string, what does "~{~}" mean?

- Nothing, it is an error to have nothing between ~{ and ~}

- Causes an infinite loop

- Uses the next argument to FORMAT as the internal format control
  string

- None of the above

Ref: 22.3.7.4

A: Uses the next argument to FORMAT as the internal format control string


======== format-hash-arg ====

What does (format nil "~#,vD" #\8 0 0 0) return?

- "8880"

- "0008"

- "0"

- None of the above

Ref: ~mincol, padchar, commachar, commaintervalD

# in mincol means read from arguments, v in padchar means read from arguments.

A: "8880"


======== get-first-element ====

Which of the following forms do NOT return the first element of LIST?

- (first list)

- (car list)

- (nth 1 list)

- None of the above

Ref: nth

(nth n list) ==  (car (nthcdr n list))

A: nth

======== implicit-tagbody ====

Which of the following macros does NOT have an implicit PROGN?

- DEFUN

- WHEN

- DOLIST

- None of the above

Ref: tagbody page

The macros in the next figure have implicit tagbodies.

do              do-external-symbols  dotimes  
do*             do-symbols           prog     
do-all-symbols  dolist               prog*    


(prog variable-list declaration . body)
    ==  (block nil (let variable-list declaration (tagbody . body)))

Figure 5-10. Macros that have implicit tagbodies.

Many places in Common Lisp involve syntax that uses implicit progns. 
That is, part of their syntax allows many forms to be written that are to be evaluated sequentially, 
discarding the results of all forms but the last and returning
the results of the last form. Such places include, but are not limited to,
the following: the body of a lambda expression; the bodies of various control and conditional forms (e.g., case, catch, progn, and when).

A: DOLIST

======== longest-function-name ====

What is the longest exported symbol name in the COMMON-LISP package?

- UPDATE-INSTANCE-FOR-REDEFINED-CLASS

- UPDATE-INSTANCE-FOR-DIFFERENT-CLASS

???

A: LEAST-NEGATIVE-NORMALIZED-DOUBLE-FLOAT 38
======== make-package-defaults ====

If you do not provide an explicit :USE argument to MAKE-PACKAGE, what
can you say about the list of packages that the newly created package
uses?

- The list consists only of the COMMON-LISP package.

- The list is implementation-dependent but always includes the
  COMMON-LISP pacakge.

- The list might be empty.

- None of the above.

use---a list of package designators. The default is implementation-defined.

A: The list might be empty.

======== not-a-function ====

Which of the following symbols does not name a Common Lisp function?

- PAIRLIS

- REVAPPEND

- CONJUGATE

- None of the above

Other possibilities: SCHAR, PHASE, MAKE-INSTANCES-OBSOLETE,
MAKE-LOAD-FORM-SAVING-SLOTS (from tcr)

A: None of the above.

======== not-a-string-designator ====

Which of the following is NOT a string designator?

- :foo

- #\x

- #xBA5

- None of the above

Ref: glossary for string designator, string function

string designator n. a designator for a string; that is, an object that
denotes a string and that is one of: a character (denoting a singleton string that
has the character as its only element), a symbol (denoting the string that is its name)
, or a string (denoting itself). The intent is that this term be consistent with the behavior
of string; implementations taht extend string must extend the meaning of this term in a 
compatible way.

A: #xBA5

======== odd-forms ====

Which form is illegal syntax? [not really syntax, but]

- (defvar *foo*)

- (aref array)

- (*)

- None of the above

A: None of the above

======== sharpquote-let ====

13:51 <stassats`> i like (let (#'1) (+ function 2)) => 3
13:51 <pjb> (let (#'1 '2) (+ function quote))

haha, a joke. #'1 read transformed to (function 1) '2 transformed to (quote 2)

(let (#'42) (+ . #'5))

======== zero-dimensional-arrays ====

Something about (aref thing) or (setf (aref thing) 42), and
(make-array nil :initial-element 42), etc.

Sep 20, 2012 Lisp History

Lisp is a family of languages with a long history. Early key ideas in Lisp were
developed by John McCarthy during the 1956 Dartmouth Summer Research Project on
Artificial Intelligence. McCarthy's motivation was to develop an algebraic list
processing language for artificial intelligence work. Implementation efforts for
early dialects of Lisp were undertaken on the IBM 704, the IBM 7090, the Digital
Equipment Corporation (DEC) PDP-1, the DEC PDP-6, and the PDP-10. The primary
dialect of Lisp between 1960 and 1965 was Lisp 1.5. By the early 1970's there
were two predominant dialects of Lisp, both arising from these early efforts:
MacLisp and Interlisp. For further information about very early Lisp dialects,
see The Anatomy of Lisp or Lisp 1.5 Programmer's Manual.

MacLisp improved on the Lisp 1.5 notion of special variables and error
handling. MacLisp also introduced the concept of functions that could take a
variable number of arguments, macros, arrays, non-local dynamic exits, fast
arithmetic, the first good Lisp compiler, and an emphasis on execution speed. By
the end of the 1970's, MacLisp was in use at over 50 sites. For further
information about Maclisp, see Maclisp Reference Manual, Revision 0 or The
Revised Maclisp Manual.

Interlisp introduced many ideas into Lisp programming environments and
methodology. One of the Interlisp ideas that influenced Common Lisp was an
iteration construct implemented by Warren Teitelman that inspired the loop macro
used both on the Lisp Machines and in MacLisp, and now in Common Lisp. For
further information about Interlisp, see Interlisp Reference Manual.

Although the first implementations of Lisp were on the IBM 704 and the IBM 7090,
later work focussed on the DEC PDP-6 and, later, PDP-10 computers, the latter
being the mainstay of Lisp and artificial intelligence work at such places as
Massachusetts Institute of Technology (MIT), Stanford University, and Carnegie
Mellon University (CMU) from the mid-1960's through much of the 1970's. The
PDP-10 computer and its predecessor the PDP-6 computer were, by design,
especially well-suited to Lisp because they had 36-bit words and 18-bit
addresses. This architecture allowed a cons cell to be stored in one word;
single instructions could extract the car and cdr parts. The PDP-6 and PDP-10
had fast, powerful stack instructions that enabled fast function calling. But
the limitations of the PDP-10 were evident by 1973: it supported a small number
of researchers using Lisp, and the small, 18-bit address space (2^18 = 262,144
words) limited the size of a single program. One response to the address space
problem was the Lisp Machine, a special-purpose computer designed to run Lisp
programs. The other response was to use general-purpose computers with address
spaces larger than 18 bits, such as the DEC VAX and the S-1 Mark IIA. For
further information about S-1 Common Lisp, see ``S-1 Common Lisp
Implementation.''

The Lisp machine concept was developed in the late 1960's. In the early 1970's,
Peter Deutsch, working with Daniel Bobrow, implemented a Lisp on the Alto, a
single-user minicomputer, using microcode to interpret a byte-code
implementation language. Shortly thereafter, Richard Greenblatt began work on a
different hardware and instruction set design at MIT. Although the Alto was not
a total success as a Lisp machine, a dialect of Interlisp known as Interlisp-D
became available on the D-series machines manufactured by Xerox---the Dorado,
Dandelion, Dandetiger, and Dove (or Daybreak). An upward-compatible extension of
MacLisp called Lisp Machine Lisp became available on the early MIT Lisp
Machines. Commercial Lisp machines from Xerox, Lisp Machines (LMI), and
Symbolics were on the market by 1981. For further information about Lisp Machine
Lisp, see Lisp Machine Manual.

During the late 1970's, Lisp Machine Lisp began to expand towards a much fuller
language. Sophisticated lambda lists, setf, multiple values, and structures like
those in Common Lisp are the results of early experimentation with programming
styles by the Lisp Machine group. Jonl White and others migrated these features
to MacLisp. Around 1980, Scott Fahlman and others at CMU began work on a Lisp to
run on the Scientific Personal Integrated Computing Environment (SPICE)
workstation. One of the goals of the project was to design a simpler dialect
than Lisp Machine Lisp.

The Macsyma group at MIT began a project during the late 1970's called the New
Implementation of Lisp (NIL) for the VAX, which was headed by White. One of the
stated goals of the NIL project was to fix many of the historic, but annoying,
problems with Lisp while retaining significant compatibility with MacLisp. At
about the same time, a research group at Stanford University and Lawrence
Livermore National Laboratory headed by Richard P. Gabriel began the design of a
Lisp to run on the S-1 Mark IIA supercomputer. S-1 Lisp, never completely
functional, was the test bed for adapting advanced compiler techniques to Lisp
implementation. Eventually the S-1 and NIL groups collaborated. For further
information about the NIL project, see ``NIL---A Perspective.''

The first effort towards Lisp standardization was made in 1969, when Anthony
Hearn and Martin Griss at the University of Utah defined Standard Lisp---a
subset of Lisp 1.5 and other dialects---to transport REDUCE, a symbolic algebra
system. During the 1970's, the Utah group implemented first a retargetable
optimizing compiler for Standard Lisp, and then an extended implementation known
as Portable Standard Lisp (PSL). By the mid 1980's, PSL ran on about a dozen
kinds of computers. For further information about Standard Lisp, see ``Standard
LISP Report.''

PSL and Franz Lisp---a MacLisp-like dialect for Unix machines---were the first
examples of widely available Lisp dialects on multiple hardware platforms.

One of the most important developments in Lisp occurred during the second half
of the 1970's: Scheme. Scheme, designed by Gerald J. Sussman and Guy L. Steele
Jr., is a simple dialect of Lisp whose design brought to Lisp some of the ideas
from programming language semantics developed in the 1960's. Sussman was one of
the prime innovators behind many other advances in Lisp technology from the late
1960's through the 1970's. The major contributions of Scheme were lexical
scoping, lexical closures, first-class continuations, and simplified syntax (no
separation of value cells and function cells). Some of these contributions made
a large impact on the design of Common Lisp. For further information about
Scheme, see IEEE Standard for the Scheme Programming Language or ``Revised^3
Report on the Algorithmic Language Scheme.''

In the late 1970's object-oriented programming concepts started to make a strong
impact on Lisp. At MIT, certain ideas from Smalltalk made their way into several
widely used programming systems. Flavors, an object-oriented programming system
with multiple inheritance, was developed at MIT for the Lisp machine community
by Howard Cannon and others. At Xerox, the experience with Smalltalk and
Knowledge Representation Language (KRL) led to the development of Lisp Object
Oriented Programming System (LOOPS) and later Common LOOPS. For further
information on Smalltalk, see Smalltalk-80: The Language and its
Implementation. For further information on Flavors, see Flavors: A
Non-Hierarchical Approach to Object-Oriented Programming.

These systems influenced the design of the Common Lisp Object System
(CLOS). CLOS was developed specifically for this standardization effort, and was
separately written up in ``Common Lisp Object System Specification.'' However,
minor details of its design have changed slightly since that publication, and
that paper should not be taken as an authoritative reference to the semantics of
the object system as described in this document.

In 1980 Symbolics and LMI were developing Lisp Machine Lisp; stock-hardware
implementation groups were developing NIL, Franz Lisp, and PSL; Xerox was
developing Interlisp; and the SPICE project at CMU was developing a MacLisp-like
dialect of Lisp called SpiceLisp.

In April 1981, after a DARPA-sponsored meeting concerning the splintered Lisp
community, Symbolics, the SPICE project, the NIL project, and the S-1 Lisp
project joined together to define Common Lisp. Initially spearheaded by White
and Gabriel, the driving force behind this grassroots effort was provided by
Fahlman, Daniel Weinreb, David Moon, Steele, and Gabriel. Common Lisp was
designed as a description of a family of languages. The primary influences on
Common Lisp were Lisp Machine Lisp, MacLisp, NIL, S-1 Lisp, Spice Lisp, and
Scheme. Common Lisp: The Language is a description of that design. Its semantics
were intentionally underspecified in places where it was felt that a tight
specification would overly constrain Common Lisp esearch and use.

In 1986 X3J13 was formed as a technical working group to produce a draft for an
ANSI Common Lisp standard. Because of the acceptance of Common Lisp, the goals
of this group differed from those of the original designers. These new goals
included stricter standardization for portability, an object-oriented
programming system, a condition system, iteration facilities, and a way to
handle large character sets. To accommodate those goals, a new language
specification, this document, was developed.

Sep 21, 2012 Brief about difference among Schemes

"The big differences between Scheme environments are about whether they compile,
compile incrementally or interpret, how they do error handling, work with the network,
the operating system, libraries external to the scheme environment, binary data,
and to some extent characters beyond the range of A-Z (that is unicode characters)"

from <<A Tour of Scheme in Gambit>>


Sep 24, 2012 Meaning of "frobbing"

v. Randomly adjusting the settings of an object, such as the dials on a piece of
equipment or the options in a software program, in an effort to learn how the object
works.

"frobbing - fiddling aimlessly with the controls to see what happens" - Steven Pinker, The Language Instinct.


Sep 24, 2012 CLOCK MONOTONIC vs. REALTIME

see man page of clock_gettime

CLOCK_REALTIME
       System-wide real-time clock.  Setting this clock requires appropriate privileges.

CLOCK_MONOTONIC
       Clock that cannot be set and represents monotonic time since  some  unspecified  starting
       point.


Sep 24, 2012 Delimited Continuation
又叫做Composable Continuation或者是Functional Continuation。
它有不同的实现，比较常见的两种是felleisen的control/prompt和Fillinski的shift/reset，
分别代表着dynamic和static两类delimited continuation。具体的区别有一些形式语言表示的研究论文可以学习下。

基本思路是把表达式的外层计算(即它的continuation)保存到一个函数中，这样就能通过调用该函数模拟传统的Continuation。
区别点是可以通过prompt或者reset来限制被保存的外层计算范围，因此得名delimtied。

Delimited支持者认为传统Continuation仅仅将Continuation作为fisrt class object，但没有将其范围作为FCO。
传统的Continuation一般会保存从顶层REPL或者叫prompt以下的所有计算，而delimited Continuation就是要将这个保存范围
放开，让它变成可以控制的对象。(这就是为什么control/prompt中界限用prompt这个词的由来。)

通过将延续计算的范围变成一级对象，它也不再像传统Continuation那样调用后将重置整个调用栈。而是可以在现有调用栈之上完成continuation的动作，
这也是它得名composable的原因。delimited continuation作为原construction比传统continuation的表示能力也大大提升。

以下是用control/prompt模拟call/cc的例子：

(define-syntax-rule (abort exp)
   (control (lambda (dummy) exp)))

(define call/cc
   (lambda (f)
     (control (lambda (k) 
                 (k (f (lambda (v) (abort (k v)))))))))

Sep 26, 2012 Common Lisp Array Type 及 Character Type
使用make-array是创建array的基本接口。它可以用来创建任何array及其子类型的对象。
array的类型，根据其自身的性质以及其包含的元素的性质，按如下分类：

array -> simple-array -+
  |                    |---> simple-vector-+-+
  -----> vector--------+		   | |
           |				   |---> simple-bit-vector
	   +---------------> bit-vector----+ |
	   |				     |
	   +---------------> string----------+-> simple-string
	   		     	|
				+--------------> base-string

simple-array是:adjustable, :displaced-to, :fill-pointer均为nil的数组，
即不可变更容量，没有fill pointer，不是指向其他数组的共享数组。

vector是dimension为一维的数组。

simple-string 是一维的含有字符类型或其子类型元素的simple array，它等同于(simple-array character (size))

simple-bit-vector 元素是bit的simple array，它等同于(simple-array bit (size))

base-string 等同于 (vector base-char)， 它代表着包含任意标准字符序列的最高效形式。

Note1:
array-dimension-limit 限制每个维度的上限，array-total-size-limit 限制所有维度总和的上限，
array-rank-limit 限制维度个数的上限，但下限要求实现至少支持7个维度。

Note2:
只有vector类型和list类型属于sequence类型，而array类型并不属于。

-----------
character 按照类型 可以分为

char -> base-char -> standard-char
   	  |
	  -----> extended-char

standard-char 是X3J13标准要求的96个标准字符，每个CL实现必须遵从的。包括non-graphic newline, graphic space, 以及字母，数字，标点符号等剩余的94个符号。

base-char 标准定义它为一个standard-char的增强类型，实现可以根据自己的需要，定义一些介于char和standard-char之间的字符。实现也可以选择让base-char等同于character。

extended-char 等同于 (and character (not base-char))，在character = base-char 的实现中，extended-char可能为空。




Sep 27, 2012 SBCL IR1中的用于新建、分割block的各种函数

- start-block
目的是把ctran（block的最后一个ctran）所在的block结束掉，
然后用ctran创建一个新的block，并把这两个block连接起来。

ctran必须是block的最后一个ctran。当它是第一个ctran即block-start时，
它什么也不做，直接返回。当它是一个中间的ctran时，会报错。

正确调用这个函数的结果是：
ctran的node变成了block的block-last，ctran变成了新创建的block的block-start
两个block通过link-blocks连接了起来。

- ctran-starts-block
目的是为ctran创建一个新的block。
如果该ctran未被使用，它将会创建新的block，成为该block的block-start，
新创建的block位于*current-component*的component-last-block前一个位置。

如果ctran已经是block-start时，将会什么都不做；如果ctran不是block-start又被使用
着将会报错。

- ensure-block-start
目的是保证ctran会是一个block的block-start

当ctran未被使用时，它会创建block，让ctran作为该block的block-start，但和ctran-starts-block
不同的时，该block不会加入*current-component*。（类似于不加入*current-component*的ctran-starts-block)

当ctran被使用，但不是block-start时，会调用node-ends-block从ctran和它的ctran-use node
间断开链接，新创建的block插入到原来block之后，而ctran变成了新创建的block的block-start。

Sep 27, 2012 SBCL DEF Internal 之 sb-c::def-ir1-translator
def-ir1-translator(定义于macro.lisp)是SBCL中用于定义 special form到IR1的翻译函数 的宏，
这些特殊的翻译函数叫做IR1 custom translator，由该宏定义并存储在(info :function :translator <special form>)中。

下面我们通过分析代码了解该宏的行为：

(defmacro def-ir1-translator (name (lambda-list start-var next-var result-var)
                              &body body)

从参数列表看，该宏接受的参数包括：
- name: special form的名字，如progn, go, block。
- lambda-list: 一个macro-style lambda-list，即special form可以接受的form，如progn的是(&rest forms), go的是(tag)
- start-var, next-var: 承接前面代码IR1表示的start ctran和连接后续代码IR1的next ctran。
- result: 可能是null如果这个special form不会返回值的话，否则就是传递给后续代码的值的lvar。
- body: 进行IR1翻译的具体代码


  (let ((fn-name (symbolicate "IR1-CONVERT-" name))
        (guard-name (symbolicate name "-GUARD")))

首先创建两个函数名字：ir1-convert-<special form>和 <special-form>-guard
前者就是翻译函数的名字，后者是当special form被apply或funcall时产生错误信息的保护函数。


    (with-unique-names (whole-var n-env)
      (multiple-value-bind (body decls doc)
          (parse-defmacro lambda-list whole-var body name "special form"
                          :environment n-env
                          :error-fun 'compiler-error
                          :wrap-block nil)
        `(progn
           (declaim (ftype (function (ctran ctran (or lvar null) t) (values))
                           ,fn-name))
           (defun ,fn-name (,start-var ,next-var ,result-var ,whole-var
                            &aux (,n-env *lexenv*))
             (declare (ignorable ,start-var ,next-var ,result-var))
             ,@decls
             ,body
             (values))

定义ir1-convert-<special form>:
通过parse-defmacro解析参数列表，解析后的新body包含了必要的代码从whole-var中把lambda-list
的参数抽取出来，并且let这些绑定到原来的body上。这样转换函数本身只需要固定的参数接口。

转换函数的类型被声明为：(function (ctran ctran (or lvar null) t) (values))
前两个参数是start和next ctran， 第三个是result lvar， 最后那个 t 就是special form包含的form，
即lambda-list中的参数。


           (progn
             (defun ,guard-name (&rest args)
               ,@(when doc (list doc))
               (declare (ignore args))
               (error 'special-form-function :name ',name))
             (let ((fun #',guard-name))
               (setf (%simple-fun-arglist fun) ',lambda-list
                     (%simple-fun-name fun) ',name
                     (symbol-function ',name) fun)
               (fmakunbound ',guard-name)))

定义<special form>-guard:
该函数防止用户把special form当函数使用，当调用special form同名的函数时，
会掷出special-form-function的错误信息。


           (setf (info :function :ir1-convert ',name) #',fn-name)
           (setf (info :function :kind ',name) :special-form)
           ',name)))))

最后，将翻译函数存入info数据库中。

存入info数据库的翻译函数，会在ir1-convert-functoid(ir1tran.lisp)中被查询和调用。

(defun ir1-convert-functoid (start next result form)
  (let* ((op (car form))
         (translator (and (symbolp op) (info :function :ir1-convert op))))
    (cond (translator
           (funcall translator start next result form))
          (t ...))))

该函数是IR1中翻译类似函数调用的form，如macro, compiler macro, special form, function的入口。

Sep 27, 2012 SBCL DEF Internal 之 define-source-transform
define-source-transform(定义于macro.lisp)是SBCL中定义 IR1阶段代码到代码变换函数 的宏。
这些代码变换函数主要针对非:notinline的全局函数(global funcion)，
由该宏定义并存储于(info :function :source-transform <function name>)中。

define-source-transform类似于用defmacro，它们都是基于symbol manipulation的代码变换。
但是有两点是和defmacro明显不同的：
1. 它只针对非:notinline的全局函数。
2. 它的第二个返回值为t时，变换将会失效。编译器将忽略代码变换，进行正常的函数调用。

define-source-transform代码变换的目的是把某些函数的调用变换为编译器希望的某些标准形式的调用，如(first x) -> (car x)
从而让编译器更好的处理和优化这些调用。这个就是所谓的open-coding，这也是为什么:notinline时，不进行变换的原因。
（见srctran.lisp开头注释）

下面我们通过代码分析下这个宏的行为：

(defmacro source-transform-lambda (lambda-list &body body)
  (with-unique-names (whole-var n-env name)
    (multiple-value-bind (body decls)
        (parse-defmacro lambda-list whole-var body "source transform" "form"
                        :environment n-env
                        :error-fun `(lambda (&rest stuff)
                                      (declare (ignore stuff))
                                      (return-from ,name
                                        (values nil t)))
                        :wrap-block nil)
      `(lambda (,whole-var &aux (,n-env *lexenv*))
         ,@decls
         (block ,name
           ,body)))))

通过parse-defmacro分析参数列表，利用whole-var和附加在body外层的let绑定将调用的函数名、参数名绑定到该宏的lambda-list的参数上，
最后返回一个执行body的匿名函数。


(defmacro define-source-transform (name lambda-list &body body)
  `(setf (info :function :source-transform ',name)
         (source-transform-lambda ,lambda-list ,@body)))

将变换函数保存到info数据库中。


存入info数据库的变换函数，会在ir1-convert-srctran(ir1tran.lisp)中被查询和调用。

(defun ir1-convert-srctran (start next result var form)
  (let ((inlinep (when (defined-fun-p var)
                   (defined-fun-inlinep var))))
    (if (eq inlinep :notinline)
        (ir1-convert-combination start next result form var)

如果是:notinline，则不open-coding，进行正常的函数调用。


        (let* ((name (leaf-source-name var))
               (transform (info :function :source-transform name)))
          (if transform
              (multiple-value-bind (transformed pass) (funcall transform form)

注意这里funcall transform后返回的是变换后的代码，这相当于defmacro的宏返回后还未被eval时的代码。


                (cond (pass
                       (ir1-convert-maybe-predicate start next result form var))

当第二个返回值为t时，则忽略变换结果。


                      (t
                       (unless (policy *lexenv* (zerop store-xref-data))
                         (record-call name (ctran-block start) *current-path*))
                       (ir1-convert start next result transformed))))
              (ir1-convert-maybe-predicate start next result form var))))))

当使用代码变换时，ir1-convert-srctran会利用变换后的form完成IR1的翻译。

另外，在IR1优化阶段，propogate-fun-change函数可能也会参考该代码变换。

Sep 28, 2012 bit rot
Bit rot, also known as bit decay, data rot, or data decay, is a colloquial computing
term used most commonly to describe a gradual decay of storage media. It may also refer
to the degradation of a software program over time.

Sep 28, 2012 SBCL DEF Internals 之 !def-boolean-attribute
SBCL编译器中诸如lambda-var, block, known function, VOP, instruction这些东西都是拥有属性的，
编译器根据它们拥有的属性来决定优化动作。!def-boolean-attribute(定义于macro.lisp)就是用来为这些东西定义属性集合的宏。

出于效率考虑，属性集合类似于C语言里以二进制整数、属性由不同的二进制位代表，通过位操作来查询和设置属性值是否含有属性集合里的某个属性。

首先我们通过代码来了解下!def-boolean-attribute的实现：

(deftype attributes () 'fixnum)
(defun compute-attribute-mask (names alist)
  (collect ((res 0 logior))
    (dolist (name names)
      (let ((mask (cdr (assoc name alist))))
        (unless mask
          (error "unknown attribute name: ~S" name))
        (res mask)))
    (res)))

根据提供的 属性名字的列表 以及 属性名字/位值的对应表，产生一个属性所对应的二进制位置1的整数掩码，即属性值。


  (def!macro !def-boolean-attribute (name &rest attribute-names)

从参数来看，!def-boolean-attribue接受一个属性集合的名字，以及这个集合中全部属性名字的列表。
从下面可以看到!def-boolean-attribute会定义出：
1. *<name>-attribute-translations*全局变量： 属性名字/位值的对应表。
2. <name>-attributep宏： 用于获取和设置属性值中包含某个属性的访问器。
3. decode-<name>-attributes函数： 把属性值转换为属性名字列表。
4. <name>-attributes宏： 把属性名字列表转换为属性值。


    (let ((translations-name (symbolicate "*" name "-ATTRIBUTE-TRANSLATIONS*"))
          (test-name (symbolicate name "-ATTRIBUTEP"))
          (decoder-name (symbolicate "DECODE-" name "-ATTRIBUTES")))
      (collect ((alist))
        (do ((mask 1 (ash mask 1))
             (names attribute-names (cdr names)))
            ((null names))
          (alist (cons (car names) mask)))

从这里可以看到属性位值是从1开始，按位左移生成的，即每个二进制位代表一个属性。


        `(progn
           (eval-when (:compile-toplevel :load-toplevel :execute)
             (defparameter ,translations-name ',(alist)))

           (defmacro ,(symbolicate name "-ATTRIBUTES") (&rest attribute-names)
             (compute-attribute-mask attribute-names ,translations-name))

           (defmacro ,test-name (attributes &rest attribute-names)
             `(logtest ,(compute-attribute-mask attribute-names
                                                ,translations-name)
                       (the attributes ,attributes)))

           (!def-boolean-attribute-setter ,test-name
                                          ,translations-name
                                          ,@attribute-names)

这里setter是通过define-setf-expander来实现的。详细请参考代码。

           (defun ,decoder-name (attributes)
             (loop for (name . mask) in ,translations-name
                   when (logtest mask attributes)
                     collect name))))))

下面我们来看看lambda-var, block, known function, vop, instruction的属性集合以及不同属性对编译的影响：
注释已经很好的解释了这些属性的含义。

(!def-boolean-attribute lambda-var
  ;; true if this variable has been declared IGNORE
  ignore
  ;; This is set by physical environment analysis if it chooses an
  ;; indirect (value cell) representation for this variable because it
  ;; is both set and closed over.
  indirect
  ;; true if the last reference has been deleted (and new references
  ;; should not be made)
  deleted
  ;; This is set by physical environment analysis if, should it be an
  ;; indirect lambda-var, an actual value cell object must be
  ;; allocated for this variable because one or more of the closures
  ;; that refer to it are not dynamic-extent.  Note that both
  ;; attributes must be set for the value-cell object to be created.
  explicit-value-cell
  )

(def!struct (lambda-var (:include basic-var))
  (flags (lambda-var-attributes)
         :type attributes)
  ...)

;;; Flags that are used to indicate various things about a block, such
;;; as what optimizations need to be done on it:
;;; -- REOPTIMIZE is set when something interesting happens the uses of a
;;;    lvar whose DEST is in this block. This indicates that the
;;;    value-driven (forward) IR1 optimizations should be done on this block.
;;; -- FLUSH-P is set when code in this block becomes potentially flushable,
;;;    usually due to an lvar's DEST becoming null.
;;; -- TYPE-CHECK is true when the type check phase should be run on this
;;;    block. IR1 optimize can introduce new blocks after type check has
;;;    already run. We need to check these blocks, but there is no point in
;;;    checking blocks we have already checked.
;;; -- DELETE-P is true when this block is used to indicate that this block
;;;    has been determined to be unreachable and should be deleted. IR1
;;;    phases should not attempt to examine or modify blocks with DELETE-P
;;;    set, since they may:
;;;     - be in the process of being deleted, or
;;;     - have no successors.
;;; -- TYPE-ASSERTED, TEST-MODIFIED
;;;    These flags are used to indicate that something in this block
;;;    might be of interest to constraint propagation. TYPE-ASSERTED
;;;    is set when an lvar type assertion is strengthened.
;;;    TEST-MODIFIED is set whenever the test for the ending IF has
;;;    changed (may be true when there is no IF.)
(!def-boolean-attribute block
  reoptimize flush-p type-check delete-p type-asserted test-modified)

(def!struct (cblock (:include sset-element)
                    (:constructor make-block (start))
                    (:constructor make-block-key)
                    (:conc-name block-)
                    (:predicate block-p))
  ...
  ;; This block's attributes: see above.
  (flags (block-attributes reoptimize flush-p type-check type-asserted
                           test-modified)
         :type attributes)
  ...)

(!def-boolean-attribute ir1
  ;; may call functions that are passed as arguments. In order to
  ;; determine what other effects are present, we must find the
  ;; effects of all arguments that may be functions.
  call
  ;; may fail to return during correct execution. Errors are O.K.
  ;; UNUSED, BEWARE OF BITROT.
  unwind
  ;; the (default) worst case. Includes all the other bad things, plus
  ;; any other possible bad thing. If this is present, the above bad
  ;; attributes will be explicitly present as well.
  any
  ;; all arguments are safe for dynamic extent.
  ;; (We used to have an UNSAFE attribute, which was basically the inverse
  ;; of this, but it was unused and bitrotted, so when we started making
  ;; use of the information we flipped the name and meaning the safe way
  ;; around.)
  dx-safe
  ;; may be constant-folded. The function has no side effects, but may
  ;; be affected by side effects on the arguments. e.g. SVREF, MAPC.
  ;; Functions that side-effect their arguments are not considered to
  ;; be foldable. Although it would be "legal" to constant fold them
  ;; (since it "is an error" to modify a constant), we choose not to
  ;; mark these functions as foldable in this database.
  foldable
  ;; may be eliminated if value is unused. The function has no side
  ;; effects except possibly cons. If a function might signal errors,
  ;; then it is not flushable even if it is movable, foldable or
  ;; unsafely-flushable. Implies UNSAFELY-FLUSHABLE. (In safe code
  ;; type checking of arguments is always performed by the caller, so
  ;; a function which SHOULD signal an error if arguments are not of
  ;; declared types may be FLUSHABLE.)
  flushable
  ;; unsafe call may be eliminated if value is unused. The function
  ;; has no side effects except possibly cons and signalling an error
  ;; in the safe code. If a function MUST signal errors, then it is
  ;; not unsafely-flushable even if it is movable or foldable.
  unsafely-flushable
  ;; return value is important, and ignoring it is probably a mistake.
  ;; Unlike the other attributes, this is used only for style
  ;; warnings and has no effect on optimization.
  important-result
  ;; may be moved with impunity. Has no side effects except possibly
  ;; consing, and is affected only by its arguments.
  ;; UNUSED, BEWARE OF BITROT.
  movable
  ;; The function is a true predicate likely to be open-coded. Convert
  ;; any non-conditional uses into (IF <pred> T NIL). Not usually
  ;; specified to DEFKNOWN, since this is implementation dependent,
  ;; and is usually automatically set by the DEFINE-VOP :CONDITIONAL
  ;; option.
  predicate
  ;; Inhibit any warning for compiling a recursive definition.
  ;; (Normally the compiler warns when compiling a recursive
  ;; definition for a known function, since it might be a botched
  ;; interpreter stub.)
  recursive
  ;; The function does explicit argument type checking, so the
  ;; declared type should not be asserted when a definition is
  ;; compiled.
  explicit-check
  ;; The function should always be translated by a VOP (i.e. it should
  ;; should never be converted into a full call).  This is used strictly
  ;; as a consistency checking mechanism inside the compiler during IR2
  ;; transformation.
  always-translatable)

(defstruct (fun-info #-sb-xc-host (:pure t))
  ;; boolean attributes of this function.
  (attributes (missing-arg) :type attributes)
  ...）

(!def-boolean-attribute vop
  any)

(!def-boolean-attribute instruction
  ;; This attribute is set if the scheduler can freely flush this
  ;; instruction if it thinks it is not needed. Examples are NOP and
  ;; instructions that have no side effect not described by the
  ;; writes.
  flushable
  ;; This attribute is set when an instruction can cause a control
  ;; transfer. For test instructions, the delay is used to determine
  ;; how many instructions follow the branch.
  branch
  ;; This attribute indicates that this ``instruction'' can be
  ;; variable length, and therefore had better never be used in a
  ;; branch delay slot.
  variable-length)

(def!struct (instruction
            (:include sset-element)
            (:conc-name inst-)
            (:constructor make-instruction (number emitter attributes delay))
            (:copier nil))
  ...
  ;; The attributes of this instruction.
  (attributes (instruction-attributes) :type sb!c:attributes)
  ...)

注意上面的这些属性定义中，只有known function的没有默认值（它会产生missing-arg的错误），
block的默认值是所有属性，其他的默认值都是空。

最后，让我们来看看针对known function的foldable属性到底意味着什么。

首先，在ir1-optimize-combination中我们找到如下代码：

(defun ir1-optimize-combination (node)
  ...
  (let (...
        (kind (basic-combination-kind node))
        ...)
    (ecase kind
      ...
      (:known
       ...
       (let ((attr (fun-info-attributes info)))
         (when (and (ir1-attributep attr foldable)
                    (not (ir1-attributep attr call))
                    (every #'constant-lvar-p args)
                    (node-lvar node))
           (constant-fold-call node)
           (return-from ir1-optimize-combination)))
       ...)))
  (values))

核心代码在when判断中，当被调函数已知，fun-info-attributes中含有foldable属性且每个参数都是常量时，可以对原被调函数进行常量替换，
即编译时计算出被调函数的返回结果，以直接返回该结果的函数或node代替原被调函数。

下面是常量替换详细过程：
(defun constant-fold-call (call)
  (let ((args (mapcar #'lvar-value (combination-args call)))
        (fun-name (combination-fun-source-name call)))
    (multiple-value-bind (values win)
        (careful-call fun-name
                      args
                      call
                      #-sb-xc-host #'compiler-style-warn
                      #+sb-xc-host #'compiler-warn
                      "constant folding")

首先从调用node中取出函数名和参数，通过careful-call在编译期对函数调用求值，计算其调用结果。(careful-call是可以产生编译期warning的apply函数（它其实内部调用apply）)，
并将结果放在values。


      (cond ((not win)
             (setf (combination-kind call) :error))

foldable函数可能会抛出error。针对抛出error的函数，我们把它的类型改为:error，它就没有一般意义上的返回值，后续也不再对其进行优化。


            ((and (proper-list-of-length-p values 1))

当返回值是单值时，进行必要的替换动作，


             (with-ir1-environment-from-node call
               (let* ((lvar (node-lvar call))
                      (prev (node-prev call))
                      (intermediate-ctran (make-ctran)))
                 (%delete-lvar-use call)
                 (setf (ctran-next prev) nil)
                 (setf (node-prev call) nil)
                 (reference-constant prev intermediate-ctran lvar
                                     (first values))
                 (link-node-to-previous-ctran call intermediate-ctran)
                 (reoptimize-lvar lvar)

将调用求值结果加入到ir1中，注意这里lvar的变化，原先call的node value的lvar现在成为call求值结果constant ref（常量值引用）的lvar。


                 (flush-combination call))))

最后call被从ir1中移除。该函数会调用flush-dest，先断掉call引用的fun和args等输入lvar，这会引起以这些lvar作为结果的block的再优化。
最后调用unlink-node把call移除掉。


            (t (let ((dummies (make-gensym-list (length args))))
                 (transform-call
                  call
                  `(lambda ,dummies
                     (declare (ignore ,@dummies))
                     (values ,@(mapcar (lambda (x) `',x) values)))
                  fun-name))))))
  (values))

如果返回结果是多值，就用一个返回该多值的匿名函数调用代替call。transform-call实际上在define-source-transform那里
已经有涉及到。我们来看看它具体的动作：

(defun transform-call (call res source-name)
  (declare (type combination call) (list res))
  (aver (and (legal-fun-name-p source-name)
             (not (eql source-name '.anonymous.))))

call是要被变换的调用的combination node。
res参数相当于define-source-transform返回的内容，即变换后的目标代码(由编译期计算出来的inline lambda)。

  (node-ends-block call)
  ...
  (with-ir1-environment-from-node call
    (with-component-last-block (*current-component*
                                (block-next (node-block call)))

      (let ((new-fun (ir1-convert-inline-lambda
                      res
                      :debug-name (debug-name 'lambda-inlined source-name)
                      :system-lambda t))
            (ref (lvar-use (combination-fun call))))
        (change-ref-leaf ref new-fun)
        (setf (combination-kind call) :full)

ir1-convert-inline-lambda的一个典型应用就是用于代码变换（或者叫inline或者叫open-coding）中对目标代码lambda的IR1的翻译。
用目标代码的IR1翻译代替原先的call中引用的fun lvar, 这样就替换掉了原先的函数。
        (locall-analyze-component *current-component*))))
  (values))

到此，我们基本已经对属性，属性的处理有了基本的了解。

Sep 29, 2012 SBCL中的link-node-to-previous-ctran, use-ctran, %use-ctran, use-continuation
这三个函数都用于node和ctran的连接：箭头代表ctran, 方框代表node，大方框代表block。

link-node-to-previous-ctran将node变成ctran的下一个node, ctran变成node的上一个ctran。
如图：
         +----+
   --c-->| n  |
   	 +----+


use-ctran的作用是当ctran未被使用过时，ctran变成node的下一个ctran，node变成ctran的上一个node。
node的block变成了ctran的block，ctran类型变成了:inside-block。
而当ctran是另一个block的开头时，会调用%use-ctran。

%use-ctran的作用是当ctran是另一个block的开头时，会连接node所在的block和ctran所在的block。
node将变成所在block的block-last，ctran所在的block变成node所在block的下一个block。

如图：
ctran未被使用时：

    +----+
    |  n |--c-->
    +----+

ctran是另一个block的block-start时

    +------+-p<->s-+-------+
    |  b1  |       |   b2  |
    |    +---+     |       |
    |    | n |   --c-->    |
    |    +---+     |       |
    |      |       |       |
    +------+       +-------+

use-continuation等同于对ctran调用use-ctran，对lvar调用use-lvar

Sep 29, 2012 SBCL DEF Internal 之 defknown

defknown(定义于macro.lisp)主要目的就是针对性质已知的特定的函数（如标准中定义的函数），
让编译器知道这些函数的相关性质，包括，函数类型、函数属性等。 编译器可以利用这些已知信息来
进行相应的优化处理，如constant propogation, source-to-souce transform等。

defknown函数会在info数据库中新增
(info :function :type <fun name>)   specifier-type
(info :function :where-from <fun name>)  固定为:declared
(info :function :kind <fun name>)   固定为:function
(info :function :info <fun name>)   函数attribute、derive-type、optimizer相关信息

下面，我们来看看defknown的代码来了解下它的行为：
(defmacro defknown (name arg-types result-type &optional (attributes '(any))
                    &body keys)

从参数来看，
name： 可以是单个source-name或者以列表形式的多个source-name，因此一个defknown可以声明多个函数。
arg-types， result-type： 函数的参数和返回值类型。
attributes: 函数的属性，默认包含any，即最坏情况。
keys:为其余%defknown所需的参数。

  #-sb-xc-host
  (when (member 'unsafe attributes)
    (style-warn "Ignoring legacy attribute UNSAFE. Replaced by its inverse: DX-SAFE.")
    (setf attributes (remove 'unsafe attributes)))
  (when (and (intersection attributes '(any call unwind))
             (intersection attributes '(movable)))
    (error "function cannot have both good and bad attributes: ~S" attributes))

好的和坏的属性不能共存。我一直好奇movable的作用，注释上不是说它不再用了吗？


  (when (member 'any attributes)
    (setq attributes (union '(call unwind) attributes)))
  (when (member 'flushable attributes)
    (pushnew 'unsafely-flushable attributes))

正如known function的属性集合定义中的注释所言，当any存在时，call和unwind都必须存在。
flushable存在时，unsafely-flushable必然存在。


  `(%defknown ',(if (and (consp name)
                         (not (legal-fun-name-p name)))
                    name
                    (list name))
              '(sfunction ,arg-types ,result-type)
              (ir1-attributes ,@attributes)
              ,@keys))

调用%defknown完成真正的info数据库注册工作。

(defun %defknown (names type attributes &key derive-type optimizer destroyed-constant-args result-arg)
  (let ((ctype (specifier-type type))
        (info (make-fun-info :attributes attributes
                             :derive-type derive-type
                             :optimizer optimizer
                             :destroyed-constant-args destroyed-constant-args
                             :result-arg result-arg)))
    (dolist (name names)
      ...
      (setf (info :function :type name) ctype)
      (setf (info :function :where-from name) :declared)
      (setf (info :function :kind name) :function)
      (setf (info :function :info name) info)))
  names)

info数据库中四种不同type信息的注册。

Oct 8, 2012 SBCL DEF Internals之deftransform

在IR1优化中，有一类针对:known类型函数的调用的IR1变换，这类变换主要利用函数调用的参数及返回值的特定类型，有针对性的对调用进行变换优化。
deftransform(定义在macro.lisp)就是定义这些变换优化的宏。

针对已知函数的特定参数及返回值类型的调用，通过deftransform将会在(info :function :info <name>)的fun-info-transforms列表中存储相应的
变换结构。变换结构中保存了变换所需的类型条件transform-type，变换函数（接受combination，返回变换结果lambda)transform-function
以及与编译警告相关的内容transform-note, transform-important。

下面我们通过分析代码进一步了解deftransform是怎么工作的：

(defmacro deftransform (name (lambda-list &optional (arg-types '*)
                                          (result-type '*)
                                          &key result policy node defun-only
                                          eval-name important)
                             &body body-decls-doc)
  (when (and eval-name defun-only)
    (error "can't specify both DEFUN-ONLY and EVAL-NAME"))

从参数来看，
name：被优化的调用的函数名、lambda-list：被优化的调用的函数形参列表、
arg-types和result-type：被优化调用的参数和返回值类型(这里指的是derived-type)，
这三个参数相当于优化的大条件，即只有同时满足这三个条件的调用才会被优化。

policy：针对调用所处的环境的编译策略加以限制，即只有满足policy的调用才会被优化。


  (multiple-value-bind (body decls doc) (parse-body body-decls-doc)
    (let ((n-args (sb!xc:gensym))
          (n-node (or node (sb!xc:gensym)))
          (n-decls (sb!xc:gensym))
          (n-lambda (sb!xc:gensym))
          (decls-body `(,@decls ,@body)))
      (multiple-value-bind (parsed-form vars)
          (parse-deftransform lambda-list
                              (if policy
                                  `((unless (policy ,n-node ,policy)
                                      (give-up-ir1-transform))
                                    ,@decls-body)
                                  body)
                              n-args
                              '(give-up-ir1-transform))

通过parse-deftransform（类似于parse-defmacro）将deftransform的body包装在一个外层的let绑定中，
将被优化的调用的参数与deftransform的lambda-list中的参数形成绑定关系。

这里需要指出的是deftransform的lambda-list参数列表有两重作用，
其一，它作为与要被优化的调用的参数对应的deftransform体内使用的参数的列表；其二，它作为transform-function对combination
变换后的结果lambda的参数列表。这里parse-deftransform的绑定是针对前者来说的。

另外，注意当policy不满足时，就会通过give-up-ir1-transform放弃本变换优化。


        (let ((stuff
               `((,n-node)
                 (let* ((,n-args (basic-combination-args ,n-node))
                        ,@(when result
                            `((,result (node-lvar ,n-node)))))
                   (multiple-value-bind (,n-lambda ,n-decls)
                       ,parsed-form
                     (if (and (consp ,n-lambda) (eq (car ,n-lambda) 'lambda))
                         ,n-lambda
                       `(lambda ,',lambda-list
                          (declare (ignorable ,@',vars))
                          ,@,n-decls
                          ,,n-lambda)))))))

创建变换结构中的transform-function变换函数的body，这个body可以看成是deftransform的body的展开。
如果deftransform的body的最后一个form是lambda表达式，则该表达式就是变换函数返回的变换后的结果lambda。
否则deftransform返回一个quoted form（以及一个可选的声明quoted form作为第二个返回值），变换函数将
把这个quoted form组装在一个空的lambda表达式中作为返回值。

          (if defun-only
              `(defun ,name ,@(when doc `(,doc)) ,@stuff)
              `(%deftransform
                ,(if eval-name name `',name)
                ,(if eval-name
                     ``(function ,,arg-types ,,result-type)
                     `'(function ,arg-types ,result-type))
                (lambda ,@stuff)
                ,doc
                ,(if important t nil))))))))

通过%deftransform，创建变换结构并将其加入(info :function :info <name>)的fun-info-transforms中。


(defun %deftransform (name type fun &optional note important)
  (let* ((ctype (specifier-type type))
         (note (or note "optimize"))
         (info (fun-info-or-lose name))
         (old (find-if (lambda (x)
                         (and (type= (transform-type x) ctype)
                              (string-equal (transform-note x) note)
                              (eq (transform-important x) important)))
                       (fun-info-transforms info))))
    (cond (old
           (style-warn 'sb!kernel:redefinition-with-deftransform
                       :transform old)
           (setf (transform-function old) fun
                 (transform-note old) note))

针对note, type, important都相同的优化变换，我们替换之。


          (t
           (push (make-transform :type ctype :function fun :note note
                                 :important important)
                 (fun-info-transforms info))))

否则，将其加入fun-info-transforms列表。


    name))

通过deftransform定义优化变换函数，将会在ir1-optimize-combination中发挥作用，下面我们来分析下这一优化过程。

(defun ir1-optimize-combination (node)
  ...
  (let (...
        (kind (basic-combination-kind node))
        ...)
    (ecase kind
      ...
      (:known
       ...
       (let ((fun (fun-info-optimizer info)))
         (unless (and fun (funcall fun node))
           ;; First give the VM a peek at the call
           (multiple-value-bind (style transform)
               (combination-implementation-style node)
             (ecase style
               (:direct
                ;; The VM knows how to handle this.
                )
               (:transform
                ;; The VM mostly knows how to handle this.  We need
                ;; to massage the call slightly, though.
                (transform-call node transform (combination-fun-source-name node)))
               (:default
                ;; Let transforms have a crack at it.
                (dolist (x (fun-info-transforms info))
                  (unless (ir1-transform node x)
                    (return)))))))))))
  (values))

在针对known类型函数的调用的优化中，ir1-transform将遍历尝试fun-info-transforms中的
优化变换，直到其中有一个成功完成优化变换为止。

(defun ir1-transform (node transform)
  (declare (type combination node) (type transform transform))
  (let* ((type (transform-type transform))
         (fun (transform-function transform))
         (constrained (fun-type-p type))
         (table (component-failed-optimizations *component-being-compiled*))

该table记录了所有IR1优化过程中失败的优化，这些失败的优化会在IR1 finalize阶段产生警告或者提示信息。


         (flame (if (transform-important transform)
                    (policy node (>= speed inhibit-warnings))
                    (policy node (> speed inhibit-warnings))))
         (*compiler-error-context* node))
    (cond ((or (not constrained)
               (valid-fun-use node type))

要求调用node符合type时，才可以进行下面的优化变换。
当constrained为nil时，表明该变换是built-in function类型，在参数和返回值上并没有对优化进行限制。

           (multiple-value-bind (severity args)
               (catch 'give-up-ir1-transform
                 (transform-call node
                                 (funcall fun node)
                                 (combination-fun-source-name node))
                 (values :none nil))

进行变换，变换成功则是:none，否则，give-up-ir1-transform会catch到各种失败的原因。
这些失败的原因分为三类：:aborted, :failure, :delayed。


             (ecase severity
               (:none
                (remhash node table)
                nil)
               (:aborted
                (setf (combination-kind node) :error)
                (when args
                  (apply #'warn args))
                (remhash node table)
                nil)
               (:failure
                (if args
                    (when flame
                      (record-optimization-failure node transform args))
                    (setf (gethash node table)
                          (remove transform (gethash node table) :key #'car)))
                t)
               (:delayed
                 (remhash node table)
                 nil))))

:aborted代表放弃对该调用的变换优化，fun-info-transforms中的后续变换也将不再尝试。
:failure代表本变换优化失败，将尝试fun-info-transforms中的后续优化。
:delayed代表优化将被推迟到目前的IR1 优化阶段之后，或者constraint propogation之后。

注意上面ecase中每个分支的返回值，只有:failure将记录优化失败，其余都将移除失败记录。

          ((and flame
                (valid-fun-use node
                               type
                               :argument-test #'types-equal-or-intersect
                               :result-test #'values-types-equal-or-intersect))
           (record-optimization-failure node transform type)
           t)
          (t
           t))))

如果类型都不匹配，必然无法进行优化，这时将根据transform-important来决定是否记录这个失败的优化。

最后，我们来看看在变换优化中的三种失败原因的实现函数：

(defun give-up-ir1-transform (&rest args)
  (throw 'give-up-ir1-transform (values :failure args)))
(defun abort-ir1-transform (&rest args)
  (throw 'give-up-ir1-transform (values :aborted args)))
(defun delay-ir1-transform (node &rest reasons)
  (let ((assoc (assoc node *delayed-ir1-transforms*)))
    (cond ((not assoc)
            (setf *delayed-ir1-transforms*
                    (acons node reasons *delayed-ir1-transforms*))
            (throw 'give-up-ir1-transform :delayed))
          ((cdr assoc)
            (dolist (reason reasons)
              (pushnew reason (cdr assoc)))
            (throw 'give-up-ir1-transform :delayed)))))

以上三个函数都极为直白，这里就不解释了。

注， 最后的最后，辨析一下deftransform和define-source-transform的区别：
前者针对的是函数调用，后者针对的是函数。
前者在IR1翻译之后，是IR1优化的一个过程。后者是IR1翻译过程的一部分，目的是将某些函数的调用(标准化)变换成编译器更容易优化的另一些函数的调用。
前者在语义基础上变换，依赖于类型、值。 后者在代码结构的基础上通过symbol manipulation进行变换。
前者针对:known函数。后者针对非:notinline函数。

两者相似处是：
都是一种变换操作，都可以放弃变换，都是针对函数调用的，两者变换返回的结果都是lambda函数。

Oct 10, 2012 git删除tag和branch
删除tag
git tag -d <tag name>
git push origin :refs/tag/<tag name>

删除branch
git tag -d <branch name>
git push origin :<branch name>

Oct 10, 2012 Common Lisp 中 Array的adjustable属性
在Common Lisp中，创建array时通常有一个:adjustable关键字参数。该参数与array的adjustable有关。
Common Lisp中对array有两种adjustable，
- expressly adjustable，指的是明确以:adjustable t指定并创建array
- actually adjustable，这个是依赖特定实现的。即对于没有明确指定为adjustable的array，实现可以选择它的属性。

那么，什么是adjustable属性呢？其实就是adjust-array函数对array来说是destructive还是functional的。
对于非adjustable的array，该函数将会返回一个修改的array副本，原array不发生变化。否则，修改将发生在原array身上，
返回的array就是被修改后的原array。

最后，通常对于actually adjustable的array，都是通过array-adjustable-p来判定的。

Oct 10, 2012 Common Lisp 中 的Array Upgrading
在CLHS中对Array Upgrading有如下绕口令似的解释：
"The upgraded array element type of a type T1 is a type T2 that is a supertype of T1 and 
that is used instead of T1 whenever T1 is used as an array element type for object creation
or type discrimination"

简而言之，在创建array的时候，你指定的:element-type仅仅是你期望被安排的类型。根据这个期望类型计算出实际的类型
这个类型可能会比你期望的要宽泛，当发生这种事情时，实际的类型就是你期望类型的upgraded type，这时候array就upgrading了。

通常可以使用upgraded-array-element-type函数来查看实现将会upgrade的类型。

最后，这种事情在complex中也同样存在。

Oct 12, 2012 SBCL DEF Internals 之 defoptimizer

defoptimizer(定义于macro.lisp)可谓是SBCL编译器中定义优化函数的多功能工具。
通过defoptimizer可以定义四种不同的优化，它们分别是derive-type, optimizer, ltn-annotate和ir2-convert。
- derive-type类型的优化存储于fun-info-derive-type中，它的作用是在IR1中根据函数调用的参数类型推导函数调用的返回结果类型，
  即根据参数的lvar类型推导lvar-dest的combination node的value类型。
- optimizer类型的优化存储于fun-info-optimizer中，是一类针对:known类型函数的调用的变换优化，它的目的与一般的
  deftransform定义的IR1变换优化的目的相同，但它不受编译器后端影响。优先度高于deftransform定义的IR1变换优化。
- ltn-annotate和ir2-convert都是针对IR2的，它们也都存储与fun-info结构中，这里暂时不深入讨论它们。

下面我们从代码上来详细了解一下defoptimizer：

(defmacro defoptimizer (what (lambda-list &optional (n-node (sb!xc:gensym))
                                          &rest vars)
                             &body body)
  (let ((name (if (symbolp what) what
                  (symbolicate (first what) "-" (second what) "-OPTIMIZER"))))

what参数支持两种形式: name 或者 (name kind)，我们可以看到根据这个参数，defoptimizer会为优化函数创建名字，
形如: <name>或者<name>-<kind>-optimizer。下面代码将创建并注册优化函数。


    (let ((n-args (gensym)))
      `(progn
        (defun ,name (,n-node ,@vars)
          (declare (ignorable ,@vars))
          (let ((,n-args (basic-combination-args ,n-node)))
            ,(parse-deftransform lambda-list body n-args
                                 `(return-from ,name nil))))

可以看到，defoptimizer和deftransform一样，通过parse-deftransform分析调用的参数，并将其绑定到lambda-list的参数上。


        ,@(when (consp what)
            `((setf (,(let ((*package* (symbol-package 'sb!c::fun-info)))
                        (symbolicate "FUN-INFO-" (second what)))

将不同种类的优化保存到fun-info-<kind>中去。


                     (fun-info-or-lose ',(first what)))
                    #',name)))))))


接下来，我们以针对+函数的derive-type优化为例，来看看defoptimizer是如何被使用的。

(defoptimizer (+ derive-type) ((x y))
  (two-arg-derive-type x y #'+-derive-type-aux #'+))

首先，通过defoptimizer定义+函数的derive-type优化函数，
这里two-arg-derive-type将根据+-derive-type-aux辅助函数返回根据x和y的类型推导后的返回值的numeric-type。

(defun +-derive-type-aux (x y same-arg)
  (if (and (numeric-type-real-p x)
           (numeric-type-real-p y))

如果x 和 y有一个不是实数类型（目前运算有复数参加的情况不进一步优化），那么就只是进行numeric contagion（具体规则参考CLHS）。


      (let ((result
             (if same-arg
                 (let ((x-int (numeric-type->interval x)))
                   (interval-add x-int x-int))
                 (interval-add (numeric-type->interval x)
                               (numeric-type->interval y))))
            (result-type (numeric-contagion x y)))

分别计算返回值的类型(通过numeric-contagion)以及返回值可能的范围(根据参数的数值范围相叠加)


        ;; If the result type is a float, we need to be sure to coerce
        ;; the bounds into the correct type.
        (when (eq (numeric-type-class result-type) 'float)
          (setf result (interval-func
                        #'(lambda (x)
                            (coerce-for-bound x (or (numeric-type-format result-type)
                                                    'float)))
                        result)))

如果是浮点数类型，要确保范围落在类型允许的边界内。


        (make-numeric-type
         :class (if (and (eq (numeric-type-class x) 'integer)
                         (eq (numeric-type-class y) 'integer))
                    ;; The sum of integers is always an integer.
                    'integer
                    (numeric-type-class result-type))
         :format (numeric-type-format result-type)
         :low (interval-low result)
         :high (interval-high result)))

最后，产生返回结果的numeric-type结构。


      ;; general contagion
      (numeric-contagion x y)))


我们已经很熟悉ir1-optimize-combination函数了，针对:known和:full类型的调用，
依据fun-info-drive-type，对调用的返回结果类型进行推导：

(defun ir1-optimize-combination (node)
   ...
          (let ((fun (fun-info-derive-type info)))
                (when fun
                  (let ((res (funcall fun node)))
                    (when res
                      (derive-node-type node (coerce-to-values res))
                      (maybe-terminate-block node nil)))))
   ...)

在IR1变换发生以后，derive-node-type是唯一正确的更新node类型的方法，直接修改node-derived-type是错误的。


(defun derive-node-type (node rtype)
  (declare (type valued-node node) (type ctype rtype))
  (let ((node-type (node-derived-type node)))
    (unless (eq node-type rtype)
      (let ((int (values-type-intersection node-type rtype))
            (lvar (node-lvar node)))

首先，获取node原有类型，并与新的类型进行intersection，以产生新的derived-type。


        (when (type/= node-type int)
          (when (and *check-consistency*
                     (eq int *empty-type*)
                     (not (eq rtype *empty-type*)))
            (let ((*compiler-error-context* node))
              (compiler-warn
               "New inferred type ~S conflicts with old type:~
                ~%  ~S~%*** possible internal error? Please report this."
               (type-specifier rtype) (type-specifier node-type))))

如果新的derive-type变成*empty-type*，说明这个更新是有冲突的，derive-type只可能尽可能的详细，但不应该是空。


          (setf (node-derived-type node) int)

更新node-derived-type字段


          ;; If the new type consists of only one object, replace the
          ;; node with a constant reference.
          (when (and (ref-p node)
                     (lambda-var-p (ref-leaf node)))
            (let ((type (single-value-type int)))
              (when (and (member-type-p type)
                         (eql 1 (member-type-size type)))
                (change-ref-leaf node (find-constant
                                       (first (member-type-members type)))))))

如果新产生的derive-type是只含有一个对象的member类型，说明返回值已知是member中的这个对象了，没有必要进行函数调用了，进行常量替换。


          (reoptimize-lvar lvar)))))

因为，node返回值node-lvar的类型发生了变化，所以需要安排再优化。


  (values))

至此，我们以初步了解了defoptimizer以及通过defoptimizer定义derive-type优化的内容。

补充：
其实defoptimizer能够定义的derive-type以及optimizer优化函数，也能够通过defknown函数的&key参数指定。

Feb 6, 2013 Agent admitted failure to sign using the key
When using authorized pubkey to access remote ssh server, if there is error like above,
run ssh-add <path-to-your-private-key>

Apr 23, 2013 Yesod approot cause IE slow
If IE acts slowly on loading pages from a Yesod webapp, check if this is a problem caused by approot.
